// Copyright 2014-present 650 Industries, Inc. All rights reserved.
// @generated by Tools/generate_natives.py

#import "EmbeddedNativeSources.h"

@implementation EmbeddedNativeSources

static NSString * const sources[] = {
  @"// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Hello, and welcome to hacking node.js!\n//\n// This file is invoked by node::Load in src/node.cc, and responsible for\n// bootstrapping the node.js core. Special caution is given to the performance\n// of the startup process, so many dependencies are invoked lazily.\n(function(process) {\n  this.global = this;\n\n  function startup() {\n    var EventEmitter = NativeModule.require('events').EventEmitter;\n\n    process.__proto__ = Object.create(EventEmitter.prototype, {\n      constructor: {\n        value: process.constructor\n      }\n    });\n    EventEmitter.call(process);\n\n    process.EventEmitter = EventEmitter; // process.EventEmitter is deprecated\n\n    // Setup the tracing module\n    NativeModule.require('tracing')._nodeInitialization(process);\n\n    // do this good and early, since it handles errors.\n    startup.processFatal();\n\n    startup.globalVariables();\n    startup.globalTimeouts();\n    startup.globalConsole();\n\n    startup.processAssert();\n    startup.processConfig();\n    startup.processNextTick();\n    startup.processStdio();\n    startup.processKillAndExit();\n    startup.processSignalHandlers();\n\n    startup.processChannel();\n\n    startup.processRawDebug();\n\n    startup.resolveArgv0();\n\n    // There are various modes that Node can run in. The most common two\n    // are running from a script and running the REPL - but there are a few\n    // others like the debugger or running --eval arguments. Here we decide\n    // which mode we run in.\n\n    if (NativeModule.exists('_third_party_main')) {\n      // To allow people to extend Node in different ways, this hook allows\n      // one to drop a file lib/_third_party_main.js into the build\n      // directory which will be executed instead of Node's normal loading.\n      process.nextTick(function() {\n        NativeModule.require('_third_party_main');\n      });\n\n    } else if (process.argv[1] == 'debug') {\n      // Start the debugger agent\n      var d = NativeModule.require('_debugger');\n      d.start();\n\n    } else if (process._eval != null) {\n      // User passed '-e' or '--eval' arguments to Node.\n      evalScript('[eval]');\n    } else if (process.argv[1]) {\n      // make process.argv[1] into a full path\n      var path = NativeModule.require('path');\n      process.argv[1] = path.resolve(process.argv[1]);\n\n      // If this is a worker in cluster mode, start up the communication\n      // channel.\n      if (process.env.NODE_UNIQUE_ID) {\n        var cluster = NativeModule.require('cluster');\n        cluster._setupWorker();\n\n        // Make sure it's not accidentally inherited by child processes.\n        delete process.env.NODE_UNIQUE_ID;\n      }\n\n      var Module = NativeModule.require('module');\n\n      if (global.v8debug &&\n          process.execArgv.some(function(arg) {\n            return arg.match(/^--debug-brk(=[0-9]*)?$/);\n          })) {\n\n        // XXX Fix this terrible hack!\n        //\n        // Give the client program a few ticks to connect.\n        // Otherwise, there's a race condition where `node debug foo.js`\n        // will not be able to connect in time to catch the first\n        // breakpoint message on line 1.\n        //\n        // A better fix would be to somehow get a message from the\n        // global.v8debug object about a connection, and runMain when\n        // that occurs.  --isaacs\n\n        var debugTimeout = +process.env.NODE_DEBUG_TIMEOUT || 50;\n        setTimeout(Module.runMain, debugTimeout);\n\n      } else {\n        // Main entry point into most programs:\n        Module.runMain();\n      }\n\n    } else {\n      var Module = NativeModule.require('module');\n\n      // If -i or --interactive were passed, or stdin is a TTY.\n      if (process._forceRepl || NativeModule.require('tty').isatty(0)) {\n        // REPL\n        var opts = {\n          useGlobal: true,\n          ignoreUndefined: false\n        };\n        if (parseInt(process.env['NODE_NO_READLINE'], 10)) {\n          opts.terminal = false;\n        }\n        if (parseInt(process.env['NODE_DISABLE_COLORS'], 10)) {\n          opts.useColors = false;\n        }\n        var repl = Module.requireRepl().start(opts);\n        repl.on('exit', function() {\n          process.exit();\n        });\n\n      } else {\n        // Read all of stdin - execute it.\n        process.stdin.setEncoding('utf8');\n\n        var code = '';\n        process.stdin.on('data', function(d) {\n          code += d;\n        });\n\n        process.stdin.on('end', function() {\n          process._eval = code;\n          evalScript('[stdin]');\n        });\n      }\n    }\n  }\n\n  startup.globalVariables = function() {\n    global.process = process;\n    global.global = global;\n    global.GLOBAL = global;\n    global.root = global;\n    global.Buffer = NativeModule.require('buffer').Buffer;\n    process.domain = null;\n    process._exiting = false;\n  };\n\n  startup.globalTimeouts = function() {\n    global.setTimeout = function() {\n      var t = NativeModule.require('timers');\n      return t.setTimeout.apply(this, arguments);\n    };\n\n    global.setInterval = function() {\n      var t = NativeModule.require('timers');\n      return t.setInterval.apply(this, arguments);\n    };\n\n    global.clearTimeout = function() {\n      var t = NativeModule.require('timers');\n      return t.clearTimeout.apply(this, arguments);\n    };\n\n    global.clearInterval = function() {\n      var t = NativeModule.require('timers');\n      return t.clearInterval.apply(this, arguments);\n    };\n\n    global.setImmediate = function() {\n      var t = NativeModule.require('timers');\n      return t.setImmediate.apply(this, arguments);\n    };\n\n    global.clearImmediate = function() {\n      var t = NativeModule.require('timers');\n      return t.clearImmediate.apply(this, arguments);\n    };\n  };\n\n  startup.globalConsole = function() {\n    global.__defineGetter__('console', function() {\n      return NativeModule.require('console');\n    });\n  };\n\n\n  startup._lazyConstants = null;\n\n  startup.lazyConstants = function() {\n    if (!startup._lazyConstants) {\n      startup._lazyConstants = process.binding('constants');\n    }\n    return startup._lazyConstants;\n  };\n\n  startup.processFatal = function() {\n    var tracing = NativeModule.require('tracing');\n    var _errorHandler = tracing._errorHandler;\n    // Cleanup\n    delete tracing._errorHandler;\n\n    process._fatalException = function(er) {\n      // First run through error handlers from asyncListener.\n      var caught = _errorHandler(er);\n\n      if (process.domain && process.domain._errorHandler)\n        caught = process.domain._errorHandler(er) || caught;\n\n      if (!caught)\n        caught = process.emit('uncaughtException', er);\n\n      // If someone handled it, then great.  otherwise, die in C++ land\n      // since that means that we'll exit the process, emit the 'exit' event\n      if (!caught) {\n        try {\n          if (!process._exiting) {\n            process._exiting = true;\n            process.emit('exit', 1);\n          }\n        } catch (er) {\n          // nothing to be done about it at this point.\n        }\n\n      // if we handled an error, then make sure any ticks get processed\n      } else {\n        var t = setImmediate(process._tickCallback);\n        // Complete hack to make sure any errors thrown from async\n        // listeners don't cause an infinite loop.\n        if (t._asyncQueue)\n          t._asyncQueue = [];\n      }\n\n      return caught;\n    };\n  };\n\n  var assert;\n  startup.processAssert = function() {\n    assert = process.assert = function(x, msg) {\n      if (!x) throw new Error(msg || 'assertion error');\n    };\n  };\n\n  startup.processConfig = function() {\n    // used for `process.config`, but not a real module\n    var config = NativeModule._source.config;\n    delete NativeModule._source.config;\n\n    // strip the gyp comment line at the beginning\n    config = config.split('\\n')\n                   .slice(1)\n                   .join('\\n')\n                   .replace(/\"/g, '\\\\\"')\n                   .replace(/'/g, '\"');\n\n    process.config = JSON.parse(config, function(key, value) {\n      if (value === 'true') return true;\n      if (value === 'false') return false;\n      return value;\n    });\n  };\n\n  startup.processNextTick = function() {\n    var tracing = NativeModule.require('tracing');\n    var nextTickQueue = [];\n    var asyncFlags = tracing._asyncFlags;\n    var _runAsyncQueue = tracing._runAsyncQueue;\n    var _loadAsyncQueue = tracing._loadAsyncQueue;\n    var _unloadAsyncQueue = tracing._unloadAsyncQueue;\n\n    // This tickInfo thing is used so that the C++ code in src/node.cc\n    // can have easy accesss to our nextTick state, and avoid unnecessary\n    var tickInfo = {};\n\n    // *Must* match Environment::TickInfo::Fields in src/env.h.\n    var kIndex = 0;\n    var kLength = 1;\n\n    // For asyncFlags.\n    // *Must* match Environment::AsyncListeners::Fields in src/env.h\n    var kCount = 0;\n\n    process.nextTick = nextTick;\n    // Needs to be accessible from beyond this scope.\n    process._tickCallback = _tickCallback;\n    process._tickDomainCallback = _tickDomainCallback;\n\n    process._setupNextTick(tickInfo, _tickCallback);\n\n    function tickDone() {\n      if (tickInfo[kLength] !== 0) {\n        if (tickInfo[kLength] <= tickInfo[kIndex]) {\n          nextTickQueue = [];\n          tickInfo[kLength] = 0;\n        } else {\n          nextTickQueue.splice(0, tickInfo[kIndex]);\n          tickInfo[kLength] = nextTickQueue.length;\n        }\n      }\n      tickInfo[kIndex] = 0;\n    }\n\n    // Run callbacks that have no domain.\n    // Using domains will cause this to be overridden.\n    function _tickCallback() {\n      var callback, hasQueue, threw, tock;\n\n      while (tickInfo[kIndex] < tickInfo[kLength]) {\n        tock = nextTickQueue[tickInfo[kIndex]++];\n        callback = tock.callback;\n        threw = true;\n        hasQueue = !!tock._asyncQueue;\n        if (hasQueue)\n          _loadAsyncQueue(tock);\n        try {\n          callback();\n          threw = false;\n        } finally {\n          if (threw)\n            tickDone();\n        }\n        if (hasQueue)\n          _unloadAsyncQueue(tock);\n        if (1e4 < tickInfo[kIndex])\n          tickDone();\n      }\n\n      tickDone();\n    }\n\n    function _tickDomainCallback() {\n      var callback, domain, hasQueue, threw, tock;\n\n      while (tickInfo[kIndex] < tickInfo[kLength]) {\n        tock = nextTickQueue[tickInfo[kIndex]++];\n        callback = tock.callback;\n        domain = tock.domain;\n        hasQueue = !!tock._asyncQueue;\n        if (hasQueue)\n          _loadAsyncQueue(tock);\n        if (domain)\n          domain.enter();\n        threw = true;\n        try {\n          callback();\n          threw = false;\n        } finally {\n          if (threw)\n            tickDone();\n        }\n        if (hasQueue)\n          _unloadAsyncQueue(tock);\n        if (1e4 < tickInfo[kIndex])\n          tickDone();\n        if (domain)\n          domain.exit();\n      }\n\n      tickDone();\n    }\n\n    function nextTick(callback) {\n      // on the way out, don't bother. it won't get fired anyway.\n      if (process._exiting)\n        return;\n\n      var obj = {\n        callback: callback,\n        domain: process.domain || null,\n        _asyncQueue: undefined\n      };\n\n      if (asyncFlags[kCount] > 0)\n        _runAsyncQueue(obj);\n\n      nextTickQueue.push(obj);\n      tickInfo[kLength]++;\n    }\n  };\n\n  function evalScript(name) {\n    var Module = NativeModule.require('module');\n    var path = NativeModule.require('path');\n    var cwd = process.cwd();\n\n    var module = new Module(name);\n    module.filename = path.join(cwd, name);\n    module.paths = Module._nodeModulePaths(cwd);\n    var script = process._eval;\n    if (!Module._contextLoad) {\n      var body = script;\n      script = 'global.__filename = ' + JSON.stringify(name) + ';\\n' +\n               'global.exports = exports;\\n' +\n               'global.module = module;\\n' +\n               'global.__dirname = __dirname;\\n' +\n               'global.require = require;\\n' +\n               'return require(\"vm\").runInThisContext(' +\n               JSON.stringify(body) + ', { filename: ' +\n               JSON.stringify(name) + ' });\\n';\n    }\n    var result = module._compile(script, name + '-wrapper');\n    if (process._print_eval) console.log(result);\n  }\n\n  function createWritableStdioStream(fd) {\n    var stream;\n    var tty_wrap = process.binding('tty_wrap');\n\n    // Note stream._type is used for test-module-load-list.js\n\n    switch (tty_wrap.guessHandleType(fd)) {\n      case 'TTY':\n        var tty = NativeModule.require('tty');\n        stream = new tty.WriteStream(fd);\n        stream._type = 'tty';\n\n        // Hack to have stream not keep the event loop alive.\n        // See https://github.com/joyent/node/issues/1726\n        if (stream._handle && stream._handle.unref) {\n          stream._handle.unref();\n        }\n        break;\n\n      case 'FILE':\n        var fs = NativeModule.require('fs');\n        stream = new fs.SyncWriteStream(fd, { autoClose: false });\n        stream._type = 'fs';\n        break;\n\n      case 'PIPE':\n      case 'TCP':\n        var net = NativeModule.require('net');\n        stream = new net.Socket({\n          fd: fd,\n          readable: false,\n          writable: true\n        });\n\n        // FIXME Should probably have an option in net.Socket to create a\n        // stream from an existing fd which is writable only. But for now\n        // we'll just add this hack and set the `readable` member to false.\n        // Test: ./node test/fixtures/echo.js < /etc/passwd\n        stream.readable = false;\n        stream.read = null;\n        stream._type = 'pipe';\n\n        // FIXME Hack to have stream not keep the event loop alive.\n        // See https://github.com/joyent/node/issues/1726\n        if (stream._handle && stream._handle.unref) {\n          stream._handle.unref();\n        }\n        break;\n\n      default:\n        // Probably an error on in uv_guess_handle()\n        throw new Error('Implement me. Unknown stream file type!');\n    }\n\n    // For supporting legacy API we put the FD here.\n    stream.fd = fd;\n\n    stream._isStdio = true;\n\n    return stream;\n  }\n\n  startup.processStdio = function() {\n    var stdin, stdout, stderr;\n\n    process.__defineGetter__('stdout', function() {\n      if (stdout) return stdout;\n      stdout = createWritableStdioStream(1);\n      stdout.destroy = stdout.destroySoon = function(er) {\n        er = er || new Error('process.stdout cannot be closed.');\n        stdout.emit('error', er);\n      };\n      if (stdout.isTTY) {\n        process.on('SIGWINCH', function() {\n          stdout._refreshSize();\n        });\n      }\n      return stdout;\n    });\n\n    process.__defineGetter__('stderr', function() {\n      if (stderr) return stderr;\n      stderr = createWritableStdioStream(2);\n      stderr.destroy = stderr.destroySoon = function(er) {\n        er = er || new Error('process.stderr cannot be closed.');\n        stderr.emit('error', er);\n      };\n      return stderr;\n    });\n\n    process.__defineGetter__('stdin', function() {\n      if (stdin) return stdin;\n\n      var tty_wrap = process.binding('tty_wrap');\n      var fd = 0;\n\n      switch (tty_wrap.guessHandleType(fd)) {\n        case 'TTY':\n          var tty = NativeModule.require('tty');\n          stdin = new tty.ReadStream(fd, {\n            highWaterMark: 0,\n            readable: true,\n            writable: false\n          });\n          break;\n\n        case 'FILE':\n          var fs = NativeModule.require('fs');\n          stdin = new fs.ReadStream(null, { fd: fd, autoClose: false });\n          break;\n\n        case 'PIPE':\n        case 'TCP':\n          var net = NativeModule.require('net');\n          stdin = new net.Socket({\n            fd: fd,\n            readable: true,\n            writable: false\n          });\n          break;\n\n        default:\n          // Probably an error on in uv_guess_handle()\n          throw new Error('Implement me. Unknown stdin file type!');\n      }\n\n      // For supporting legacy API we put the FD here.\n      stdin.fd = fd;\n\n      // stdin starts out life in a paused state, but node doesn't\n      // know yet.  Explicitly to readStop() it to put it in the\n      // not-reading state.\n      if (stdin._handle && stdin._handle.readStop) {\n        stdin._handle.reading = false;\n        stdin._readableState.reading = false;\n        stdin._handle.readStop();\n      }\n\n      // if the user calls stdin.pause(), then we need to stop reading\n      // immediately, so that the process can close down.\n      stdin.on('pause', function() {\n        if (!stdin._handle)\n          return;\n        stdin._readableState.reading = false;\n        stdin._handle.reading = false;\n        stdin._handle.readStop();\n      });\n\n      return stdin;\n    });\n\n    process.openStdin = function() {\n      process.stdin.resume();\n      return process.stdin;\n    };\n  };\n\n  startup.processKillAndExit = function() {\n    process.exitCode = 0;\n    process.exit = function(code) {\n      if (code || code === 0)\n        process.exitCode = code;\n\n      if (!process._exiting) {\n        process._exiting = true;\n        process.emit('exit', process.exitCode || 0);\n      }\n      process.reallyExit(process.exitCode || 0);\n    };\n\n    process.kill = function(pid, sig) {\n      var err;\n\n      // preserve null signal\n      if (0 === sig) {\n        err = process._kill(pid, 0);\n      } else {\n        sig = sig || 'SIGTERM';\n        if (startup.lazyConstants()[sig] &&\n            sig.slice(0, 3) === 'SIG') {\n          err = process._kill(pid, startup.lazyConstants()[sig]);\n        } else {\n          throw new Error('Unknown signal: ' + sig);\n        }\n      }\n\n      if (err) {\n        var errnoException = NativeModule.require('util')._errnoException;\n        throw errnoException(err, 'kill');\n      }\n\n      return true;\n    };\n  };\n\n  startup.processSignalHandlers = function() {\n    // Load events module in order to access prototype elements on process like\n    // process.addListener.\n    var signalWraps = {};\n    var addListener = process.addListener;\n    var removeListener = process.removeListener;\n\n    function isSignal(event) {\n      return event.slice(0, 3) === 'SIG' &&\n             startup.lazyConstants().hasOwnProperty(event);\n    }\n\n    // Wrap addListener for the special signal types\n    process.on = process.addListener = function(type, listener) {\n      if (isSignal(type) &&\n          !signalWraps.hasOwnProperty(type)) {\n        var Signal = process.binding('signal_wrap').Signal;\n        var wrap = new Signal();\n\n        wrap.unref();\n\n        wrap.onsignal = function() { process.emit(type); };\n\n        var signum = startup.lazyConstants()[type];\n        var err = wrap.start(signum);\n        if (err) {\n          wrap.close();\n          var errnoException = NativeModule.require('util')._errnoException;\n          throw errnoException(err, 'uv_signal_start');\n        }\n\n        signalWraps[type] = wrap;\n      }\n\n      return addListener.apply(this, arguments);\n    };\n\n    process.removeListener = function(type, listener) {\n      var ret = removeListener.apply(this, arguments);\n      if (isSignal(type)) {\n        assert(signalWraps.hasOwnProperty(type));\n\n        if (this.listeners(type).length === 0) {\n          signalWraps[type].close();\n          delete signalWraps[type];\n        }\n      }\n\n      return ret;\n    };\n  };\n\n\n  startup.processChannel = function() {\n    // If we were spawned with env NODE_CHANNEL_FD then load that up and\n    // start parsing data from that stream.\n    if (process.env.NODE_CHANNEL_FD) {\n      var fd = parseInt(process.env.NODE_CHANNEL_FD, 10);\n      assert(fd >= 0);\n\n      // Make sure it's not accidentally inherited by child processes.\n      delete process.env.NODE_CHANNEL_FD;\n\n      var cp = NativeModule.require('child_process');\n\n      // Load tcp_wrap to avoid situation where we might immediately receive\n      // a message.\n      // FIXME is this really necessary?\n      process.binding('tcp_wrap');\n\n      cp._forkChild(fd);\n      assert(process.send);\n    }\n  };\n\n\n  startup.processRawDebug = function() {\n    var format = NativeModule.require('util').format;\n    var rawDebug = process._rawDebug;\n    process._rawDebug = function() {\n      rawDebug(format.apply(null, arguments));\n    };\n  };\n\n\n  startup.resolveArgv0 = function() {\n    var cwd = process.cwd();\n    var isWindows = process.platform === 'win32';\n\n    // Make process.argv[0] into a full path, but only touch argv[0] if it's\n    // not a system $PATH lookup.\n    // TODO: Make this work on Windows as well.  Note that \"node\" might\n    // execute cwd\\node.exe, or some %PATH%\\node.exe on Windows,\n    // and that every directory has its own cwd, so d:node.exe is valid.\n    var argv0 = process.argv[0];\n    if (!isWindows && argv0.indexOf('/') !== -1 && argv0.charAt(0) !== '/') {\n      var path = NativeModule.require('path');\n      process.argv[0] = path.join(cwd, process.argv[0]);\n    }\n  };\n\n  // Below you find a minimal module system, which is used to load the node\n  // core modules found in lib/*.js. All core modules are compiled into the\n  // node binary, so they can be loaded faster.\n\n  var ContextifyScript = process.binding('contextify').ContextifyScript;\n  function runInThisContext(code, options) {\n    var script = new ContextifyScript(code, options);\n    return script.runInThisContext();\n  }\n\n  function NativeModule(id) {\n    this.filename = id + '.js';\n    this.id = id;\n    this.exports = {};\n    this.loaded = false;\n  }\n\n  NativeModule._source = process.binding('natives');\n  NativeModule._cache = {};\n\n  NativeModule.require = function(id) {\n    if (id == 'native_module') {\n      return NativeModule;\n    }\n\n    var cached = NativeModule.getCached(id);\n    if (cached) {\n      return cached.exports;\n    }\n\n    if (!NativeModule.exists(id)) {\n      throw new Error('No such native module ' + id);\n    }\n\n    process.moduleLoadList.push('NativeModule ' + id);\n\n    var nativeModule = new NativeModule(id);\n\n    nativeModule.cache();\n    nativeModule.compile();\n\n    return nativeModule.exports;\n  };\n\n  NativeModule.getCached = function(id) {\n    return NativeModule._cache[id];\n  }\n\n  NativeModule.exists = function(id) {\n    return NativeModule._source.hasOwnProperty(id);\n  }\n\n  NativeModule.getSource = function(id) {\n    return NativeModule._source[id];\n  }\n\n  NativeModule.wrap = function(script) {\n    return NativeModule.wrapper[0] + script + NativeModule.wrapper[1];\n  };\n\n  NativeModule.wrapper = [\n    '(function (exports, require, module, __filename, __dirname) { ',\n    '\\n});'\n  ];\n\n  NativeModule.prototype.compile = function() {\n    var source = NativeModule.getSource(this.id);\n    source = NativeModule.wrap(source);\n\n    var fn = runInThisContext(source, { filename: this.filename });\n    fn(this.exports, NativeModule.require, this, this.filename);\n\n    this.loaded = true;\n  };\n\n  NativeModule.prototype.cache = function() {\n    NativeModule._cache[this.id] = this;\n  };\n\n  startup();\n});\n",
  @"var iOS = process.binding('ios');\n\nexports.binding = function binding(name) {\n    return iOS.binding(name);\n};\n",
  @"// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar util = require('util'),\n    path = require('path'),\n    net = require('net'),\n    vm = require('vm'),\n    repl = require('repl'),\n    inherits = util.inherits,\n    assert = require('assert'),\n    spawn = require('child_process').spawn;\n\nexports.start = function(argv, stdin, stdout) {\n  argv || (argv = process.argv.slice(2));\n\n  if (argv.length < 1) {\n    console.error('Usage: node debug script.js');\n    process.exit(1);\n  }\n\n  // Setup input/output streams\n  stdin = stdin || process.stdin;\n  stdout = stdout || process.stdout;\n\n  var args = ['--debug-brk'].concat(argv),\n      interface_ = new Interface(stdin, stdout, args);\n\n  stdin.resume();\n\n  process.on('uncaughtException', function(e) {\n    console.error(\"There was an internal error in Node's debugger. \" +\n        'Please report this bug.');\n    console.error(e.message);\n    console.error(e.stack);\n    if (interface_.child) interface_.child.kill();\n    process.exit(1);\n  });\n};\n\nexports.port = 5858;\n\n\n//\n// Parser/Serializer for V8 debugger protocol\n// http://code.google.com/p/v8/wiki/DebuggerProtocol\n//\n// Usage:\n//    p = new Protocol();\n//\n//    p.onResponse = function(res) {\n//      // do stuff with response from V8\n//    };\n//\n//    socket.setEncoding('utf8');\n//    socket.on('data', function(s) {\n//      // Pass strings into the protocol\n//      p.execute(s);\n//    });\n//\n//\nfunction Protocol() {\n  this._newRes();\n}\nexports.Protocol = Protocol;\n\n\nProtocol.prototype._newRes = function(raw) {\n  this.res = { raw: raw || '', headers: {} };\n  this.state = 'headers';\n  this.reqSeq = 1;\n  this.execute('');\n};\n\n\nProtocol.prototype.execute = function(d) {\n  var res = this.res;\n  res.raw += d;\n\n  switch (this.state) {\n    case 'headers':\n      var endHeaderIndex = res.raw.indexOf('\\r\\n\\r\\n');\n\n      if (endHeaderIndex < 0) break;\n\n      var rawHeader = res.raw.slice(0, endHeaderIndex);\n      var endHeaderByteIndex = Buffer.byteLength(rawHeader, 'utf8');\n      var lines = rawHeader.split('\\r\\n');\n      for (var i = 0; i < lines.length; i++) {\n        var kv = lines[i].split(/: +/);\n        res.headers[kv[0]] = kv[1];\n      }\n\n      this.contentLength = +res.headers['Content-Length'];\n      this.bodyStartByteIndex = endHeaderByteIndex + 4;\n\n      this.state = 'body';\n\n      var len = Buffer.byteLength(res.raw, 'utf8');\n      if (len - this.bodyStartByteIndex < this.contentLength) {\n        break;\n      }\n      // pass thru\n    case 'body':\n      var resRawByteLength = Buffer.byteLength(res.raw, 'utf8');\n\n      if (resRawByteLength - this.bodyStartByteIndex >= this.contentLength) {\n        var buf = new Buffer(resRawByteLength);\n        buf.write(res.raw, 0, resRawByteLength, 'utf8');\n        res.body =\n            buf.slice(this.bodyStartByteIndex,\n                      this.bodyStartByteIndex +\n                      this.contentLength).toString('utf8');\n        // JSON parse body?\n        res.body = res.body.length ? JSON.parse(res.body) : {};\n\n        // Done!\n        this.onResponse(res);\n\n        this._newRes(buf.slice(this.bodyStartByteIndex +\n                               this.contentLength).toString('utf8'));\n      }\n      break;\n\n    default:\n      throw new Error('Unknown state');\n      break;\n  }\n};\n\n\nProtocol.prototype.serialize = function(req) {\n  req.type = 'request';\n  req.seq = this.reqSeq++;\n  var json = JSON.stringify(req);\n  return 'Content-Length: ' + Buffer.byteLength(json, 'utf8') +\n         '\\r\\n\\r\\n' + json;\n};\n\n\nvar NO_FRAME = -1;\n\nfunction Client() {\n  net.Stream.call(this);\n  var protocol = this.protocol = new Protocol(this);\n  this._reqCallbacks = [];\n  var socket = this;\n\n  this.currentFrame = NO_FRAME;\n  this.currentSourceLine = -1;\n  this.handles = {};\n  this.scripts = {};\n  this.breakpoints = [];\n\n  // Note that 'Protocol' requires strings instead of Buffers.\n  socket.setEncoding('utf8');\n  socket.on('data', function(d) {\n    protocol.execute(d);\n  });\n\n  protocol.onResponse = this._onResponse.bind(this);\n}\ninherits(Client, net.Stream);\nexports.Client = Client;\n\n\nClient.prototype._addHandle = function(desc) {\n  if (!util.isObject(desc) || !util.isNumber(desc.handle)) {\n    return;\n  }\n\n  this.handles[desc.handle] = desc;\n\n  if (desc.type == 'script') {\n    this._addScript(desc);\n  }\n};\n\n\nvar natives = process.binding('natives');\n\n\nClient.prototype._addScript = function(desc) {\n  this.scripts[desc.id] = desc;\n  if (desc.name) {\n    desc.isNative = (desc.name.replace('.js', '') in natives) ||\n                    desc.name == 'node.js';\n  }\n};\n\n\nClient.prototype._removeScript = function(desc) {\n  this.scripts[desc.id] = undefined;\n};\n\n\nClient.prototype._onResponse = function(res) {\n  var cb,\n      index = -1;\n\n  this._reqCallbacks.some(function(fn, i) {\n    if (fn.request_seq == res.body.request_seq) {\n      cb = fn;\n      index = i;\n      return true;\n    }\n  });\n\n  var self = this;\n  var handled = false;\n\n  if (res.headers.Type == 'connect') {\n    // Request a list of scripts for our own storage.\n    self.reqScripts();\n    self.emit('ready');\n    handled = true;\n\n  } else if (res.body && res.body.event == 'break') {\n    this.emit('break', res.body);\n    handled = true;\n\n  } else if (res.body && res.body.event == 'exception') {\n    this.emit('exception', res.body);\n    handled = true;\n\n  } else if (res.body && res.body.event == 'afterCompile') {\n    this._addHandle(res.body.body.script);\n    handled = true;\n\n  } else if (res.body && res.body.event == 'scriptCollected') {\n    // ???\n    this._removeScript(res.body.body.script);\n    handled = true;\n\n  }\n\n  if (cb) {\n    this._reqCallbacks.splice(index, 1);\n    handled = true;\n\n    var err = res.success === false && (res.message || true) ||\n              res.body.success === false && (res.body.message || true);\n    cb(err, res.body && res.body.body || res.body, res);\n  }\n\n  if (!handled) this.emit('unhandledResponse', res.body);\n};\n\n\nClient.prototype.req = function(req, cb) {\n  this.write(this.protocol.serialize(req));\n  cb.request_seq = req.seq;\n  this._reqCallbacks.push(cb);\n};\n\n\nClient.prototype.reqVersion = function(cb) {\n  cb = cb || function() {};\n  this.req({ command: 'version' } , function(err, body, res) {\n    if (err) return cb(err);\n    cb(null, res.body.body.V8Version, res.body.running);\n  });\n};\n\n\nClient.prototype.reqLookup = function(refs, cb) {\n  var self = this;\n\n  // TODO: We have a cache of handle's we've already seen in this.handles\n  // This can be used if we're careful.\n  var req = {\n    command: 'lookup',\n    arguments: {\n      handles: refs\n    }\n  };\n\n  cb = cb || function() {};\n  this.req(req, function(err, res) {\n    if (err) return cb(err);\n    for (var ref in res) {\n      if (util.isObject(res[ref])) {\n        self._addHandle(res[ref]);\n      }\n    }\n\n    cb(null, res);\n  });\n};\n\nClient.prototype.reqScopes = function(cb) {\n  var self = this,\n      req = {\n        command: 'scopes',\n        arguments: {}\n      };\n\n  cb = cb || function() {};\n  this.req(req, function(err, res) {\n    if (err) return cb(err);\n    var refs = res.scopes.map(function(scope) {\n      return scope.object.ref;\n    });\n\n    self.reqLookup(refs, function(err, res) {\n      if (err) return cb(err);\n\n      var globals = Object.keys(res).map(function(key) {\n        return res[key].properties.map(function(prop) {\n          return prop.name;\n        });\n      });\n\n      cb(null, globals.reverse());\n    });\n  });\n};\n\n// This is like reqEval, except it will look up the expression in each of the\n// scopes associated with the current frame.\nClient.prototype.reqEval = function(expression, cb) {\n  var self = this;\n\n  if (this.currentFrame == NO_FRAME) {\n    // Only need to eval in global scope.\n    this.reqFrameEval(expression, NO_FRAME, cb);\n    return;\n  }\n\n  cb = cb || function() {};\n  // Otherwise we need to get the current frame to see which scopes it has.\n  this.reqBacktrace(function(err, bt) {\n    if (err || !bt.frames) {\n      // ??\n      return cb(null, {});\n    }\n\n    var frame = bt.frames[self.currentFrame];\n\n    var evalFrames = frame.scopes.map(function(s) {\n      if (!s) return;\n      var x = bt.frames[s.index];\n      if (!x) return;\n      return x.index;\n    });\n\n    self._reqFramesEval(expression, evalFrames, cb);\n  });\n};\n\n\n// Finds the first scope in the array in which the expression evals.\nClient.prototype._reqFramesEval = function(expression, evalFrames, cb) {\n  if (evalFrames.length == 0) {\n    // Just eval in global scope.\n    this.reqFrameEval(expression, NO_FRAME, cb);\n    return;\n  }\n\n  var self = this;\n  var i = evalFrames.shift();\n\n  cb = cb || function() {};\n  this.reqFrameEval(expression, i, function(err, res) {\n    if (!err) return cb(null, res);\n    self._reqFramesEval(expression, evalFrames, cb);\n  });\n};\n\n\nClient.prototype.reqFrameEval = function(expression, frame, cb) {\n  var self = this;\n  var req = {\n    command: 'evaluate',\n    arguments: { expression: expression }\n  };\n\n  if (frame == NO_FRAME) {\n    req.arguments.global = true;\n  } else {\n    req.arguments.frame = frame;\n  }\n\n  cb = cb || function() {};\n  this.req(req, function(err, res) {\n    if (!err) self._addHandle(res);\n    cb(err, res);\n  });\n};\n\n\n// reqBacktrace(cb)\n// TODO: from, to, bottom\nClient.prototype.reqBacktrace = function(cb) {\n  this.req({ command: 'backtrace', arguments: { inlineRefs: true } } , cb);\n};\n\n\n// reqSetExceptionBreak(type, cb)\n// TODO: from, to, bottom\nClient.prototype.reqSetExceptionBreak = function(type, cb) {\n  this.req({\n    command: 'setexceptionbreak',\n    arguments: { type: type, enabled: true }\n  }, cb);\n};\n\n\n// Returns an array of objects like this:\n//\n//   { handle: 11,\n//     type: 'script',\n//     name: 'node.js',\n//     id: 14,\n//     lineOffset: 0,\n//     columnOffset: 0,\n//     lineCount: 562,\n//     sourceStart: '(function(process) {\\n\\n  ',\n//     sourceLength: 15939,\n//     scriptType: 2,\n//     compilationType: 0,\n//     context: { ref: 10 },\n//     text: 'node.js (lines: 562)' }\n//\nClient.prototype.reqScripts = function(cb) {\n  var self = this;\n  cb = cb || function() {};\n\n  this.req({ command: 'scripts' } , function(err, res) {\n    if (err) return cb(err);\n\n    for (var i = 0; i < res.length; i++) {\n      self._addHandle(res[i]);\n    }\n    cb(null);\n  });\n};\n\n\nClient.prototype.reqContinue = function(cb) {\n  this.currentFrame = NO_FRAME;\n  this.req({ command: 'continue' }, cb);\n};\n\nClient.prototype.listbreakpoints = function(cb) {\n  this.req({ command: 'listbreakpoints' }, cb);\n};\n\nClient.prototype.setBreakpoint = function(req, cb) {\n  req = {\n    command: 'setbreakpoint',\n    arguments: req\n  };\n\n  this.req(req, cb);\n};\n\nClient.prototype.clearBreakpoint = function(req, cb) {\n  var req = {\n    command: 'clearbreakpoint',\n    arguments: req\n  };\n\n  this.req(req, cb);\n};\n\nClient.prototype.reqSource = function(from, to, cb) {\n  var req = {\n    command: 'source',\n    fromLine: from,\n    toLine: to\n  };\n\n  this.req(req, cb);\n};\n\n\n// client.next(1, cb);\nClient.prototype.step = function(action, count, cb) {\n  var req = {\n    command: 'continue',\n    arguments: { stepaction: action, stepcount: count }\n  };\n\n  this.currentFrame = NO_FRAME;\n  this.req(req, cb);\n};\n\n\nClient.prototype.mirrorObject = function(handle, depth, cb) {\n  var self = this;\n\n  var val;\n\n  if (handle.type === 'object') {\n    // The handle looks something like this:\n    // { handle: 8,\n    //   type: 'object',\n    //   className: 'Object',\n    //   constructorFunction: { ref: 9 },\n    //   protoObject: { ref: 4 },\n    //   prototypeObject: { ref: 2 },\n    //   properties: [ { name: 'hello', propertyType: 1, ref: 10 } ],\n    //   text: '#<an Object>' }\n\n    // For now ignore the className and constructor and prototype.\n    // TJ's method of object inspection would probably be good for this:\n    // https://groups.google.com/forum/?pli=1#!topic/nodejs-dev/4gkWBOimiOg\n\n    var propertyRefs = handle.properties.map(function(p) {\n      return p.ref;\n    });\n\n    cb = cb || function() {};\n    this.reqLookup(propertyRefs, function(err, res) {\n      if (err) {\n        console.error('problem with reqLookup');\n        cb(null, handle);\n        return;\n      }\n\n      var mirror,\n          waiting = 1;\n\n      if (handle.className == 'Array') {\n        mirror = [];\n      } else if (handle.className == 'Date') {\n        mirror = new Date(handle.value);\n      } else {\n        mirror = {};\n      }\n\n\n      var keyValues = [];\n      handle.properties.forEach(function(prop, i) {\n        var value = res[prop.ref];\n        var mirrorValue;\n        if (value) {\n          mirrorValue = value.value ? value.value : value.text;\n        } else {\n          mirrorValue = '[?]';\n        }\n\n\n        if (util.isArray(mirror) && !util.isNumber(prop.name)) {\n          // Skip the 'length' property.\n          return;\n        }\n\n        keyValues[i] = {\n          name: prop.name,\n          value: mirrorValue\n        };\n        if (value && value.handle && depth > 0) {\n          waiting++;\n          self.mirrorObject(value, depth - 1, function(err, result) {\n            if (!err) keyValues[i].value = result;\n            waitForOthers();\n          });\n        }\n      });\n\n      waitForOthers();\n      function waitForOthers() {\n        if (--waiting === 0 && cb) {\n          keyValues.forEach(function(kv) {\n            mirror[kv.name] = kv.value;\n          });\n          cb(null, mirror);\n        }\n      };\n    });\n    return;\n  } else if (handle.type === 'function') {\n    val = function() {};\n  } else if (handle.type === 'null') {\n    val = null;\n  } else if (!util.isUndefined(handle.value)) {\n    val = handle.value;\n  } else if (handle.type === 'undefined') {\n    val = undefined;\n  } else {\n    val = handle;\n  }\n  process.nextTick(function() {\n    cb(null, val);\n  });\n};\n\n\nClient.prototype.fullTrace = function(cb) {\n  var self = this;\n\n  cb = cb || function() {};\n  this.reqBacktrace(function(err, trace) {\n    if (err) return cb(err);\n    if (trace.totalFrames <= 0) return cb(Error('No frames'));\n\n    var refs = [];\n\n    for (var i = 0; i < trace.frames.length; i++) {\n      var frame = trace.frames[i];\n      // looks like this:\n      // { type: 'frame',\n      //   index: 0,\n      //   receiver: { ref: 1 },\n      //   func: { ref: 0 },\n      //   script: { ref: 7 },\n      //   constructCall: false,\n      //   atReturn: false,\n      //   debuggerFrame: false,\n      //   arguments: [],\n      //   locals: [],\n      //   position: 160,\n      //   line: 7,\n      //   column: 2,\n      //   sourceLineText: '  debugger;',\n      //   scopes: [ { type: 1, index: 0 }, { type: 0, index: 1 } ],\n      //   text: '#00 blah() /home/ryan/projects/node/test-debug.js l...' }\n      refs.push(frame.script.ref);\n      refs.push(frame.func.ref);\n      refs.push(frame.receiver.ref);\n    }\n\n    self.reqLookup(refs, function(err, res) {\n      if (err) return cb(err);\n\n      for (var i = 0; i < trace.frames.length; i++) {\n        var frame = trace.frames[i];\n        frame.script = res[frame.script.ref];\n        frame.func = res[frame.func.ref];\n        frame.receiver = res[frame.receiver.ref];\n      }\n\n      cb(null, trace);\n    });\n  });\n};\n\n\n\n\n\n\nvar commands = [\n  [\n    'run (r)',\n    'cont (c)',\n    'next (n)',\n    'step (s)',\n    'out (o)',\n    'backtrace (bt)',\n    'setBreakpoint (sb)',\n    'clearBreakpoint (cb)'\n  ],\n  [\n    'watch',\n    'unwatch',\n    'watchers',\n    'repl',\n    'restart',\n    'kill',\n    'list',\n    'scripts',\n    'breakOnException',\n    'breakpoints',\n    'version'\n  ]\n];\n\n\nvar helpMessage = 'Commands: ' + commands.map(function(group) {\n  return group.join(', ');\n}).join(',\\n');\n\n\nfunction SourceUnderline(sourceText, position, repl) {\n  if (!sourceText) return '';\n\n  var head = sourceText.slice(0, position),\n      tail = sourceText.slice(position);\n\n  // Colourize char if stdout supports colours\n  if (repl.useColors) {\n    tail = tail.replace(/(.+?)([^\\w]|$)/, '\\u001b[32m$1\\u001b[39m$2');\n  }\n\n  // Return source line with coloured char at `position`\n  return [\n    head,\n    tail\n  ].join('');\n}\n\n\nfunction SourceInfo(body) {\n  var result = body.exception ? 'exception in ' : 'break in ';\n\n  if (body.script) {\n    if (body.script.name) {\n      var name = body.script.name,\n          dir = path.resolve() + '/';\n\n      // Change path to relative, if possible\n      if (name.indexOf(dir) === 0) {\n        name = name.slice(dir.length);\n      }\n\n      result += name;\n    } else {\n      result += '[unnamed]';\n    }\n  }\n  result += ':';\n  result += body.sourceLine + 1;\n\n  if (body.exception) result += '\\n' + body.exception.text;\n\n  return result;\n}\n\n// This class is the repl-enabled debugger interface which is invoked on\n// \"node debug\"\nfunction Interface(stdin, stdout, args) {\n  var self = this;\n\n  this.stdin = stdin;\n  this.stdout = stdout;\n  this.args = args;\n\n  // Two eval modes are available: controlEval and debugEval\n  // But controlEval is used by default\n  var opts = {\n    prompt: 'debug> ',\n    input: this.stdin,\n    output: this.stdout,\n    eval: this.controlEval.bind(this),\n    useGlobal: false,\n    ignoreUndefined: true\n  };\n  if (parseInt(process.env['NODE_NO_READLINE'], 10)) {\n    opts.terminal = false;\n  } else if (parseInt(process.env['NODE_FORCE_READLINE'], 10)) {\n    opts.terminal = true;\n\n    // Emulate Ctrl+C if we're emulating terminal\n    if (!this.stdout.isTTY) {\n      process.on('SIGINT', function() {\n        self.repl.rli.emit('SIGINT');\n      });\n    }\n  }\n  if (parseInt(process.env['NODE_DISABLE_COLORS'], 10)) {\n    opts.useColors = false;\n  }\n  this.repl = repl.start(opts);\n\n  // Do not print useless warning\n  repl._builtinLibs.splice(repl._builtinLibs.indexOf('repl'), 1);\n\n  // Kill child process when main process dies\n  this.repl.on('exit', function() {\n    process.exit(0);\n  });\n\n  // Handle all possible exits\n  process.on('exit', this.killChild.bind(this));\n  process.once('SIGTERM', process.exit.bind(process, 0));\n  process.once('SIGHUP', process.exit.bind(process, 0));\n\n  var proto = Interface.prototype,\n      ignored = ['pause', 'resume', 'exitRepl', 'handleBreak',\n                 'requireConnection', 'killChild', 'trySpawn',\n                 'controlEval', 'debugEval', 'print', 'childPrint',\n                 'clearline'],\n      shortcut = {\n        'run': 'r',\n        'cont': 'c',\n        'next': 'n',\n        'step': 's',\n        'out': 'o',\n        'backtrace': 'bt',\n        'setBreakpoint': 'sb',\n        'clearBreakpoint': 'cb',\n        'pause_': 'pause'\n      };\n\n  function defineProperty(key, protoKey) {\n    // Check arity\n    var fn = proto[protoKey].bind(self);\n\n    if (proto[protoKey].length === 0) {\n      Object.defineProperty(self.repl.context, key, {\n        get: fn,\n        enumerable: true,\n        configurable: false\n      });\n    } else {\n      self.repl.context[key] = fn;\n    }\n  };\n\n  // Copy all prototype methods in repl context\n  // Setup them as getters if possible\n  for (var i in proto) {\n    if (Object.prototype.hasOwnProperty.call(proto, i) &&\n        ignored.indexOf(i) === -1) {\n      defineProperty(i, i);\n      if (shortcut[i]) defineProperty(shortcut[i], i);\n    }\n  }\n\n  this.killed = false;\n  this.waiting = null;\n  this.paused = 0;\n  this.context = this.repl.context;\n  this.history = {\n    debug: [],\n    control: []\n  };\n  this.breakpoints = [];\n  this._watchers = [];\n\n  // Run script automatically\n  this.pause();\n\n  // XXX Need to figure out why we need this delay\n  setTimeout(function() {\n\n    self.run(function() {\n      self.resume();\n    });\n  }, 10);\n}\n\n\n// Stream control\n\n\nInterface.prototype.pause = function() {\n  if (this.killed || this.paused++ > 0) return this;\n  this.repl.rli.pause();\n  this.stdin.pause();\n  return this;\n};\n\nInterface.prototype.resume = function(silent) {\n  if (this.killed || this.paused === 0 || --this.paused !== 0) return this;\n  this.repl.rli.resume();\n  if (silent !== true) {\n    this.repl.displayPrompt();\n  }\n  this.stdin.resume();\n\n  if (this.waiting) {\n    this.waiting();\n    this.waiting = null;\n  }\n  return this;\n};\n\n\n// Clear current line\nInterface.prototype.clearline = function() {\n  if (this.stdout.isTTY) {\n    this.stdout.cursorTo(0);\n    this.stdout.clearLine(1);\n  } else {\n    this.stdout.write('\\b');\n  }\n};\n\n// Print text to output stream\nInterface.prototype.print = function(text, oneline) {\n  if (this.killed) return;\n  this.clearline();\n\n  this.stdout.write(util.isString(text) ? text : util.inspect(text));\n\n  if (oneline !== true) {\n    this.stdout.write('\\n');\n  }\n};\n\n// Format and print text from child process\nInterface.prototype.childPrint = function(text) {\n  this.print(text.toString().split(/\\r\\n|\\r|\\n/g).filter(function(chunk) {\n    return chunk;\n  }).map(function(chunk) {\n    return '< ' + chunk;\n  }).join('\\n'));\n  this.repl.displayPrompt(true);\n};\n\n// Errors formatting\nInterface.prototype.error = function(text) {\n  this.print(text);\n  this.resume();\n};\n\n\n// Debugger's `break` event handler\nInterface.prototype.handleBreak = function(r) {\n  var self = this;\n\n  this.pause();\n\n  // Save execution context's data\n  this.client.currentSourceLine = r.sourceLine;\n  this.client.currentSourceLineText = r.sourceLineText;\n  this.client.currentSourceColumn = r.sourceColumn;\n  this.client.currentFrame = 0;\n  this.client.currentScript = r.script && r.script.name;\n\n  // Print break data\n  this.print(SourceInfo(r));\n\n  // Show watchers' values\n  this.watchers(true, function(err) {\n    if (err) return self.error(err);\n\n    // And list source\n    self.list(2);\n\n    self.resume(true);\n  });\n};\n\n\n// Internal method for checking connection state\nInterface.prototype.requireConnection = function() {\n  if (!this.client) {\n    this.error('App isn\\'t running... Try `run` instead');\n    return false;\n  }\n  return true;\n};\n\n\n// Evals\n\n// Used for debugger's commands evaluation and execution\nInterface.prototype.controlEval = function(code, context, filename, callback) {\n  try {\n    // Repeat last command if empty line are going to be evaluated\n    if (this.repl.rli.history && this.repl.rli.history.length > 0) {\n      if (code === '\\n') {\n        code = this.repl.rli.history[0] + '\\n';\n      }\n    }\n\n    var result = vm.runInContext(code, context, filename);\n\n    // Repl should not ask for next command\n    // if current one was asynchronous.\n    if (this.paused === 0) return callback(null, result);\n\n    // Add a callback for asynchronous command\n    // (it will be automatically invoked by .resume() method\n    this.waiting = function() {\n      callback(null, result);\n    };\n  } catch (e) {\n    callback(e);\n  }\n};\n\n// Used for debugger's remote evaluation (`repl`) commands\nInterface.prototype.debugEval = function(code, context, filename, callback) {\n  if (!this.requireConnection()) return;\n\n  var self = this,\n      client = this.client;\n\n  // Repl asked for scope variables\n  if (code === '.scope') {\n    client.reqScopes(callback);\n    return;\n  }\n\n  var frame = client.currentFrame === NO_FRAME ? frame : undefined;\n\n  self.pause();\n\n  // Request remote evaluation globally or in current frame\n  client.reqFrameEval(code, frame, function(err, res) {\n    if (err) {\n      callback(err);\n      self.resume(true);\n      return;\n    }\n\n    // Request object by handles (and it's sub-properties)\n    client.mirrorObject(res, 3, function(err, mirror) {\n      callback(null, mirror);\n      self.resume(true);\n    });\n  });\n};\n\n\n// Utils\n\n// Adds spaces and prefix to number\n// maxN is a maximum number we should have space for\nfunction leftPad(n, prefix, maxN) {\n  var s = n.toString(),\n      nchars = Math.max(2, String(maxN).length) + 1,\n      nspaces = nchars - s.length - 1;\n\n  for (var i = 0; i < nspaces; i++) {\n    prefix += ' ';\n  }\n\n  return prefix + s;\n}\n\n\n// Commands\n\n\n// Print help message\nInterface.prototype.help = function() {\n  this.print(helpMessage);\n};\n\n\n// Run script\nInterface.prototype.run = function() {\n  var callback = arguments[0];\n\n  if (this.child) {\n    this.error('App is already running... Try `restart` instead');\n    callback && callback(true);\n  } else {\n    this.trySpawn(callback);\n  }\n};\n\n\n// Restart script\nInterface.prototype.restart = function() {\n  if (!this.requireConnection()) return;\n\n  var self = this;\n\n  self.pause();\n  self.killChild();\n\n  // XXX need to wait a little bit for the restart to work?\n  setTimeout(function() {\n    self.trySpawn();\n    self.resume();\n  }, 1000);\n};\n\n\n// Print version\nInterface.prototype.version = function() {\n  if (!this.requireConnection()) return;\n\n  var self = this;\n\n  this.pause();\n  this.client.reqVersion(function(err, v) {\n    if (err) {\n      self.error(err);\n    } else {\n      self.print(v);\n    }\n    self.resume();\n  });\n};\n\n// List source code\nInterface.prototype.list = function(delta) {\n  if (!this.requireConnection()) return;\n\n  delta || (delta = 5);\n\n  var self = this,\n      client = this.client,\n      from = client.currentSourceLine - delta + 1,\n      to = client.currentSourceLine + delta + 1;\n\n  self.pause();\n  client.reqSource(from, to, function(err, res) {\n    if (err || !res) {\n      self.error('You can\\'t list source code right now');\n      self.resume();\n      return;\n    }\n\n    var lines = res.source.split('\\n');\n    for (var i = 0; i < lines.length; i++) {\n      var lineno = res.fromLine + i + 1;\n      if (lineno < from || lineno > to) continue;\n\n      var current = lineno == 1 + client.currentSourceLine,\n          breakpoint = client.breakpoints.some(function(bp) {\n            return (bp.scriptReq === client.currentScript ||\n                    bp.script === client.currentScript) &&\n                    bp.line == lineno;\n          });\n\n      if (lineno == 1) {\n        // The first line needs to have the module wrapper filtered out of\n        // it.\n        var wrapper = require('module').wrapper[0];\n        lines[i] = lines[i].slice(wrapper.length);\n\n        client.currentSourceColumn -= wrapper.length;\n      }\n\n      // Highlight executing statement\n      var line;\n      if (current) {\n        line = SourceUnderline(lines[i],\n                               client.currentSourceColumn,\n                               self.repl);\n      } else {\n        line = lines[i];\n      }\n\n      var prefixChar = ' ';\n      if (current) {\n        prefixChar = '>';\n      } else if (breakpoint) {\n        prefixChar = '*';\n      }\n\n      self.print(leftPad(lineno, prefixChar, to) + ' ' + line);\n    }\n    self.resume();\n  });\n};\n\n// Print backtrace\nInterface.prototype.backtrace = function() {\n  if (!this.requireConnection()) return;\n\n  var self = this,\n      client = this.client;\n\n  self.pause();\n  client.fullTrace(function(err, bt) {\n    if (err) {\n      self.error('Can\\'t request backtrace now');\n      self.resume();\n      return;\n    }\n\n    if (bt.totalFrames == 0) {\n      self.print('(empty stack)');\n    } else {\n      var trace = [],\n          firstFrameNative = bt.frames[0].script.isNative;\n\n      for (var i = 0; i < bt.frames.length; i++) {\n        var frame = bt.frames[i];\n        if (!firstFrameNative && frame.script.isNative) break;\n\n        var text = '#' + i + ' ';\n        if (frame.func.inferredName && frame.func.inferredName.length > 0) {\n          text += frame.func.inferredName + ' ';\n        }\n        text += path.basename(frame.script.name) + ':';\n        text += (frame.line + 1) + ':' + (frame.column + 1);\n\n        trace.push(text);\n      }\n\n      self.print(trace.join('\\n'));\n    }\n\n    self.resume();\n  });\n};\n\n\n// First argument tells if it should display internal node scripts or not\n// (available only for internal debugger's functions)\nInterface.prototype.scripts = function() {\n  if (!this.requireConnection()) return;\n\n  var client = this.client,\n      displayNatives = arguments[0] || false,\n      scripts = [];\n\n  this.pause();\n  for (var id in client.scripts) {\n    var script = client.scripts[id];\n    if (util.isObject(script) && script.name) {\n      if (displayNatives ||\n          script.name == client.currentScript ||\n          !script.isNative) {\n        scripts.push(\n            (script.name == client.currentScript ? '* ' : '  ') +\n            id + ': ' +\n            path.basename(script.name)\n        );\n      }\n    }\n  }\n  this.print(scripts.join('\\n'));\n  this.resume();\n};\n\n\n// Continue execution of script\nInterface.prototype.cont = function() {\n  if (!this.requireConnection()) return;\n  this.pause();\n\n  var self = this;\n  this.client.reqContinue(function(err) {\n    if (err) self.error(err);\n    self.resume();\n  });\n};\n\n\n// Step commands generator\nInterface.stepGenerator = function(type, count) {\n  return function() {\n    if (!this.requireConnection()) return;\n\n    var self = this;\n\n    self.pause();\n    self.client.step(type, count, function(err, res) {\n      if (err) self.error(err);\n      self.resume();\n    });\n  };\n};\n\n\n// Jump to next command\nInterface.prototype.next = Interface.stepGenerator('next', 1);\n\n\n// Step in\nInterface.prototype.step = Interface.stepGenerator('in', 1);\n\n\n// Step out\nInterface.prototype.out = Interface.stepGenerator('out', 1);\n\n\n// Watch\nInterface.prototype.watch = function(expr) {\n  this._watchers.push(expr);\n};\n\n// Unwatch\nInterface.prototype.unwatch = function(expr) {\n  var index = this._watchers.indexOf(expr);\n\n  // Unwatch by expression\n  // or\n  // Unwatch by watcher number\n  this._watchers.splice(index !== -1 ? index : +expr, 1);\n};\n\n// List watchers\nInterface.prototype.watchers = function() {\n  var self = this,\n      verbose = arguments[0] || false,\n      callback = arguments[1] || function() {},\n      waiting = this._watchers.length,\n      values = [];\n\n  this.pause();\n\n  if (!waiting) {\n    this.resume();\n\n    return callback();\n  }\n\n  this._watchers.forEach(function(watcher, i) {\n    self.debugEval(watcher, null, null, function(err, value) {\n      values[i] = err ? '<error>' : value;\n      wait();\n    });\n  });\n\n  function wait() {\n    if (--waiting === 0) {\n      if (verbose) self.print('Watchers:');\n\n      self._watchers.forEach(function(watcher, i) {\n        self.print(leftPad(i, ' ', self._watchers.length - 1) +\n                   ': ' + watcher + ' = ' +\n                   JSON.stringify(values[i]));\n      });\n\n      if (verbose) self.print('');\n\n      self.resume();\n\n      callback(null);\n    }\n  }\n};\n\n// Break on exception\nInterface.prototype.breakOnException = function breakOnException() {\n  if (!this.requireConnection()) return;\n\n  var self = this;\n\n  // Break on exceptions\n  this.pause();\n  this.client.reqSetExceptionBreak('all', function(err, res) {\n    self.resume();\n  });\n};\n\n// Add breakpoint\nInterface.prototype.setBreakpoint = function(script, line,\n                                             condition, silent) {\n  if (!this.requireConnection()) return;\n\n  var self = this,\n      scriptId,\n      ambiguous;\n\n  // setBreakpoint() should insert breakpoint on current line\n  if (util.isUndefined(script)) {\n    script = this.client.currentScript;\n    line = this.client.currentSourceLine + 1;\n  }\n\n  // setBreakpoint(line-number) should insert breakpoint in current script\n  if (util.isUndefined(line) && util.isNumber(script)) {\n    line = script;\n    script = this.client.currentScript;\n  }\n\n  if (/\\(\\)$/.test(script)) {\n    // setBreakpoint('functionname()');\n    var req = {\n      type: 'function',\n      target: script.replace(/\\(\\)$/, ''),\n      condition: condition\n    };\n  } else {\n    // setBreakpoint('scriptname')\n    if (script != +script && !this.client.scripts[script]) {\n      var scripts = this.client.scripts;\n      Object.keys(scripts).forEach(function(id) {\n        if (scripts[id] &&\n            scripts[id].name &&\n            scripts[id].name.indexOf(script) !== -1) {\n          if (scriptId) {\n            ambiguous = true;\n          }\n          scriptId = id;\n        }\n      });\n    } else {\n      scriptId = script;\n    }\n\n    if (ambiguous) return this.error('Script name is ambiguous');\n    if (line <= 0) return this.error('Line should be a positive value');\n\n    var req;\n    if (scriptId) {\n      req = {\n        type: 'scriptId',\n        target: scriptId,\n        line: line - 1,\n        condition: condition\n      };\n    } else {\n      this.print('Warning: script \\'' + script + '\\' was not loaded yet.');\n      var escapedPath = script.replace(/([/\\\\.?*()^${}|[\\]])/g, '\\\\$1');\n      var scriptPathRegex = '^(.*[\\\\/\\\\\\\\])?' + escapedPath + '$';\n      req = {\n        type: 'scriptRegExp',\n        target: scriptPathRegex,\n        line: line - 1,\n        condition: condition\n      };\n    }\n  }\n\n  self.pause();\n  self.client.setBreakpoint(req, function(err, res) {\n    if (err) {\n      if (!silent) {\n        self.error(err);\n      }\n    } else {\n      if (!silent) {\n        self.list(5);\n      }\n\n      // Try load scriptId and line from response\n      if (!scriptId) {\n        scriptId = res.script_id;\n        line = res.line + 1;\n      }\n\n      // Remember this breakpoint even if scriptId is not resolved yet\n      self.client.breakpoints.push({\n        id: res.breakpoint,\n        scriptId: scriptId,\n        script: (self.client.scripts[scriptId] || {}).name,\n        line: line,\n        condition: condition,\n        scriptReq: script\n      });\n    }\n    self.resume();\n  });\n};\n\n// Clear breakpoint\nInterface.prototype.clearBreakpoint = function(script, line) {\n  if (!this.requireConnection()) return;\n\n  var ambiguous,\n      breakpoint,\n      index;\n\n  this.client.breakpoints.some(function(bp, i) {\n    if (bp.scriptId === script ||\n        bp.scriptReq === script ||\n        (bp.script && bp.script.indexOf(script) !== -1)) {\n      if (!util.isUndefined(index)) {\n        ambiguous = true;\n      }\n      if (bp.line === line) {\n        index = i;\n        breakpoint = bp.id;\n        return true;\n      }\n    }\n  });\n\n  if (ambiguous) return this.error('Script name is ambiguous');\n\n  if (util.isUndefined(breakpoint)) {\n    return this.error('Script : ' + script + ' not found');\n  }\n\n  var self = this,\n      req = {\n        breakpoint: breakpoint\n      };\n\n  self.pause();\n  self.client.clearBreakpoint(req, function(err, res) {\n    if (err) {\n      self.error(err);\n    } else {\n      self.client.breakpoints.splice(index, 1);\n      self.list(5);\n    }\n    self.resume();\n  });\n};\n\n\n// Show breakpoints\nInterface.prototype.breakpoints = function() {\n  if (!this.requireConnection()) return;\n\n  this.pause();\n  var self = this;\n  this.client.listbreakpoints(function(err, res) {\n    if (err) {\n      self.error(err);\n    } else {\n      self.print(res);\n      self.resume();\n    }\n  });\n};\n\n\n// Pause child process\nInterface.prototype.pause_ = function() {\n  if (!this.requireConnection()) return;\n\n  var self = this,\n      cmd = 'process._debugPause();';\n\n  this.pause();\n  this.client.reqFrameEval(cmd, NO_FRAME, function(err, res) {\n    if (err) {\n      self.error(err);\n    } else {\n      self.resume();\n    }\n  });\n};\n\n\n// Kill child process\nInterface.prototype.kill = function() {\n  if (!this.child) return;\n  this.killChild();\n};\n\n\n// Activate debug repl\nInterface.prototype.repl = function() {\n  if (!this.requireConnection()) return;\n\n  var self = this;\n\n  self.print('Press Ctrl + C to leave debug repl');\n\n  // Don't display any default messages\n  var listeners = this.repl.rli.listeners('SIGINT').slice(0);\n  this.repl.rli.removeAllListeners('SIGINT');\n\n  // Exit debug repl on Ctrl + C\n  this.repl.rli.once('SIGINT', function() {\n    // Restore all listeners\n    process.nextTick(function() {\n      listeners.forEach(function(listener) {\n        self.repl.rli.on('SIGINT', listener);\n      });\n    });\n\n    // Exit debug repl\n    self.exitRepl();\n  });\n\n  // Set new\n  this.repl.eval = this.debugEval.bind(this);\n  this.repl.context = {};\n\n  // Swap history\n  this.history.control = this.repl.rli.history;\n  this.repl.rli.history = this.history.debug;\n\n  this.repl.rli.setPrompt('> ');\n  this.repl.displayPrompt();\n};\n\n\n// Exit debug repl\nInterface.prototype.exitRepl = function() {\n  // Restore eval\n  this.repl.eval = this.controlEval.bind(this);\n\n  // Swap history\n  this.history.debug = this.repl.rli.history;\n  this.repl.rli.history = this.history.control;\n\n  this.repl.context = this.context;\n  this.repl.rli.setPrompt('debug> ');\n  this.repl.displayPrompt();\n};\n\n\n// Quit\nInterface.prototype.quit = function() {\n  this.killChild();\n  process.exit(0);\n};\n\n\n// Kills child process\nInterface.prototype.killChild = function() {\n  if (this.child) {\n    this.child.kill();\n    this.child = null;\n  }\n\n  if (this.client) {\n    // Save breakpoints\n    this.breakpoints = this.client.breakpoints;\n\n    this.client.destroy();\n    this.client = null;\n  }\n};\n\n\n// Spawns child process (and restores breakpoints)\nInterface.prototype.trySpawn = function(cb) {\n  var self = this,\n      breakpoints = this.breakpoints || [],\n      port = exports.port,\n      host = 'localhost',\n      childArgs = this.args;\n\n  this.killChild();\n  assert(!this.child);\n\n  if (this.args.length === 2) {\n    var match = this.args[1].match(/^([^:]+):(\\d+)$/);\n\n    if (match) {\n      // Connecting to remote debugger\n      // `node debug localhost:5858`\n      host = match[1];\n      port = parseInt(match[2], 10);\n      this.child = {\n        kill: function() {\n          // TODO Do we really need to handle it?\n        }\n      };\n    }\n  } else if (this.args.length === 3) {\n    // `node debug -p pid`\n    if (this.args[1] === '-p' && /^\\d+$/.test(this.args[2])) {\n      this.child = {\n        kill: function() {\n          // TODO Do we really need to handle it?\n        }\n      };\n      process._debugProcess(parseInt(this.args[2], 10));\n    } else {\n      var match = this.args[1].match(/^--port=(\\d+)$/);\n      if (match) {\n        // Start debugger on custom port\n        // `node debug --port=5858 app.js`\n        port = parseInt(match[1], 10);\n        childArgs = ['--debug-brk=' + port].concat(this.args.slice(2));\n      }\n    }\n  }\n\n  this.child = spawn(process.execPath, childArgs);\n\n  this.child.stdout.on('data', this.childPrint.bind(this));\n  this.child.stderr.on('data', this.childPrint.bind(this));\n\n  this.pause();\n\n  var client = self.client = new Client(),\n      connectionAttempts = 0;\n\n  client.once('ready', function() {\n    self.stdout.write(' ok\\n');\n\n    // Restore breakpoints\n    breakpoints.forEach(function(bp) {\n      self.print('Restoring breakpoint ' + bp.scriptReq + ':' + bp.line);\n      self.setBreakpoint(bp.scriptReq, bp.line, bp.condition, true);\n    });\n\n    client.on('close', function() {\n      self.pause();\n      self.print('program terminated');\n      self.resume();\n      self.client = null;\n      self.killChild();\n    });\n\n    if (cb) cb();\n    self.resume();\n  });\n\n  client.on('unhandledResponse', function(res) {\n    self.pause();\n    self.print('\\nunhandled res:' + JSON.stringify(res));\n    self.resume();\n  });\n\n  client.on('break', function(res) {\n    self.handleBreak(res.body);\n  });\n\n  client.on('exception', function(res) {\n    self.handleBreak(res.body);\n  });\n\n  client.on('error', connectError);\n  function connectError() {\n    // If it's failed to connect 4 times then don't catch the next error\n    if (connectionAttempts >= 10) {\n      client.removeListener('error', connectError);\n    }\n    setTimeout(attemptConnect, 500);\n  }\n\n  function attemptConnect() {\n    ++connectionAttempts;\n    self.stdout.write('.');\n    client.connect(port, host);\n  }\n\n  this.child.stderr.once('data', function() {\n    setImmediate(function() {\n      self.print('connecting to port ' + port + '..', true);\n      attemptConnect();\n    });\n  });\n};\n",
  @"// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar net = require('net');\nvar util = require('util');\nvar EventEmitter = require('events').EventEmitter;\nvar debug = util.debuglog('http');\n\n// New Agent code.\n\n// The largest departure from the previous implementation is that\n// an Agent instance holds connections for a variable number of host:ports.\n// Surprisingly, this is still API compatible as far as third parties are\n// concerned. The only code that really notices the difference is the\n// request object.\n\n// Another departure is that all code related to HTTP parsing is in\n// ClientRequest.onSocket(). The Agent is now *strictly*\n// concerned with managing a connection pool.\n\nfunction Agent(options) {\n  if (!(this instanceof Agent))\n    return new Agent(options);\n\n  EventEmitter.call(this);\n\n  var self = this;\n\n  self.defaultPort = 80;\n  self.protocol = 'http:';\n\n  self.options = util._extend({}, options);\n\n  // don't confuse net and make it think that we're connecting to a pipe\n  self.options.path = null;\n  self.requests = {};\n  self.sockets = {};\n  self.freeSockets = {};\n  self.keepAliveMsecs = self.options.keepAliveMsecs || 1000;\n  self.keepAlive = self.options.keepAlive || false;\n  self.maxSockets = self.options.maxSockets || Agent.defaultMaxSockets;\n  self.maxFreeSockets = self.options.maxFreeSockets || 256;\n\n  self.on('free', function(socket, options) {\n    var name = self.getName(options);\n    debug('agent.on(free)', name);\n\n    if (!socket.destroyed &&\n        self.requests[name] && self.requests[name].length) {\n      self.requests[name].shift().onSocket(socket);\n      if (self.requests[name].length === 0) {\n        // don't leak\n        delete self.requests[name];\n      }\n    } else {\n      // If there are no pending requests, then put it in\n      // the freeSockets pool, but only if we're allowed to do so.\n      var req = socket._httpMessage;\n      if (req &&\n          req.shouldKeepAlive &&\n          !socket.destroyed &&\n          self.options.keepAlive) {\n        var freeSockets = self.freeSockets[name];\n        var freeLen = freeSockets ? freeSockets.length : 0;\n        var count = freeLen;\n        if (self.sockets[name])\n          count += self.sockets[name].length;\n\n        if (count >= self.maxSockets || freeLen >= self.maxFreeSockets) {\n          self.removeSocket(socket, options);\n          socket.destroy();\n        } else {\n          freeSockets = freeSockets || [];\n          self.freeSockets[name] = freeSockets;\n          socket.setKeepAlive(true, self.keepAliveMsecs);\n          socket.unref();\n          socket._httpMessage = null;\n          self.removeSocket(socket, options);\n          freeSockets.push(socket);\n        }\n      } else {\n        self.removeSocket(socket, options);\n        socket.destroy();\n      }\n    }\n  });\n}\n\nutil.inherits(Agent, EventEmitter);\nexports.Agent = Agent;\n\nAgent.defaultMaxSockets = Infinity;\n\nAgent.prototype.createConnection = net.createConnection;\n\n// Get the key for a given set of request options\nAgent.prototype.getName = function(options) {\n  var name = '';\n\n  if (options.host)\n    name += options.host;\n  else\n    name += 'localhost';\n\n  name += ':';\n  if (options.port)\n    name += options.port;\n  name += ':';\n  if (options.localAddress)\n    name += options.localAddress;\n  name += ':';\n  return name;\n};\n\nAgent.prototype.addRequest = function(req, options) {\n  // Legacy API: addRequest(req, host, port, path)\n  if (typeof options === 'string') {\n    options = {\n      host: options,\n      port: arguments[2],\n      path: arguments[3]\n    };\n  }\n\n  var name = this.getName(options);\n  if (!this.sockets[name]) {\n    this.sockets[name] = [];\n  }\n\n  var freeLen = this.freeSockets[name] ? this.freeSockets[name].length : 0;\n  var sockLen = freeLen + this.sockets[name].length;\n\n  if (freeLen) {\n    // we have a free socket, so use that.\n    var socket = this.freeSockets[name].shift();\n    debug('have free socket');\n\n    // don't leak\n    if (!this.freeSockets[name].length)\n      delete this.freeSockets[name];\n\n    socket.ref();\n    req.onSocket(socket);\n    this.sockets[name].push(socket);\n  } else if (sockLen < this.maxSockets) {\n    debug('call onSocket', sockLen, freeLen);\n    // If we are under maxSockets create a new one.\n    req.onSocket(this.createSocket(req, options));\n  } else {\n    debug('wait for socket');\n    // We are over limit so we'll add it to the queue.\n    if (!this.requests[name]) {\n      this.requests[name] = [];\n    }\n    this.requests[name].push(req);\n  }\n};\n\nAgent.prototype.createSocket = function(req, options) {\n  var self = this;\n  options = util._extend({}, options);\n  options = util._extend(options, self.options);\n\n  options.servername = options.host;\n  if (req) {\n    var hostHeader = req.getHeader('host');\n    if (hostHeader) {\n      options.servername = hostHeader.replace(/:.*$/, '');\n    }\n  }\n\n  var name = self.getName(options);\n\n  debug('createConnection', name, options);\n  options.encoding = null;\n  var s = self.createConnection(options);\n  if (!self.sockets[name]) {\n    self.sockets[name] = [];\n  }\n  this.sockets[name].push(s);\n  debug('sockets', name, this.sockets[name].length);\n\n  function onFree() {\n    self.emit('free', s, options);\n  }\n  s.on('free', onFree);\n\n  function onClose(err) {\n    debug('CLIENT socket onClose');\n    // This is the only place where sockets get removed from the Agent.\n    // If you want to remove a socket from the pool, just close it.\n    // All socket errors end in a close event anyway.\n    self.removeSocket(s, options);\n  }\n  s.on('close', onClose);\n\n  function onRemove() {\n    // We need this function for cases like HTTP 'upgrade'\n    // (defined by WebSockets) where we need to remove a socket from the\n    // pool because it'll be locked up indefinitely\n    debug('CLIENT socket onRemove');\n    self.removeSocket(s, options);\n    s.removeListener('close', onClose);\n    s.removeListener('free', onFree);\n    s.removeListener('agentRemove', onRemove);\n  }\n  s.on('agentRemove', onRemove);\n  return s;\n};\n\nAgent.prototype.removeSocket = function(s, options) {\n  var name = this.getName(options);\n  debug('removeSocket', name, 'destroyed:', s.destroyed);\n  var sets = [this.sockets];\n\n  // If the socket was destroyed, remove it from the free buffers too.\n  if (s.destroyed)\n    sets.push(this.freeSockets);\n\n  sets.forEach(function(sockets) {\n    if (sockets[name]) {\n      var index = sockets[name].indexOf(s);\n      if (index !== -1) {\n        sockets[name].splice(index, 1);\n        // Don't leak\n        if (sockets[name].length === 0)\n          delete sockets[name];\n      }\n    }\n  });\n  if (this.requests[name] && this.requests[name].length) {\n    debug('removeSocket, have a request, make a socket');\n    var req = this.requests[name][0];\n    // If we have pending requests and a socket gets closed make a new one\n    this.createSocket(req, options).emit('free');\n  }\n};\n\nAgent.prototype.destroy = function() {\n  var sets = [this.freeSockets, this.sockets];\n  sets.forEach(function(set) {\n    Object.keys(set).forEach(function(name) {\n      set[name].forEach(function(socket) {\n        socket.destroy();\n      });\n    });\n  });\n};\n\nexports.globalAgent = new Agent();\n",
  @"// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar util = require('util');\nvar net = require('net');\nvar url = require('url');\nvar EventEmitter = require('events').EventEmitter;\nvar HTTPParser = process.binding('http_parser').HTTPParser;\nvar assert = require('assert').ok;\n\nvar common = require('_http_common');\n\nvar httpSocketSetup = common.httpSocketSetup;\nvar parsers = common.parsers;\nvar freeParser = common.freeParser;\nvar debug = common.debug;\n\nvar OutgoingMessage = require('_http_outgoing').OutgoingMessage;\n\nvar Agent = require('_http_agent');\n\n\nfunction ClientRequest(options, cb) {\n  var self = this;\n  OutgoingMessage.call(self);\n\n  if (util.isString(options)) {\n    options = url.parse(options);\n  } else {\n    options = util._extend({}, options);\n  }\n\n  var agent = options.agent;\n  var defaultAgent = options._defaultAgent || Agent.globalAgent;\n  if (agent === false) {\n    agent = new defaultAgent.constructor();\n  } else if (util.isNullOrUndefined(agent) && !options.createConnection) {\n    agent = defaultAgent;\n  }\n  self.agent = agent;\n\n  var protocol = options.protocol || defaultAgent.protocol;\n  var expectedProtocol = defaultAgent.protocol;\n  if (self.agent && self.agent.protocol)\n    expectedProtocol = self.agent.protocol;\n\n  if (options.path && / /.test(options.path)) {\n    // The actual regex is more like /[^A-Za-z0-9\\-._~!$&'()*+,;=/:@]/\n    // with an additional rule for ignoring percentage-escaped characters\n    // but that's a) hard to capture in a regular expression that performs\n    // well, and b) possibly too restrictive for real-world usage. That's\n    // why it only scans for spaces because those are guaranteed to create\n    // an invalid request.\n    throw new TypeError('Request path contains unescaped characters.');\n  } else if (protocol !== expectedProtocol) {\n    throw new Error('Protocol \"' + protocol + '\" not supported. ' +\n                    'Expected \"' + expectedProtocol + '\".');\n  }\n\n  var defaultPort = options.defaultPort || self.agent && self.agent.defaultPort;\n\n  var port = options.port = options.port || defaultPort || 80;\n  var host = options.host = options.hostname || options.host || 'localhost';\n\n  if (util.isUndefined(options.setHost)) {\n    var setHost = true;\n  }\n\n  self.socketPath = options.socketPath;\n\n  var method = self.method = (options.method || 'GET').toUpperCase();\n  self.path = options.path || '/';\n  if (cb) {\n    self.once('response', cb);\n  }\n\n  if (!util.isArray(options.headers)) {\n    if (options.headers) {\n      var keys = Object.keys(options.headers);\n      for (var i = 0, l = keys.length; i < l; i++) {\n        var key = keys[i];\n        self.setHeader(key, options.headers[key]);\n      }\n    }\n    if (host && !this.getHeader('host') && setHost) {\n      var hostHeader = host;\n      if (port && +port !== defaultPort) {\n        hostHeader += ':' + port;\n      }\n      this.setHeader('Host', hostHeader);\n    }\n  }\n\n  if (options.auth && !this.getHeader('Authorization')) {\n    //basic auth\n    this.setHeader('Authorization', 'Basic ' +\n                   new Buffer(options.auth).toString('base64'));\n  }\n\n  if (method === 'GET' ||\n      method === 'HEAD' ||\n      method === 'DELETE' ||\n      method === 'OPTIONS' ||\n      method === 'CONNECT') {\n    self.useChunkedEncodingByDefault = false;\n  } else {\n    self.useChunkedEncodingByDefault = true;\n  }\n\n  if (util.isArray(options.headers)) {\n    self._storeHeader(self.method + ' ' + self.path + ' HTTP/1.1\\r\\n',\n                      options.headers);\n  } else if (self.getHeader('expect')) {\n    self._storeHeader(self.method + ' ' + self.path + ' HTTP/1.1\\r\\n',\n                      self._renderHeaders());\n  }\n\n  if (self.socketPath) {\n    self._last = true;\n    self.shouldKeepAlive = false;\n    var conn = self.agent.createConnection({ path: self.socketPath });\n    self.onSocket(conn);\n  } else if (self.agent) {\n    // If there is an agent we should default to Connection:keep-alive,\n    // but only if the Agent will actually reuse the connection!\n    // If it's not a keepAlive agent, and the maxSockets==Infinity, then\n    // there's never a case where this socket will actually be reused\n    if (!self.agent.keepAlive && !Number.isFinite(self.agent.maxSockets)) {\n      self._last = true;\n      self.shouldKeepAlive = false;\n    } else {\n      self._last = false;\n      self.shouldKeepAlive = true;\n    }\n    self.agent.addRequest(self, options);\n  } else {\n    // No agent, default to Connection:close.\n    self._last = true;\n    self.shouldKeepAlive = false;\n    if (options.createConnection) {\n      var conn = options.createConnection(options);\n    } else {\n      debug('CLIENT use net.createConnection', options);\n      var conn = net.createConnection(options);\n    }\n    self.onSocket(conn);\n  }\n\n  self._deferToConnect(null, null, function() {\n    self._flush();\n    self = null;\n  });\n}\n\nutil.inherits(ClientRequest, OutgoingMessage);\n\nexports.ClientRequest = ClientRequest;\n\nClientRequest.prototype.aborted = undefined;\n\nClientRequest.prototype._finish = function() {\n  DTRACE_HTTP_CLIENT_REQUEST(this, this.connection);\n  COUNTER_HTTP_CLIENT_REQUEST();\n  OutgoingMessage.prototype._finish.call(this);\n};\n\nClientRequest.prototype._implicitHeader = function() {\n  this._storeHeader(this.method + ' ' + this.path + ' HTTP/1.1\\r\\n',\n                    this._renderHeaders());\n};\n\nClientRequest.prototype.abort = function() {\n  // Mark as aborting so we can avoid sending queued request data\n  // This is used as a truthy flag elsewhere. The use of Date.now is for\n  // debugging purposes only.\n  this.aborted = Date.now();\n\n  // If we're aborting, we don't care about any more response data.\n  if (this.res)\n    this.res._dump();\n  else\n    this.once('response', function(res) {\n      res._dump();\n    });\n\n  // In the event that we don't have a socket, we will pop out of\n  // the request queue through handling in onSocket.\n  if (this.socket) {\n    // in-progress\n    this.socket.destroy();\n  }\n};\n\n\nfunction createHangUpError() {\n  var error = new Error('socket hang up');\n  error.code = 'ECONNRESET';\n  return error;\n}\n\n\nfunction socketCloseListener() {\n  var socket = this;\n  var req = socket._httpMessage;\n  debug('HTTP socket close');\n\n  // Pull through final chunk, if anything is buffered.\n  // the ondata function will handle it properly, and this\n  // is a no-op if no final chunk remains.\n  socket.read();\n\n  // NOTE: Its important to get parser here, because it could be freed by\n  // the `socketOnData`.\n  var parser = socket.parser;\n  req.emit('close');\n  if (req.res && req.res.readable) {\n    // Socket closed before we emitted 'end' below.\n    req.res.emit('aborted');\n    var res = req.res;\n    res.on('end', function() {\n      res.emit('close');\n    });\n    res.push(null);\n  } else if (!req.res && !req.socket._hadError) {\n    // This socket error fired before we started to\n    // receive a response. The error needs to\n    // fire on the request.\n    req.emit('error', createHangUpError());\n    req.socket._hadError = true;\n  }\n\n  // Too bad.  That output wasn't getting written.\n  // This is pretty terrible that it doesn't raise an error.\n  // Fixed better in v0.10\n  if (req.output)\n    req.output.length = 0;\n  if (req.outputEncodings)\n    req.outputEncodings.length = 0;\n\n  if (parser) {\n    parser.finish();\n    freeParser(parser, req);\n  }\n}\n\nfunction socketErrorListener(err) {\n  var socket = this;\n  var parser = socket.parser;\n  var req = socket._httpMessage;\n  debug('SOCKET ERROR:', err.message, err.stack);\n\n  if (req) {\n    req.emit('error', err);\n    // For Safety. Some additional errors might fire later on\n    // and we need to make sure we don't double-fire the error event.\n    req.socket._hadError = true;\n  }\n\n  if (parser) {\n    parser.finish();\n    freeParser(parser, req);\n  }\n  socket.destroy();\n}\n\nfunction socketOnEnd() {\n  var socket = this;\n  var req = this._httpMessage;\n  var parser = this.parser;\n\n  if (!req.res && !req.socket._hadError) {\n    // If we don't have a response then we know that the socket\n    // ended prematurely and we need to emit an error on the request.\n    req.emit('error', createHangUpError());\n    req.socket._hadError = true;\n  }\n  if (parser) {\n    parser.finish();\n    freeParser(parser, req);\n  }\n  socket.destroy();\n}\n\nfunction socketOnData(d) {\n  var socket = this;\n  var req = this._httpMessage;\n  var parser = this.parser;\n\n  assert(parser && parser.socket === socket);\n\n  var ret = parser.execute(d);\n  if (ret instanceof Error) {\n    debug('parse error');\n    freeParser(parser, req);\n    socket.destroy();\n    req.emit('error', ret);\n    req.socket._hadError = true;\n  } else if (parser.incoming && parser.incoming.upgrade) {\n    // Upgrade or CONNECT\n    var bytesParsed = ret;\n    var res = parser.incoming;\n    req.res = res;\n\n    socket.removeListener('data', socketOnData);\n    socket.removeListener('end', socketOnEnd);\n    parser.finish();\n\n    var bodyHead = d.slice(bytesParsed, d.length);\n\n    var eventName = req.method === 'CONNECT' ? 'connect' : 'upgrade';\n    if (EventEmitter.listenerCount(req, eventName) > 0) {\n      req.upgradeOrConnect = true;\n\n      // detach the socket\n      socket.emit('agentRemove');\n      socket.removeListener('close', socketCloseListener);\n      socket.removeListener('error', socketErrorListener);\n\n      // TODO(isaacs): Need a way to reset a stream to fresh state\n      // IE, not flowing, and not explicitly paused.\n      socket._readableState.flowing = null;\n\n      req.emit(eventName, res, socket, bodyHead);\n      req.emit('close');\n    } else {\n      // Got Upgrade header or CONNECT method, but have no handler.\n      socket.destroy();\n    }\n    freeParser(parser, req);\n  } else if (parser.incoming && parser.incoming.complete &&\n             // When the status code is 100 (Continue), the server will\n             // send a final response after this client sends a request\n             // body. So, we must not free the parser.\n             parser.incoming.statusCode !== 100) {\n    socket.removeListener('data', socketOnData);\n    socket.removeListener('end', socketOnEnd);\n    freeParser(parser, req);\n  }\n}\n\n\n// client\nfunction parserOnIncomingClient(res, shouldKeepAlive) {\n  var socket = this.socket;\n  var req = socket._httpMessage;\n\n\n  // propogate \"domain\" setting...\n  if (req.domain && !res.domain) {\n    debug('setting \"res.domain\"');\n    res.domain = req.domain;\n  }\n\n  debug('AGENT incoming response!');\n\n  if (req.res) {\n    // We already have a response object, this means the server\n    // sent a double response.\n    socket.destroy();\n    return;\n  }\n  req.res = res;\n\n  // Responses to CONNECT request is handled as Upgrade.\n  if (req.method === 'CONNECT') {\n    res.upgrade = true;\n    return true; // skip body\n  }\n\n  // Responses to HEAD requests are crazy.\n  // HEAD responses aren't allowed to have an entity-body\n  // but *can* have a content-length which actually corresponds\n  // to the content-length of the entity-body had the request\n  // been a GET.\n  var isHeadResponse = req.method === 'HEAD';\n  debug('AGENT isHeadResponse', isHeadResponse);\n\n  if (res.statusCode === 100) {\n    // restart the parser, as this is a continue message.\n    delete req.res; // Clear res so that we don't hit double-responses.\n    req.emit('continue');\n    return true;\n  }\n\n  if (req.shouldKeepAlive && !shouldKeepAlive && !req.upgradeOrConnect) {\n    // Server MUST respond with Connection:keep-alive for us to enable it.\n    // If we've been upgraded (via WebSockets) we also shouldn't try to\n    // keep the connection open.\n    req.shouldKeepAlive = false;\n  }\n\n\n  DTRACE_HTTP_CLIENT_RESPONSE(socket, req);\n  COUNTER_HTTP_CLIENT_RESPONSE();\n  req.res = res;\n  res.req = req;\n\n  // add our listener first, so that we guarantee socket cleanup\n  res.on('end', responseOnEnd);\n  var handled = req.emit('response', res);\n\n  // If the user did not listen for the 'response' event, then they\n  // can't possibly read the data, so we ._dump() it into the void\n  // so that the socket doesn't hang there in a paused state.\n  if (!handled)\n    res._dump();\n\n  return isHeadResponse;\n}\n\n// client\nfunction responseOnEnd() {\n  var res = this;\n  var req = res.req;\n  var socket = req.socket;\n\n  if (!req.shouldKeepAlive) {\n    if (socket.writable) {\n      debug('AGENT socket.destroySoon()');\n      socket.destroySoon();\n    }\n    assert(!socket.writable);\n  } else {\n    debug('AGENT socket keep-alive');\n    if (req.timeoutCb) {\n      socket.setTimeout(0, req.timeoutCb);\n      req.timeoutCb = null;\n    }\n    socket.removeListener('close', socketCloseListener);\n    socket.removeListener('error', socketErrorListener);\n    // Mark this socket as available, AFTER user-added end\n    // handlers have a chance to run.\n    process.nextTick(function() {\n      socket.emit('free');\n    });\n  }\n}\n\nfunction tickOnSocket(req, socket) {\n  var parser = parsers.alloc();\n  req.socket = socket;\n  req.connection = socket;\n  parser.reinitialize(HTTPParser.RESPONSE);\n  parser.socket = socket;\n  parser.incoming = null;\n  req.parser = parser;\n\n  socket.parser = parser;\n  socket._httpMessage = req;\n\n  // Setup \"drain\" propogation.\n  httpSocketSetup(socket);\n\n  // Propagate headers limit from request object to parser\n  if (util.isNumber(req.maxHeadersCount)) {\n    parser.maxHeaderPairs = req.maxHeadersCount << 1;\n  } else {\n    // Set default value because parser may be reused from FreeList\n    parser.maxHeaderPairs = 2000;\n  }\n\n  parser.onIncoming = parserOnIncomingClient;\n  socket.on('error', socketErrorListener);\n  socket.on('data', socketOnData);\n  socket.on('end', socketOnEnd);\n  socket.on('close', socketCloseListener);\n  req.emit('socket', socket);\n}\n\nClientRequest.prototype.onSocket = function(socket) {\n  var req = this;\n\n  process.nextTick(function() {\n    if (req.aborted) {\n      // If we were aborted while waiting for a socket, skip the whole thing.\n      socket.emit('free');\n    } else {\n      tickOnSocket(req, socket);\n    }\n  });\n};\n\nClientRequest.prototype._deferToConnect = function(method, arguments_, cb) {\n  // This function is for calls that need to happen once the socket is\n  // connected and writable. It's an important promisy thing for all the socket\n  // calls that happen either now (when a socket is assigned) or\n  // in the future (when a socket gets assigned out of the pool and is\n  // eventually writable).\n  var self = this;\n  var onSocket = function() {\n    if (self.socket.writable) {\n      if (method) {\n        self.socket[method].apply(self.socket, arguments_);\n      }\n      if (cb) { cb(); }\n    } else {\n      self.socket.once('connect', function() {\n        if (method) {\n          self.socket[method].apply(self.socket, arguments_);\n        }\n        if (cb) { cb(); }\n      });\n    }\n  }\n  if (!self.socket) {\n    self.once('socket', onSocket);\n  } else {\n    onSocket();\n  }\n};\n\nClientRequest.prototype.setTimeout = function(msecs, callback) {\n  if (callback) this.once('timeout', callback);\n\n  var self = this;\n  function emitTimeout() {\n    self.emit('timeout');\n  }\n\n  if (this.socket && this.socket.writable) {\n    if (this.timeoutCb)\n      this.socket.setTimeout(0, this.timeoutCb);\n    this.timeoutCb = emitTimeout;\n    this.socket.setTimeout(msecs, emitTimeout);\n    return;\n  }\n\n  // Set timeoutCb so that it'll get cleaned up on request end\n  this.timeoutCb = emitTimeout;\n  if (this.socket) {\n    var sock = this.socket;\n    this.socket.once('connect', function() {\n      sock.setTimeout(msecs, emitTimeout);\n    });\n    return;\n  }\n\n  this.once('socket', function(sock) {\n    sock.setTimeout(msecs, emitTimeout);\n  });\n};\n\nClientRequest.prototype.setNoDelay = function() {\n  this._deferToConnect('setNoDelay', arguments);\n};\nClientRequest.prototype.setSocketKeepAlive = function() {\n  this._deferToConnect('setKeepAlive', arguments);\n};\n\nClientRequest.prototype.clearTimeout = function(cb) {\n  this.setTimeout(0, cb);\n};\n",
  @"// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar FreeList = require('freelist').FreeList;\nvar HTTPParser = process.binding('http_parser').HTTPParser;\n\nvar incoming = require('_http_incoming');\nvar IncomingMessage = incoming.IncomingMessage;\nvar readStart = incoming.readStart;\nvar readStop = incoming.readStop;\n\nvar isNumber = require('util').isNumber;\nvar debug = require('util').debuglog('http');\nexports.debug = debug;\n\nexports.CRLF = '\\r\\n';\nexports.chunkExpression = /chunk/i;\nexports.continueExpression = /100-continue/i;\nexports.methods = HTTPParser.methods;\n\nvar kOnHeaders = HTTPParser.kOnHeaders | 0;\nvar kOnHeadersComplete = HTTPParser.kOnHeadersComplete | 0;\nvar kOnBody = HTTPParser.kOnBody | 0;\nvar kOnMessageComplete = HTTPParser.kOnMessageComplete | 0;\n\n// Only called in the slow case where slow means\n// that the request headers were either fragmented\n// across multiple TCP packets or too large to be\n// processed in a single run. This method is also\n// called to process trailing HTTP headers.\nfunction parserOnHeaders(headers, url) {\n  // Once we exceeded headers limit - stop collecting them\n  if (this.maxHeaderPairs <= 0 ||\n      this._headers.length < this.maxHeaderPairs) {\n    this._headers = this._headers.concat(headers);\n  }\n  this._url += url;\n}\n\n// info.headers and info.url are set only if .onHeaders()\n// has not been called for this request.\n//\n// info.url is not set for response parsers but that's not\n// applicable here since all our parsers are request parsers.\nfunction parserOnHeadersComplete(info) {\n  debug('parserOnHeadersComplete', info);\n  var parser = this;\n  var headers = info.headers;\n  var url = info.url;\n\n  if (!headers) {\n    headers = parser._headers;\n    parser._headers = [];\n  }\n\n  if (!url) {\n    url = parser._url;\n    parser._url = '';\n  }\n\n  parser.incoming = new IncomingMessage(parser.socket);\n  parser.incoming.httpVersionMajor = info.versionMajor;\n  parser.incoming.httpVersionMinor = info.versionMinor;\n  parser.incoming.httpVersion = info.versionMajor + '.' + info.versionMinor;\n  parser.incoming.url = url;\n\n  var n = headers.length;\n\n  // If parser.maxHeaderPairs <= 0 - assume that there're no limit\n  if (parser.maxHeaderPairs > 0) {\n    n = Math.min(n, parser.maxHeaderPairs);\n  }\n\n  parser.incoming._addHeaderLines(headers, n);\n\n  if (isNumber(info.method)) {\n    // server only\n    parser.incoming.method = HTTPParser.methods[info.method];\n  } else {\n    // client only\n    parser.incoming.statusCode = info.statusCode;\n    parser.incoming.statusMessage = info.statusMessage;\n  }\n\n  parser.incoming.upgrade = info.upgrade;\n\n  var skipBody = false; // response to HEAD or CONNECT\n\n  if (!info.upgrade) {\n    // For upgraded connections and CONNECT method request,\n    // we'll emit this after parser.execute\n    // so that we can capture the first part of the new protocol\n    skipBody = parser.onIncoming(parser.incoming, info.shouldKeepAlive);\n  }\n\n  return skipBody;\n}\n\n// XXX This is a mess.\n// TODO: http.Parser should be a Writable emits request/response events.\nfunction parserOnBody(b, start, len) {\n  var parser = this;\n  var stream = parser.incoming;\n\n  // if the stream has already been removed, then drop it.\n  if (!stream)\n    return;\n\n  var socket = stream.socket;\n\n  // pretend this was the result of a stream._read call.\n  if (len > 0 && !stream._dumped) {\n    var slice = b.slice(start, start + len);\n    var ret = stream.push(slice);\n    if (!ret)\n      readStop(socket);\n  }\n}\n\nfunction parserOnMessageComplete() {\n  var parser = this;\n  var stream = parser.incoming;\n\n  if (stream) {\n    stream.complete = true;\n    // Emit any trailing headers.\n    var headers = parser._headers;\n    if (headers) {\n      parser.incoming._addHeaderLines(headers, headers.length);\n      parser._headers = [];\n      parser._url = '';\n    }\n\n    if (!stream.upgrade)\n      // For upgraded connections, also emit this after parser.execute\n      stream.push(null);\n  }\n\n  if (stream && !parser.incoming._pendings.length) {\n    // For emit end event\n    stream.push(null);\n  }\n\n  // force to read the next incoming message\n  readStart(parser.socket);\n}\n\n\nvar parsers = new FreeList('parsers', 1000, function() {\n  var parser = new HTTPParser(HTTPParser.REQUEST);\n\n  parser._headers = [];\n  parser._url = '';\n\n  // Only called in the slow case where slow means\n  // that the request headers were either fragmented\n  // across multiple TCP packets or too large to be\n  // processed in a single run. This method is also\n  // called to process trailing HTTP headers.\n  parser[kOnHeaders] = parserOnHeaders;\n  parser[kOnHeadersComplete] = parserOnHeadersComplete;\n  parser[kOnBody] = parserOnBody;\n  parser[kOnMessageComplete] = parserOnMessageComplete;\n\n  return parser;\n});\nexports.parsers = parsers;\n\n\n// Free the parser and also break any links that it\n// might have to any other things.\n// TODO: All parser data should be attached to a\n// single object, so that it can be easily cleaned\n// up by doing `parser.data = {}`, which should\n// be done in FreeList.free.  `parsers.free(parser)`\n// should be all that is needed.\nfunction freeParser(parser, req) {\n  if (parser) {\n    parser._headers = [];\n    parser.onIncoming = null;\n    if (parser.socket)\n      parser.socket.parser = null;\n    parser.socket = null;\n    parser.incoming = null;\n    parsers.free(parser);\n    parser = null;\n  }\n  if (req) {\n    req.parser = null;\n  }\n}\nexports.freeParser = freeParser;\n\n\nfunction ondrain() {\n  if (this._httpMessage) this._httpMessage.emit('drain');\n}\n\n\nfunction httpSocketSetup(socket) {\n  socket.removeListener('drain', ondrain);\n  socket.on('drain', ondrain);\n}\nexports.httpSocketSetup = httpSocketSetup;\n",
  @"// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar util = require('util');\nvar Stream = require('stream');\n\nfunction readStart(socket) {\n  if (socket && !socket._paused && socket.readable)\n    socket.resume();\n}\nexports.readStart = readStart;\n\nfunction readStop(socket) {\n  if (socket)\n    socket.pause();\n}\nexports.readStop = readStop;\n\n\n\nfunction IncomingMessage(socket) {\n  Stream.Readable.call(this);\n\n  // XXX This implementation is kind of all over the place\n  // When the parser emits body chunks, they go in this list.\n  // _read() pulls them out, and when it finds EOF, it ends.\n\n  this.socket = socket;\n  this.connection = socket;\n\n  this.httpVersion = null;\n  this.complete = false;\n  this.headers = {};\n  this.rawHeaders = [];\n  this.trailers = {};\n  this.rawTrailers = [];\n\n  this.readable = true;\n\n  this._pendings = [];\n  this._pendingIndex = 0;\n\n  // request (server) only\n  this.url = '';\n  this.method = null;\n\n  // response (client) only\n  this.statusCode = null;\n  this.statusMessage = null;\n  this.client = this.socket;\n\n  // flag for backwards compatibility grossness.\n  this._consuming = false;\n\n  // flag for when we decide that this message cannot possibly be\n  // read by the user, so there's no point continuing to handle it.\n  this._dumped = false;\n}\nutil.inherits(IncomingMessage, Stream.Readable);\n\n\nexports.IncomingMessage = IncomingMessage;\n\n\nIncomingMessage.prototype.setTimeout = function(msecs, callback) {\n  if (callback)\n    this.on('timeout', callback);\n  this.socket.setTimeout(msecs);\n};\n\n\nIncomingMessage.prototype.read = function(n) {\n  this._consuming = true;\n  this.read = Stream.Readable.prototype.read;\n  return this.read(n);\n};\n\n\nIncomingMessage.prototype._read = function(n) {\n  // We actually do almost nothing here, because the parserOnBody\n  // function fills up our internal buffer directly.  However, we\n  // do need to unpause the underlying socket so that it flows.\n  if (this.socket.readable)\n    readStart(this.socket);\n};\n\n\n// It's possible that the socket will be destroyed, and removed from\n// any messages, before ever calling this.  In that case, just skip\n// it, since something else is destroying this connection anyway.\nIncomingMessage.prototype.destroy = function(error) {\n  if (this.socket)\n    this.socket.destroy(error);\n};\n\n\nIncomingMessage.prototype._addHeaderLines = function(headers, n) {\n  if (headers && headers.length) {\n    var raw, dest;\n    if (this.complete) {\n      raw = this.rawTrailers;\n      dest = this.trailers;\n    } else {\n      raw = this.rawHeaders;\n      dest = this.headers;\n    }\n    raw.push.apply(raw, headers);\n\n    for (var i = 0; i < n; i += 2) {\n      var k = headers[i];\n      var v = headers[i + 1];\n      this._addHeaderLine(k, v, dest);\n    }\n  }\n};\n\n\n// Add the given (field, value) pair to the message\n//\n// Per RFC2616, section 4.2 it is acceptable to join multiple instances of the\n// same header with a ', ' if the header in question supports specification of\n// multiple values this way. If not, we declare the first instance the winner\n// and drop the second. Extended header fields (those beginning with 'x-') are\n// always joined.\nIncomingMessage.prototype._addHeaderLine = function(field, value, dest) {\n  field = field.toLowerCase();\n  switch (field) {\n    // Array headers:\n    case 'set-cookie':\n      if (!util.isUndefined(dest[field])) {\n        dest[field].push(value);\n      } else {\n        dest[field] = [value];\n      }\n      break;\n\n    // list is taken from:\n    // https://mxr.mozilla.org/mozilla/source/netwerk/protocol/http/src/nsHttpHeaderArray.cpp\n    case 'content-type':\n    case 'content-length':\n    case 'user-agent':\n    case 'referer':\n    case 'host':\n    case 'authorization':\n    case 'proxy-authorization':\n    case 'if-modified-since':\n    case 'if-unmodified-since':\n    case 'from':\n    case 'location':\n    case 'max-forwards':\n      // drop duplicates\n      if (util.isUndefined(dest[field]))\n        dest[field] = value;\n      break;\n\n    default:\n      // make comma-separated list\n      if (!util.isUndefined(dest[field]))\n        dest[field] += ', ' + value;\n      else {\n        dest[field] = value;\n      }\n  }\n};\n\n\n// Call this instead of resume() if we want to just\n// dump all the data to /dev/null\nIncomingMessage.prototype._dump = function() {\n  if (!this._dumped) {\n    this._dumped = true;\n    this.resume();\n  }\n};\n",
  @"// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar assert = require('assert').ok;\nvar Stream = require('stream');\nvar timers = require('timers');\nvar util = require('util');\n\nvar common = require('_http_common');\n\nvar CRLF = common.CRLF;\nvar chunkExpression = common.chunkExpression;\nvar debug = common.debug;\n\n\nvar connectionExpression = /Connection/i;\nvar transferEncodingExpression = /Transfer-Encoding/i;\nvar closeExpression = /close/i;\nvar contentLengthExpression = /Content-Length/i;\nvar dateExpression = /Date/i;\nvar expectExpression = /Expect/i;\n\nvar automaticHeaders = {\n  connection: true,\n  'content-length': true,\n  'transfer-encoding': true,\n  date: true\n};\n\n\nvar dateCache;\nfunction utcDate() {\n  if (!dateCache) {\n    var d = new Date();\n    dateCache = d.toUTCString();\n    timers.enroll(utcDate, 1000 - d.getMilliseconds());\n    timers._unrefActive(utcDate);\n  }\n  return dateCache;\n}\nutcDate._onTimeout = function() {\n  dateCache = undefined;\n};\n\n\nfunction OutgoingMessage() {\n  Stream.call(this);\n\n  this.output = [];\n  this.outputEncodings = [];\n  this.outputCallbacks = [];\n\n  this.writable = true;\n\n  this._last = false;\n  this.chunkedEncoding = false;\n  this.shouldKeepAlive = true;\n  this.useChunkedEncodingByDefault = true;\n  this.sendDate = false;\n  this._removedHeader = {};\n\n  this._hasBody = true;\n  this._trailer = '';\n\n  this.finished = false;\n  this._hangupClose = false;\n\n  this.socket = null;\n  this.connection = null;\n}\nutil.inherits(OutgoingMessage, Stream);\n\n\nexports.OutgoingMessage = OutgoingMessage;\n\n\nOutgoingMessage.prototype.setTimeout = function(msecs, callback) {\n  if (callback)\n    this.on('timeout', callback);\n  if (!this.socket) {\n    this.once('socket', function(socket) {\n      socket.setTimeout(msecs);\n    });\n  } else\n    this.socket.setTimeout(msecs);\n};\n\n\n// It's possible that the socket will be destroyed, and removed from\n// any messages, before ever calling this.  In that case, just skip\n// it, since something else is destroying this connection anyway.\nOutgoingMessage.prototype.destroy = function(error) {\n  if (this.socket)\n    this.socket.destroy(error);\n  else\n    this.once('socket', function(socket) {\n      socket.destroy(error);\n    });\n};\n\n\n// This abstract either writing directly to the socket or buffering it.\nOutgoingMessage.prototype._send = function(data, encoding, callback) {\n  // This is a shameful hack to get the headers and first body chunk onto\n  // the same packet. Future versions of Node are going to take care of\n  // this at a lower level and in a more general way.\n  if (!this._headerSent) {\n    if (util.isString(data) &&\n        encoding !== 'hex' &&\n        encoding !== 'base64') {\n      data = this._header + data;\n    } else {\n      this.output.unshift(this._header);\n      this.outputEncodings.unshift('binary');\n      this.outputCallbacks.unshift(null);\n    }\n    this._headerSent = true;\n  }\n  return this._writeRaw(data, encoding, callback);\n};\n\n\nOutgoingMessage.prototype._writeRaw = function(data, encoding, callback) {\n  if (util.isFunction(encoding)) {\n    callback = encoding;\n    encoding = null;\n  }\n\n  if (data.length === 0) {\n    if (util.isFunction(callback))\n      process.nextTick(callback);\n    return true;\n  }\n\n  if (this.connection &&\n      this.connection._httpMessage === this &&\n      this.connection.writable &&\n      !this.connection.destroyed) {\n    // There might be pending data in the this.output buffer.\n    while (this.output.length) {\n      if (!this.connection.writable) {\n        this._buffer(data, encoding, callback);\n        return false;\n      }\n      var c = this.output.shift();\n      var e = this.outputEncodings.shift();\n      var cb = this.outputCallbacks.shift();\n      this.connection.write(c, e, cb);\n    }\n\n    // Directly write to socket.\n    return this.connection.write(data, encoding, callback);\n  } else if (this.connection && this.connection.destroyed) {\n    // The socket was destroyed.  If we're still trying to write to it,\n    // then we haven't gotten the 'close' event yet.\n    return false;\n  } else {\n    // buffer, as long as we're not destroyed.\n    this._buffer(data, encoding, callback);\n    return false;\n  }\n};\n\n\nOutgoingMessage.prototype._buffer = function(data, encoding, callback) {\n  this.output.push(data);\n  this.outputEncodings.push(encoding);\n  this.outputCallbacks.push(callback);\n  return false;\n};\n\n\nOutgoingMessage.prototype._storeHeader = function(firstLine, headers) {\n  // firstLine in the case of request is: 'GET /index.html HTTP/1.1\\r\\n'\n  // in the case of response it is: 'HTTP/1.1 200 OK\\r\\n'\n  var state = {\n    sentConnectionHeader: false,\n    sentContentLengthHeader: false,\n    sentTransferEncodingHeader: false,\n    sentDateHeader: false,\n    sentExpect: false,\n    messageHeader: firstLine\n  };\n\n  var field, value;\n\n  if (headers) {\n    var keys = Object.keys(headers);\n    var isArray = util.isArray(headers);\n    var field, value;\n\n    for (var i = 0, l = keys.length; i < l; i++) {\n      var key = keys[i];\n      if (isArray) {\n        field = headers[key][0];\n        value = headers[key][1];\n      } else {\n        field = key;\n        value = headers[key];\n      }\n\n      if (util.isArray(value)) {\n        for (var j = 0; j < value.length; j++) {\n          storeHeader(this, state, field, value[j]);\n        }\n      } else {\n        storeHeader(this, state, field, value);\n      }\n    }\n  }\n\n  // Date header\n  if (this.sendDate === true && state.sentDateHeader === false) {\n    state.messageHeader += 'Date: ' + utcDate() + CRLF;\n  }\n\n  // Force the connection to close when the response is a 204 No Content or\n  // a 304 Not Modified and the user has set a \"Transfer-Encoding: chunked\"\n  // header.\n  //\n  // RFC 2616 mandates that 204 and 304 responses MUST NOT have a body but\n  // node.js used to send out a zero chunk anyway to accommodate clients\n  // that don't have special handling for those responses.\n  //\n  // It was pointed out that this might confuse reverse proxies to the point\n  // of creating security liabilities, so suppress the zero chunk and force\n  // the connection to close.\n  var statusCode = this.statusCode;\n  if ((statusCode === 204 || statusCode === 304) &&\n      this.chunkedEncoding === true) {\n    debug(statusCode + ' response should not use chunked encoding,' +\n          ' closing connection.');\n    this.chunkedEncoding = false;\n    this.shouldKeepAlive = false;\n  }\n\n  // keep-alive logic\n  if (this._removedHeader.connection) {\n    this._last = true;\n    this.shouldKeepAlive = false;\n  } else if (state.sentConnectionHeader === false) {\n    var shouldSendKeepAlive = this.shouldKeepAlive &&\n        (state.sentContentLengthHeader ||\n         this.useChunkedEncodingByDefault ||\n         this.agent);\n    if (shouldSendKeepAlive) {\n      state.messageHeader += 'Connection: keep-alive\\r\\n';\n    } else {\n      this._last = true;\n      state.messageHeader += 'Connection: close\\r\\n';\n    }\n  }\n\n  if (state.sentContentLengthHeader === false &&\n      state.sentTransferEncodingHeader === false) {\n    if (this._hasBody && !this._removedHeader['transfer-encoding']) {\n      if (this.useChunkedEncodingByDefault) {\n        state.messageHeader += 'Transfer-Encoding: chunked\\r\\n';\n        this.chunkedEncoding = true;\n      } else {\n        this._last = true;\n      }\n    } else {\n      // Make sure we don't end the 0\\r\\n\\r\\n at the end of the message.\n      this.chunkedEncoding = false;\n    }\n  }\n\n  this._header = state.messageHeader + CRLF;\n  this._headerSent = false;\n\n  // wait until the first body chunk, or close(), is sent to flush,\n  // UNLESS we're sending Expect: 100-continue.\n  if (state.sentExpect) this._send('');\n};\n\nfunction storeHeader(self, state, field, value) {\n  // Protect against response splitting. The if statement is there to\n  // minimize the performance impact in the common case.\n  if (/[\\r\\n]/.test(value))\n    value = value.replace(/[\\r\\n]+[ \\t]*/g, '');\n\n  state.messageHeader += field + ': ' + value + CRLF;\n\n  if (connectionExpression.test(field)) {\n    state.sentConnectionHeader = true;\n    if (closeExpression.test(value)) {\n      self._last = true;\n    } else {\n      self.shouldKeepAlive = true;\n    }\n\n  } else if (transferEncodingExpression.test(field)) {\n    state.sentTransferEncodingHeader = true;\n    if (chunkExpression.test(value)) self.chunkedEncoding = true;\n\n  } else if (contentLengthExpression.test(field)) {\n    state.sentContentLengthHeader = true;\n  } else if (dateExpression.test(field)) {\n    state.sentDateHeader = true;\n  } else if (expectExpression.test(field)) {\n    state.sentExpect = true;\n  }\n}\n\n\nOutgoingMessage.prototype.setHeader = function(name, value) {\n  if (arguments.length < 2) {\n    throw new Error('`name` and `value` are required for setHeader().');\n  }\n\n  if (this._header) {\n    throw new Error('Can\\'t set headers after they are sent.');\n  }\n\n  var key = name.toLowerCase();\n  this._headers = this._headers || {};\n  this._headerNames = this._headerNames || {};\n  this._headers[key] = value;\n  this._headerNames[key] = name;\n\n  if (automaticHeaders[key]) {\n    this._removedHeader[key] = false;\n  }\n};\n\n\nOutgoingMessage.prototype.getHeader = function(name) {\n  if (arguments.length < 1) {\n    throw new Error('`name` is required for getHeader().');\n  }\n\n  if (!this._headers) return;\n\n  var key = name.toLowerCase();\n  return this._headers[key];\n};\n\n\nOutgoingMessage.prototype.removeHeader = function(name) {\n  if (arguments.length < 1) {\n    throw new Error('`name` is required for removeHeader().');\n  }\n\n  if (this._header) {\n    throw new Error('Can\\'t remove headers after they are sent.');\n  }\n\n  var key = name.toLowerCase();\n\n  if (key === 'date')\n    this.sendDate = false;\n  else if (automaticHeaders[key])\n    this._removedHeader[key] = true;\n\n  if (this._headers) {\n    delete this._headers[key];\n    delete this._headerNames[key];\n  }\n};\n\n\nOutgoingMessage.prototype._renderHeaders = function() {\n  if (this._header) {\n    throw new Error('Can\\'t render headers after they are sent to the client.');\n  }\n\n  if (!this._headers) return {};\n\n  var headers = {};\n  var keys = Object.keys(this._headers);\n  for (var i = 0, l = keys.length; i < l; i++) {\n    var key = keys[i];\n    headers[this._headerNames[key]] = this._headers[key];\n  }\n  return headers;\n};\n\n\nObject.defineProperty(OutgoingMessage.prototype, 'headersSent', {\n  configurable: true,\n  enumerable: true,\n  get: function() { return !!this._header; }\n});\n\n\nOutgoingMessage.prototype.write = function(chunk, encoding, callback) {\n  if (!this._header) {\n    this._implicitHeader();\n  }\n\n  if (!this._hasBody) {\n    debug('This type of response MUST NOT have a body. ' +\n          'Ignoring write() calls.');\n    return true;\n  }\n\n  if (!util.isString(chunk) && !util.isBuffer(chunk)) {\n    throw new TypeError('first argument must be a string or Buffer');\n  }\n\n\n  // If we get an empty string or buffer, then just do nothing, and\n  // signal the user to keep writing.\n  if (chunk.length === 0) return true;\n\n  var len, ret;\n  if (this.chunkedEncoding) {\n    if (util.isString(chunk) &&\n        encoding !== 'hex' &&\n        encoding !== 'base64' &&\n        encoding !== 'binary') {\n      len = Buffer.byteLength(chunk, encoding);\n      chunk = len.toString(16) + CRLF + chunk + CRLF;\n      ret = this._send(chunk, encoding, callback);\n    } else {\n      // buffer, or a non-toString-friendly encoding\n      if (util.isString(chunk))\n        len = Buffer.byteLength(chunk, encoding);\n      else\n        len = chunk.length;\n\n      if (this.connection && !this.connection.corked) {\n        this.connection.cork();\n        var conn = this.connection;\n        process.nextTick(function connectionCork() {\n          if (conn)\n            conn.uncork();\n        });\n      }\n      this._send(len.toString(16), 'binary', null);\n      this._send(crlf_buf, null, null);\n      this._send(chunk, encoding, null);\n      ret = this._send(crlf_buf, null, callback);\n    }\n  } else {\n    ret = this._send(chunk, encoding, callback);\n  }\n\n  debug('write ret = ' + ret);\n  return ret;\n};\n\n\nOutgoingMessage.prototype.addTrailers = function(headers) {\n  this._trailer = '';\n  var keys = Object.keys(headers);\n  var isArray = util.isArray(headers);\n  var field, value;\n  for (var i = 0, l = keys.length; i < l; i++) {\n    var key = keys[i];\n    if (isArray) {\n      field = headers[key][0];\n      value = headers[key][1];\n    } else {\n      field = key;\n      value = headers[key];\n    }\n\n    this._trailer += field + ': ' + value + CRLF;\n  }\n};\n\n\nvar crlf_buf = new Buffer('\\r\\n');\n\n\nOutgoingMessage.prototype.end = function(data, encoding, callback) {\n  if (util.isFunction(data)) {\n    callback = data;\n    data = null;\n  } else if (util.isFunction(encoding)) {\n    callback = encoding;\n    encoding = null;\n  }\n\n  if (data && !util.isString(data) && !util.isBuffer(data)) {\n    throw new TypeError('first argument must be a string or Buffer');\n  }\n\n  if (this.finished) {\n    return false;\n  }\n\n  var self = this;\n  function finish() {\n    self.emit('finish');\n  }\n\n  if (util.isFunction(callback))\n    this.once('finish', callback);\n\n\n  if (!this._header) {\n    this._implicitHeader();\n  }\n\n  if (data && !this._hasBody) {\n    debug('This type of response MUST NOT have a body. ' +\n          'Ignoring data passed to end().');\n    data = null;\n  }\n\n  if (this.connection && data)\n    this.connection.cork();\n\n  var ret;\n  if (data) {\n    // Normal body write.\n    ret = this.write(data, encoding);\n  }\n\n  if (this.chunkedEncoding) {\n    ret = this._send('0\\r\\n' + this._trailer + '\\r\\n', 'binary', finish);\n  } else {\n    // Force a flush, HACK.\n    ret = this._send('', 'binary', finish);\n  }\n\n  if (this.connection && data)\n    this.connection.uncork();\n\n  this.finished = true;\n\n  // There is the first message on the outgoing queue, and we've sent\n  // everything to the socket.\n  debug('outgoing message end.');\n  if (this.output.length === 0 && this.connection._httpMessage === this) {\n    this._finish();\n  }\n\n  return ret;\n};\n\n\nOutgoingMessage.prototype._finish = function() {\n  assert(this.connection);\n  this.emit('prefinish');\n};\n\n\n// This logic is probably a bit confusing. Let me explain a bit:\n//\n// In both HTTP servers and clients it is possible to queue up several\n// outgoing messages. This is easiest to imagine in the case of a client.\n// Take the following situation:\n//\n//    req1 = client.request('GET', '/');\n//    req2 = client.request('POST', '/');\n//\n// When the user does\n//\n//   req2.write('hello world\\n');\n//\n// it's possible that the first request has not been completely flushed to\n// the socket yet. Thus the outgoing messages need to be prepared to queue\n// up data internally before sending it on further to the socket's queue.\n//\n// This function, outgoingFlush(), is called by both the Server and Client\n// to attempt to flush any pending messages out to the socket.\nOutgoingMessage.prototype._flush = function() {\n  if (this.socket && this.socket.writable) {\n    var ret;\n    while (this.output.length) {\n      var data = this.output.shift();\n      var encoding = this.outputEncodings.shift();\n      var cb = this.outputCallbacks.shift();\n      ret = this.socket.write(data, encoding, cb);\n    }\n\n    if (this.finished) {\n      // This is a queue to the server or client to bring in the next this.\n      this._finish();\n    } else if (ret) {\n      // This is necessary to prevent https from breaking\n      this.emit('drain');\n    }\n  }\n};\n\n\nOutgoingMessage.prototype.flush = function() {\n  if (!this._header) {\n    // Force-flush the headers.\n    this._implicitHeader();\n    this._send('');\n  }\n};\n",
  @"// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar util = require('util');\nvar net = require('net');\nvar EventEmitter = require('events').EventEmitter;\nvar HTTPParser = process.binding('http_parser').HTTPParser;\nvar assert = require('assert').ok;\n\nvar common = require('_http_common');\nvar parsers = common.parsers;\nvar freeParser = common.freeParser;\nvar debug = common.debug;\nvar CRLF = common.CRLF;\nvar continueExpression = common.continueExpression;\nvar chunkExpression = common.chunkExpression;\nvar httpSocketSetup = common.httpSocketSetup;\n\nvar OutgoingMessage = require('_http_outgoing').OutgoingMessage;\n\n\nvar STATUS_CODES = exports.STATUS_CODES = {\n  100 : 'Continue',\n  101 : 'Switching Protocols',\n  102 : 'Processing',                 // RFC 2518, obsoleted by RFC 4918\n  200 : 'OK',\n  201 : 'Created',\n  202 : 'Accepted',\n  203 : 'Non-Authoritative Information',\n  204 : 'No Content',\n  205 : 'Reset Content',\n  206 : 'Partial Content',\n  207 : 'Multi-Status',               // RFC 4918\n  300 : 'Multiple Choices',\n  301 : 'Moved Permanently',\n  302 : 'Moved Temporarily',\n  303 : 'See Other',\n  304 : 'Not Modified',\n  305 : 'Use Proxy',\n  307 : 'Temporary Redirect',\n  308 : 'Permanent Redirect',         // RFC 7238\n  400 : 'Bad Request',\n  401 : 'Unauthorized',\n  402 : 'Payment Required',\n  403 : 'Forbidden',\n  404 : 'Not Found',\n  405 : 'Method Not Allowed',\n  406 : 'Not Acceptable',\n  407 : 'Proxy Authentication Required',\n  408 : 'Request Time-out',\n  409 : 'Conflict',\n  410 : 'Gone',\n  411 : 'Length Required',\n  412 : 'Precondition Failed',\n  413 : 'Request Entity Too Large',\n  414 : 'Request-URI Too Large',\n  415 : 'Unsupported Media Type',\n  416 : 'Requested Range Not Satisfiable',\n  417 : 'Expectation Failed',\n  418 : 'I\\'m a teapot',              // RFC 2324\n  422 : 'Unprocessable Entity',       // RFC 4918\n  423 : 'Locked',                     // RFC 4918\n  424 : 'Failed Dependency',          // RFC 4918\n  425 : 'Unordered Collection',       // RFC 4918\n  426 : 'Upgrade Required',           // RFC 2817\n  428 : 'Precondition Required',      // RFC 6585\n  429 : 'Too Many Requests',          // RFC 6585\n  431 : 'Request Header Fields Too Large',// RFC 6585\n  500 : 'Internal Server Error',\n  501 : 'Not Implemented',\n  502 : 'Bad Gateway',\n  503 : 'Service Unavailable',\n  504 : 'Gateway Time-out',\n  505 : 'HTTP Version Not Supported',\n  506 : 'Variant Also Negotiates',    // RFC 2295\n  507 : 'Insufficient Storage',       // RFC 4918\n  509 : 'Bandwidth Limit Exceeded',\n  510 : 'Not Extended',               // RFC 2774\n  511 : 'Network Authentication Required' // RFC 6585\n};\n\n\nfunction ServerResponse(req) {\n  OutgoingMessage.call(this);\n\n  if (req.method === 'HEAD') this._hasBody = false;\n\n  this.sendDate = true;\n\n  if (req.httpVersionMajor < 1 || req.httpVersionMinor < 1) {\n    this.useChunkedEncodingByDefault = chunkExpression.test(req.headers.te);\n    this.shouldKeepAlive = false;\n  }\n}\nutil.inherits(ServerResponse, OutgoingMessage);\n\nServerResponse.prototype._finish = function() {\n  DTRACE_HTTP_SERVER_RESPONSE(this.connection);\n  COUNTER_HTTP_SERVER_RESPONSE();\n  OutgoingMessage.prototype._finish.call(this);\n};\n\n\n\nexports.ServerResponse = ServerResponse;\n\nServerResponse.prototype.statusCode = 200;\nServerResponse.prototype.statusMessage = undefined;\n\nfunction onServerResponseClose() {\n  // EventEmitter.emit makes a copy of the 'close' listeners array before\n  // calling the listeners. detachSocket() unregisters onServerResponseClose\n  // but if detachSocket() is called, directly or indirectly, by a 'close'\n  // listener, onServerResponseClose is still in that copy of the listeners\n  // array. That is, in the example below, b still gets called even though\n  // it's been removed by a:\n  //\n  //   var obj = new events.EventEmitter;\n  //   obj.on('event', a);\n  //   obj.on('event', b);\n  //   function a() { obj.removeListener('event', b) }\n  //   function b() { throw \"BAM!\" }\n  //   obj.emit('event');  // throws\n  //\n  // Ergo, we need to deal with stale 'close' events and handle the case\n  // where the ServerResponse object has already been deconstructed.\n  // Fortunately, that requires only a single if check. :-)\n  if (this._httpMessage) this._httpMessage.emit('close');\n}\n\nServerResponse.prototype.assignSocket = function(socket) {\n  assert(!socket._httpMessage);\n  socket._httpMessage = this;\n  socket.on('close', onServerResponseClose);\n  this.socket = socket;\n  this.connection = socket;\n  this.emit('socket', socket);\n  this._flush();\n};\n\nServerResponse.prototype.detachSocket = function(socket) {\n  assert(socket._httpMessage === this);\n  socket.removeListener('close', onServerResponseClose);\n  socket._httpMessage = null;\n  this.socket = this.connection = null;\n};\n\nServerResponse.prototype.writeContinue = function(cb) {\n  this._writeRaw('HTTP/1.1 100 Continue' + CRLF + CRLF, 'ascii', cb);\n  this._sent100 = true;\n};\n\nServerResponse.prototype._implicitHeader = function() {\n  this.writeHead(this.statusCode);\n};\n\nServerResponse.prototype.writeHead = function(statusCode) {\n  var headers, headerIndex;\n\n  if (util.isString(arguments[1])) {\n    this.statusMessage = arguments[1];\n    headerIndex = 2;\n  } else {\n    this.statusMessage =\n        this.statusMessage || STATUS_CODES[statusCode] || 'unknown';\n    headerIndex = 1;\n  }\n  this.statusCode = statusCode;\n\n  var obj = arguments[headerIndex];\n\n  if (this._headers) {\n    // Slow-case: when progressive API and header fields are passed.\n    if (obj) {\n      var keys = Object.keys(obj);\n      for (var i = 0; i < keys.length; i++) {\n        var k = keys[i];\n        if (k) this.setHeader(k, obj[k]);\n      }\n    }\n    // only progressive api is used\n    headers = this._renderHeaders();\n  } else {\n    // only writeHead() called\n    headers = obj;\n  }\n\n  var statusLine = 'HTTP/1.1 ' + statusCode.toString() + ' ' +\n                   this.statusMessage + CRLF;\n\n  if (statusCode === 204 || statusCode === 304 ||\n      (100 <= statusCode && statusCode <= 199)) {\n    // RFC 2616, 10.2.5:\n    // The 204 response MUST NOT include a message-body, and thus is always\n    // terminated by the first empty line after the header fields.\n    // RFC 2616, 10.3.5:\n    // The 304 response MUST NOT contain a message-body, and thus is always\n    // terminated by the first empty line after the header fields.\n    // RFC 2616, 10.1 Informational 1xx:\n    // This class of status code indicates a provisional response,\n    // consisting only of the Status-Line and optional headers, and is\n    // terminated by an empty line.\n    this._hasBody = false;\n  }\n\n  // don't keep alive connections where the client expects 100 Continue\n  // but we sent a final status; they may put extra bytes on the wire.\n  if (this._expect_continue && !this._sent100) {\n    this.shouldKeepAlive = false;\n  }\n\n  this._storeHeader(statusLine, headers);\n};\n\nServerResponse.prototype.writeHeader = function() {\n  this.writeHead.apply(this, arguments);\n};\n\n\nfunction Server(requestListener) {\n  if (!(this instanceof Server)) return new Server(requestListener);\n  net.Server.call(this, { allowHalfOpen: true });\n\n  if (requestListener) {\n    this.addListener('request', requestListener);\n  }\n\n  // Similar option to this. Too lazy to write my own docs.\n  // http://www.squid-cache.org/Doc/config/half_closed_clients/\n  // http://wiki.squid-cache.org/SquidFaq/InnerWorkings#What_is_a_half-closed_filedescriptor.3F\n  this.httpAllowHalfOpen = false;\n\n  this.addListener('connection', connectionListener);\n\n  this.addListener('clientError', function(err, conn) {\n    conn.destroy(err);\n  });\n\n  this.timeout = 2 * 60 * 1000;\n}\nutil.inherits(Server, net.Server);\n\n\nServer.prototype.setTimeout = function(msecs, callback) {\n  this.timeout = msecs;\n  if (callback)\n    this.on('timeout', callback);\n};\n\n\nexports.Server = Server;\n\n\nfunction connectionListener(socket) {\n  var self = this;\n  var outgoing = [];\n  var incoming = [];\n\n  function abortIncoming() {\n    while (incoming.length) {\n      var req = incoming.shift();\n      req.emit('aborted');\n      req.emit('close');\n    }\n    // abort socket._httpMessage ?\n  }\n\n  function serverSocketCloseListener() {\n    debug('server socket close');\n    // mark this parser as reusable\n    if (this.parser)\n      freeParser(this.parser);\n\n    abortIncoming();\n  }\n\n  debug('SERVER new http connection');\n\n  httpSocketSetup(socket);\n\n  // If the user has added a listener to the server,\n  // request, or response, then it's their responsibility.\n  // otherwise, destroy on timeout by default\n  if (self.timeout)\n    socket.setTimeout(self.timeout);\n  socket.on('timeout', function() {\n    var req = socket.parser && socket.parser.incoming;\n    var reqTimeout = req && !req.complete && req.emit('timeout', socket);\n    var res = socket._httpMessage;\n    var resTimeout = res && res.emit('timeout', socket);\n    var serverTimeout = self.emit('timeout', socket);\n\n    if (!reqTimeout && !resTimeout && !serverTimeout)\n      socket.destroy();\n  });\n\n  var parser = parsers.alloc();\n  parser.reinitialize(HTTPParser.REQUEST);\n  parser.socket = socket;\n  socket.parser = parser;\n  parser.incoming = null;\n\n  // Propagate headers limit from server instance to parser\n  if (util.isNumber(this.maxHeadersCount)) {\n    parser.maxHeaderPairs = this.maxHeadersCount << 1;\n  } else {\n    // Set default value because parser may be reused from FreeList\n    parser.maxHeaderPairs = 2000;\n  }\n\n  socket.addListener('error', socketOnError);\n  socket.addListener('close', serverSocketCloseListener);\n  parser.onIncoming = parserOnIncoming;\n  socket.on('end', socketOnEnd);\n  socket.on('data', socketOnData);\n\n  // TODO(isaacs): Move all these functions out of here\n  function socketOnError(e) {\n    self.emit('clientError', e, this);\n  }\n\n  function socketOnData(d) {\n    assert(!socket._paused);\n    debug('SERVER socketOnData %d', d.length);\n    var ret = parser.execute(d);\n    if (ret instanceof Error) {\n      debug('parse error');\n      socket.destroy(ret);\n    } else if (parser.incoming && parser.incoming.upgrade) {\n      // Upgrade or CONNECT\n      var bytesParsed = ret;\n      var req = parser.incoming;\n      debug('SERVER upgrade or connect', req.method);\n\n      socket.removeListener('data', socketOnData);\n      socket.removeListener('end', socketOnEnd);\n      socket.removeListener('close', serverSocketCloseListener);\n      parser.finish();\n      freeParser(parser, req);\n\n      var eventName = req.method === 'CONNECT' ? 'connect' : 'upgrade';\n      if (EventEmitter.listenerCount(self, eventName) > 0) {\n        debug('SERVER have listener for %s', eventName);\n        var bodyHead = d.slice(bytesParsed, d.length);\n\n        // TODO(isaacs): Need a way to reset a stream to fresh state\n        // IE, not flowing, and not explicitly paused.\n        socket._readableState.flowing = null;\n        self.emit(eventName, req, socket, bodyHead);\n      } else {\n        // Got upgrade header or CONNECT method, but have no handler.\n        socket.destroy();\n      }\n    }\n\n    if (socket._paused) {\n      // onIncoming paused the socket, we should pause the parser as well\n      debug('pause parser');\n      socket.parser.pause();\n    }\n  }\n\n  function socketOnEnd() {\n    var socket = this;\n    var ret = parser.finish();\n\n    if (ret instanceof Error) {\n      debug('parse error');\n      socket.destroy(ret);\n      return;\n    }\n\n    if (!self.httpAllowHalfOpen) {\n      abortIncoming();\n      if (socket.writable) socket.end();\n    } else if (outgoing.length) {\n      outgoing[outgoing.length - 1]._last = true;\n    } else if (socket._httpMessage) {\n      socket._httpMessage._last = true;\n    } else {\n      if (socket.writable) socket.end();\n    }\n  }\n\n\n  // The following callback is issued after the headers have been read on a\n  // new message. In this callback we setup the response object and pass it\n  // to the user.\n\n  socket._paused = false;\n  function socketOnDrain() {\n    // If we previously paused, then start reading again.\n    if (socket._paused) {\n      socket._paused = false;\n      socket.parser.resume();\n      socket.resume();\n    }\n  }\n  socket.on('drain', socketOnDrain);\n\n  function parserOnIncoming(req, shouldKeepAlive) {\n    incoming.push(req);\n\n    // If the writable end isn't consuming, then stop reading\n    // so that we don't become overwhelmed by a flood of\n    // pipelined requests that may never be resolved.\n    if (!socket._paused) {\n      var needPause = socket._writableState.needDrain;\n      if (needPause) {\n        socket._paused = true;\n        // We also need to pause the parser, but don't do that until after\n        // the call to execute, because we may still be processing the last\n        // chunk.\n        socket.pause();\n      }\n    }\n\n    var res = new ServerResponse(req);\n\n    res.shouldKeepAlive = shouldKeepAlive;\n    DTRACE_HTTP_SERVER_REQUEST(req, socket);\n    COUNTER_HTTP_SERVER_REQUEST();\n\n    if (socket._httpMessage) {\n      // There are already pending outgoing res, append.\n      outgoing.push(res);\n    } else {\n      res.assignSocket(socket);\n    }\n\n    // When we're finished writing the response, check if this is the last\n    // respose, if so destroy the socket.\n    res.on('prefinish', resOnFinish);\n    function resOnFinish() {\n      // Usually the first incoming element should be our request.  it may\n      // be that in the case abortIncoming() was called that the incoming\n      // array will be empty.\n      assert(incoming.length === 0 || incoming[0] === req);\n\n      incoming.shift();\n\n      // if the user never called req.read(), and didn't pipe() or\n      // .resume() or .on('data'), then we call req._dump() so that the\n      // bytes will be pulled off the wire.\n      if (!req._consuming && !req._readableState.resumeScheduled)\n        req._dump();\n\n      res.detachSocket(socket);\n\n      if (res._last) {\n        socket.destroySoon();\n      } else {\n        // start sending the next message\n        var m = outgoing.shift();\n        if (m) {\n          m.assignSocket(socket);\n        }\n      }\n    }\n\n    if (!util.isUndefined(req.headers.expect) &&\n        (req.httpVersionMajor == 1 && req.httpVersionMinor == 1) &&\n        continueExpression.test(req.headers['expect'])) {\n      res._expect_continue = true;\n      if (EventEmitter.listenerCount(self, 'checkContinue') > 0) {\n        self.emit('checkContinue', req, res);\n      } else {\n        res.writeContinue();\n        self.emit('request', req, res);\n      }\n    } else {\n      self.emit('request', req, res);\n    }\n    return false; // Not a HEAD response. (Not even a response!)\n  }\n}\nexports._connectionListener = connectionListener;\n",
  @"// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nfunction init(list) {\n  list._idleNext = list;\n  list._idlePrev = list;\n}\nexports.init = init;\n\n\n// show the most idle item\nfunction peek(list) {\n  if (list._idlePrev == list) return null;\n  return list._idlePrev;\n}\nexports.peek = peek;\n\n\n// remove the most idle item from the list\nfunction shift(list) {\n  var first = list._idlePrev;\n  remove(first);\n  return first;\n}\nexports.shift = shift;\n\n\n// remove a item from its list\nfunction remove(item) {\n  if (item._idleNext) {\n    item._idleNext._idlePrev = item._idlePrev;\n  }\n\n  if (item._idlePrev) {\n    item._idlePrev._idleNext = item._idleNext;\n  }\n\n  item._idleNext = null;\n  item._idlePrev = null;\n}\nexports.remove = remove;\n\n\n// remove a item from its list and place at the end.\nfunction append(list, item) {\n  remove(item);\n  item._idleNext = list._idleNext;\n  list._idleNext._idlePrev = item;\n  item._idlePrev = list;\n  list._idleNext = item;\n}\nexports.append = append;\n\n\nfunction isEmpty(list) {\n  return list._idleNext === list;\n}\nexports.isEmpty = isEmpty;\n",
  @"// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a duplex stream is just a stream that is both readable and writable.\n// Since JS doesn't have multiple prototypal inheritance, this class\n// prototypally inherits from Readable, and then parasitically from\n// Writable.\n\nmodule.exports = Duplex;\nvar util = require('util');\nvar Readable = require('_stream_readable');\nvar Writable = require('_stream_writable');\n\nutil.inherits(Duplex, Readable);\n\nObject.keys(Writable.prototype).forEach(function(method) {\n  if (!Duplex.prototype[method])\n    Duplex.prototype[method] = Writable.prototype[method];\n});\n\nfunction Duplex(options) {\n  if (!(this instanceof Duplex))\n    return new Duplex(options);\n\n  Readable.call(this, options);\n  Writable.call(this, options);\n\n  if (options && options.readable === false)\n    this.readable = false;\n\n  if (options && options.writable === false)\n    this.writable = false;\n\n  this.allowHalfOpen = true;\n  if (options && options.allowHalfOpen === false)\n    this.allowHalfOpen = false;\n\n  this.once('end', onend);\n}\n\n// the no-half-open enforcer\nfunction onend() {\n  // if we allow half-open state, or if the writable side ended,\n  // then we're ok.\n  if (this.allowHalfOpen || this._writableState.ended)\n    return;\n\n  // no more data can be written.\n  // But allow more writes to happen in this tick.\n  process.nextTick(this.end.bind(this));\n}\n",
  @"// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a passthrough stream.\n// basically just the most minimal sort of Transform stream.\n// Every written chunk gets output as-is.\n\nmodule.exports = PassThrough;\n\nvar Transform = require('_stream_transform');\nvar util = require('util');\nutil.inherits(PassThrough, Transform);\n\nfunction PassThrough(options) {\n  if (!(this instanceof PassThrough))\n    return new PassThrough(options);\n\n  Transform.call(this, options);\n}\n\nPassThrough.prototype._transform = function(chunk, encoding, cb) {\n  cb(null, chunk);\n};\n",
  @"// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nmodule.exports = Readable;\nReadable.ReadableState = ReadableState;\n\nvar EE = require('events').EventEmitter;\nvar Stream = require('stream');\nvar util = require('util');\nvar StringDecoder;\nvar debug = util.debuglog('stream');\n\nutil.inherits(Readable, Stream);\n\nfunction ReadableState(options, stream) {\n  options = options || {};\n\n  // object stream flag. Used to make read(n) ignore n and to\n  // make all the buffer merging and length checks go away\n  this.objectMode = !!options.objectMode;\n\n  if (stream instanceof Stream.Duplex)\n    this.objectMode = this.objectMode || !!options.readableObjectMode;\n\n  // the point at which it stops calling _read() to fill the buffer\n  // Note: 0 is a valid value, means \"don't call _read preemptively ever\"\n  var hwm = options.highWaterMark;\n  var defaultHwm = this.objectMode ? 16 : 16 * 1024;\n  this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;\n\n  // cast to ints.\n  this.highWaterMark = ~~this.highWaterMark;\n\n  this.buffer = [];\n  this.length = 0;\n  this.pipes = null;\n  this.pipesCount = 0;\n  this.flowing = null;\n  this.ended = false;\n  this.endEmitted = false;\n  this.reading = false;\n\n  // a flag to be able to tell if the onwrite cb is called immediately,\n  // or on a later tick.  We set this to true at first, because any\n  // actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first write call.\n  this.sync = true;\n\n  // whenever we return null, then we set a flag to say\n  // that we're awaiting a 'readable' event emission.\n  this.needReadable = false;\n  this.emittedReadable = false;\n  this.readableListening = false;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // when piping, we only care about 'readable' events that happen\n  // after read()ing all the bytes and not getting any pushback.\n  this.ranOut = false;\n\n  // the number of writers that are awaiting a drain event in .pipe()s\n  this.awaitDrain = 0;\n\n  // if true, a maybeReadMore has been scheduled\n  this.readingMore = false;\n\n  // if true, stream is in old mode\n  this.oldMode = false;\n\n  this.decoder = null;\n  this.encoding = null;\n  if (options.encoding) {\n    if (!StringDecoder)\n      StringDecoder = require('string_decoder').StringDecoder;\n    this.decoder = new StringDecoder(options.encoding);\n    this.encoding = options.encoding;\n  }\n}\n\nfunction Readable(options) {\n  if (!(this instanceof Readable))\n    return new Readable(options);\n\n  this._readableState = new ReadableState(options, this);\n\n  // legacy\n  this.readable = true;\n\n  Stream.call(this);\n}\n\n// Manually shove something into the read() buffer.\n// This returns true if the highWaterMark has not been hit yet,\n// similar to how Writable.write() returns true if you should\n// write() some more.\nReadable.prototype.push = function(chunk, encoding) {\n  var state = this._readableState;\n\n  if (util.isString(chunk) && !state.objectMode) {\n    encoding = encoding || state.defaultEncoding;\n    if (encoding !== state.encoding) {\n      chunk = new Buffer(chunk, encoding);\n      encoding = '';\n    }\n  }\n\n  return readableAddChunk(this, state, chunk, encoding, false);\n};\n\n// Unshift should *always* be something directly out of read()\nReadable.prototype.unshift = function(chunk) {\n  var state = this._readableState;\n  return readableAddChunk(this, state, chunk, '', true);\n};\n\nfunction readableAddChunk(stream, state, chunk, encoding, addToFront) {\n  var er = chunkInvalid(state, chunk);\n  if (er) {\n    stream.emit('error', er);\n  } else if (chunk === null) {\n    state.reading = false;\n    if (!state.ended)\n      onEofChunk(stream, state);\n  } else if (state.objectMode || chunk && chunk.length > 0) {\n    if (state.ended && !addToFront) {\n      var e = new Error('stream.push() after EOF');\n      stream.emit('error', e);\n    } else if (state.endEmitted && addToFront) {\n      var e = new Error('stream.unshift() after end event');\n      stream.emit('error', e);\n    } else {\n      if (state.decoder && !addToFront && !encoding)\n        chunk = state.decoder.write(chunk);\n\n      if (!addToFront)\n        state.reading = false;\n\n      // if we want the data now, just emit it.\n      if (state.flowing && state.length === 0 && !state.sync) {\n        stream.emit('data', chunk);\n        stream.read(0);\n      } else {\n        // update the buffer info.\n        state.length += state.objectMode ? 1 : chunk.length;\n        if (addToFront)\n          state.buffer.unshift(chunk);\n        else\n          state.buffer.push(chunk);\n\n        if (state.needReadable)\n          emitReadable(stream);\n      }\n\n      maybeReadMore(stream, state);\n    }\n  } else if (!addToFront) {\n    state.reading = false;\n  }\n\n  return needMoreData(state);\n}\n\n\n\n// if it's past the high water mark, we can push in some more.\n// Also, if we have no data yet, we can stand some\n// more bytes.  This is to work around cases where hwm=0,\n// such as the repl.  Also, if the push() triggered a\n// readable event, and the user called read(largeNumber) such that\n// needReadable was set, then we ought to push more, so that another\n// 'readable' event will be triggered.\nfunction needMoreData(state) {\n  return !state.ended &&\n         (state.needReadable ||\n          state.length < state.highWaterMark ||\n          state.length === 0);\n}\n\n// backwards compatibility.\nReadable.prototype.setEncoding = function(enc) {\n  if (!StringDecoder)\n    StringDecoder = require('string_decoder').StringDecoder;\n  this._readableState.decoder = new StringDecoder(enc);\n  this._readableState.encoding = enc;\n  return this;\n};\n\n// Don't raise the hwm > 128MB\nvar MAX_HWM = 0x800000;\nfunction roundUpToNextPowerOf2(n) {\n  if (n >= MAX_HWM) {\n    n = MAX_HWM;\n  } else {\n    // Get the next highest power of 2\n    n--;\n    for (var p = 1; p < 32; p <<= 1) n |= n >> p;\n    n++;\n  }\n  return n;\n}\n\nfunction howMuchToRead(n, state) {\n  if (state.length === 0 && state.ended)\n    return 0;\n\n  if (state.objectMode)\n    return n === 0 ? 0 : 1;\n\n  if (isNaN(n) || util.isNull(n)) {\n    // only flow one buffer at a time\n    if (state.flowing && state.buffer.length)\n      return state.buffer[0].length;\n    else\n      return state.length;\n  }\n\n  if (n <= 0)\n    return 0;\n\n  // If we're asking for more than the target buffer level,\n  // then raise the water mark.  Bump up to the next highest\n  // power of 2, to prevent increasing it excessively in tiny\n  // amounts.\n  if (n > state.highWaterMark)\n    state.highWaterMark = roundUpToNextPowerOf2(n);\n\n  // don't have that much.  return null, unless we've ended.\n  if (n > state.length) {\n    if (!state.ended) {\n      state.needReadable = true;\n      return 0;\n    } else\n      return state.length;\n  }\n\n  return n;\n}\n\n// you can override either this method, or the async _read(n) below.\nReadable.prototype.read = function(n) {\n  debug('read', n);\n  var state = this._readableState;\n  var nOrig = n;\n\n  if (!util.isNumber(n) || n > 0)\n    state.emittedReadable = false;\n\n  // if we're doing read(0) to trigger a readable event, but we\n  // already have a bunch of data in the buffer, then just trigger\n  // the 'readable' event and move on.\n  if (n === 0 &&\n      state.needReadable &&\n      (state.length >= state.highWaterMark || state.ended)) {\n    debug('read: emitReadable', state.length, state.ended);\n    if (state.length === 0 && state.ended)\n      endReadable(this);\n    else\n      emitReadable(this);\n    return null;\n  }\n\n  n = howMuchToRead(n, state);\n\n  // if we've ended, and we're now clear, then finish it up.\n  if (n === 0 && state.ended) {\n    if (state.length === 0)\n      endReadable(this);\n    return null;\n  }\n\n  // All the actual chunk generation logic needs to be\n  // *below* the call to _read.  The reason is that in certain\n  // synthetic stream cases, such as passthrough streams, _read\n  // may be a completely synchronous operation which may change\n  // the state of the read buffer, providing enough data when\n  // before there was *not* enough.\n  //\n  // So, the steps are:\n  // 1. Figure out what the state of things will be after we do\n  // a read from the buffer.\n  //\n  // 2. If that resulting state will trigger a _read, then call _read.\n  // Note that this may be asynchronous, or synchronous.  Yes, it is\n  // deeply ugly to write APIs this way, but that still doesn't mean\n  // that the Readable class should behave improperly, as streams are\n  // designed to be sync/async agnostic.\n  // Take note if the _read call is sync or async (ie, if the read call\n  // has returned yet), so that we know whether or not it's safe to emit\n  // 'readable' etc.\n  //\n  // 3. Actually pull the requested chunks out of the buffer and return.\n\n  // if we need a readable event, then we need to do some reading.\n  var doRead = state.needReadable;\n  debug('need readable', doRead);\n\n  // if we currently have less than the highWaterMark, then also read some\n  if (state.length === 0 || state.length - n < state.highWaterMark) {\n    doRead = true;\n    debug('length less than watermark', doRead);\n  }\n\n  // however, if we've ended, then there's no point, and if we're already\n  // reading, then it's unnecessary.\n  if (state.ended || state.reading) {\n    doRead = false;\n    debug('reading or ended', doRead);\n  }\n\n  if (doRead) {\n    debug('do read');\n    state.reading = true;\n    state.sync = true;\n    // if the length is currently zero, then we *need* a readable event.\n    if (state.length === 0)\n      state.needReadable = true;\n    // call internal read method\n    this._read(state.highWaterMark);\n    state.sync = false;\n  }\n\n  // If _read pushed data synchronously, then `reading` will be false,\n  // and we need to re-evaluate how much data we can return to the user.\n  if (doRead && !state.reading)\n    n = howMuchToRead(nOrig, state);\n\n  var ret;\n  if (n > 0)\n    ret = fromList(n, state);\n  else\n    ret = null;\n\n  if (util.isNull(ret)) {\n    state.needReadable = true;\n    n = 0;\n  }\n\n  state.length -= n;\n\n  // If we have nothing in the buffer, then we want to know\n  // as soon as we *do* get something into the buffer.\n  if (state.length === 0 && !state.ended)\n    state.needReadable = true;\n\n  // If we tried to read() past the EOF, then emit end on the next tick.\n  if (nOrig !== n && state.ended && state.length === 0)\n    endReadable(this);\n\n  if (!util.isNull(ret))\n    this.emit('data', ret);\n\n  return ret;\n};\n\nfunction chunkInvalid(state, chunk) {\n  var er = null;\n  if (!util.isBuffer(chunk) &&\n      !util.isString(chunk) &&\n      !util.isNullOrUndefined(chunk) &&\n      !state.objectMode) {\n    er = new TypeError('Invalid non-string/buffer chunk');\n  }\n  return er;\n}\n\n\nfunction onEofChunk(stream, state) {\n  if (state.decoder && !state.ended) {\n    var chunk = state.decoder.end();\n    if (chunk && chunk.length) {\n      state.buffer.push(chunk);\n      state.length += state.objectMode ? 1 : chunk.length;\n    }\n  }\n  state.ended = true;\n\n  // emit 'readable' now to make sure it gets picked up.\n  emitReadable(stream);\n}\n\n// Don't emit readable right away in sync mode, because this can trigger\n// another read() call => stack overflow.  This way, it might trigger\n// a nextTick recursion warning, but that's not so bad.\nfunction emitReadable(stream) {\n  var state = stream._readableState;\n  state.needReadable = false;\n  if (!state.emittedReadable) {\n    debug('emitReadable', state.flowing);\n    state.emittedReadable = true;\n    if (state.sync)\n      process.nextTick(function() {\n        emitReadable_(stream);\n      });\n    else\n      emitReadable_(stream);\n  }\n}\n\nfunction emitReadable_(stream) {\n  debug('emit readable');\n  stream.emit('readable');\n  flow(stream);\n}\n\n\n// at this point, the user has presumably seen the 'readable' event,\n// and called read() to consume some data.  that may have triggered\n// in turn another _read(n) call, in which case reading = true if\n// it's in progress.\n// However, if we're not ended, or reading, and the length < hwm,\n// then go ahead and try to read some more preemptively.\nfunction maybeReadMore(stream, state) {\n  if (!state.readingMore) {\n    state.readingMore = true;\n    process.nextTick(function() {\n      maybeReadMore_(stream, state);\n    });\n  }\n}\n\nfunction maybeReadMore_(stream, state) {\n  var len = state.length;\n  while (!state.reading && !state.flowing && !state.ended &&\n         state.length < state.highWaterMark) {\n    debug('maybeReadMore read 0');\n    stream.read(0);\n    if (len === state.length)\n      // didn't get any data, stop spinning.\n      break;\n    else\n      len = state.length;\n  }\n  state.readingMore = false;\n}\n\n// abstract method.  to be overridden in specific implementation classes.\n// call cb(er, data) where data is <= n in length.\n// for virtual (non-string, non-buffer) streams, \"length\" is somewhat\n// arbitrary, and perhaps not very meaningful.\nReadable.prototype._read = function(n) {\n  this.emit('error', new Error('not implemented'));\n};\n\nReadable.prototype.pipe = function(dest, pipeOpts) {\n  var src = this;\n  var state = this._readableState;\n\n  switch (state.pipesCount) {\n    case 0:\n      state.pipes = dest;\n      break;\n    case 1:\n      state.pipes = [state.pipes, dest];\n      break;\n    default:\n      state.pipes.push(dest);\n      break;\n  }\n  state.pipesCount += 1;\n  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);\n\n  var doEnd = (!pipeOpts || pipeOpts.end !== false) &&\n              dest !== process.stdout &&\n              dest !== process.stderr;\n\n  var endFn = doEnd ? onend : cleanup;\n  if (state.endEmitted)\n    process.nextTick(endFn);\n  else\n    src.once('end', endFn);\n\n  dest.on('unpipe', onunpipe);\n  function onunpipe(readable) {\n    debug('onunpipe');\n    if (readable === src) {\n      cleanup();\n    }\n  }\n\n  function onend() {\n    debug('onend');\n    dest.end();\n  }\n\n  // when the dest drains, it reduces the awaitDrain counter\n  // on the source.  This would be more elegant with a .once()\n  // handler in flow(), but adding and removing repeatedly is\n  // too slow.\n  var ondrain = pipeOnDrain(src);\n  dest.on('drain', ondrain);\n\n  function cleanup() {\n    debug('cleanup');\n    // cleanup event handlers once the pipe is broken\n    dest.removeListener('close', onclose);\n    dest.removeListener('finish', onfinish);\n    dest.removeListener('drain', ondrain);\n    dest.removeListener('error', onerror);\n    dest.removeListener('unpipe', onunpipe);\n    src.removeListener('end', onend);\n    src.removeListener('end', cleanup);\n    src.removeListener('data', ondata);\n\n    // if the reader is waiting for a drain event from this\n    // specific writer, then it would cause it to never start\n    // flowing again.\n    // So, if this is awaiting a drain, then we just call it now.\n    // If we don't know, then assume that we are waiting for one.\n    if (state.awaitDrain &&\n        (!dest._writableState || dest._writableState.needDrain))\n      ondrain();\n  }\n\n  src.on('data', ondata);\n  function ondata(chunk) {\n    debug('ondata');\n    var ret = dest.write(chunk);\n    if (false === ret) {\n      debug('false write response, pause',\n            src._readableState.awaitDrain);\n      src._readableState.awaitDrain++;\n      src.pause();\n    }\n  }\n\n  // if the dest has an error, then stop piping into it.\n  // however, don't suppress the throwing behavior for this.\n  function onerror(er) {\n    debug('onerror', er);\n    unpipe();\n    dest.removeListener('error', onerror);\n    if (EE.listenerCount(dest, 'error') === 0)\n      dest.emit('error', er);\n  }\n  // This is a brutally ugly hack to make sure that our error handler\n  // is attached before any userland ones.  NEVER DO THIS.\n  if (!dest._events || !dest._events.error)\n    dest.on('error', onerror);\n  else if (Array.isArray(dest._events.error))\n    dest._events.error.unshift(onerror);\n  else\n    dest._events.error = [onerror, dest._events.error];\n\n\n\n  // Both close and finish should trigger unpipe, but only once.\n  function onclose() {\n    dest.removeListener('finish', onfinish);\n    unpipe();\n  }\n  dest.once('close', onclose);\n  function onfinish() {\n    debug('onfinish');\n    dest.removeListener('close', onclose);\n    unpipe();\n  }\n  dest.once('finish', onfinish);\n\n  function unpipe() {\n    debug('unpipe');\n    src.unpipe(dest);\n  }\n\n  // tell the dest that it's being piped to\n  dest.emit('pipe', src);\n\n  // start the flow if it hasn't been started already.\n  if (!state.flowing) {\n    debug('pipe resume');\n    src.resume();\n  }\n\n  return dest;\n};\n\nfunction pipeOnDrain(src) {\n  return function() {\n    var state = src._readableState;\n    debug('pipeOnDrain', state.awaitDrain);\n    if (state.awaitDrain)\n      state.awaitDrain--;\n    if (state.awaitDrain === 0 && EE.listenerCount(src, 'data')) {\n      state.flowing = true;\n      flow(src);\n    }\n  };\n}\n\n\nReadable.prototype.unpipe = function(dest) {\n  var state = this._readableState;\n\n  // if we're not piping anywhere, then do nothing.\n  if (state.pipesCount === 0)\n    return this;\n\n  // just one destination.  most common case.\n  if (state.pipesCount === 1) {\n    // passed in one, but it's not the right one.\n    if (dest && dest !== state.pipes)\n      return this;\n\n    if (!dest)\n      dest = state.pipes;\n\n    // got a match.\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n    if (dest)\n      dest.emit('unpipe', this);\n    return this;\n  }\n\n  // slow case. multiple pipe destinations.\n\n  if (!dest) {\n    // remove all.\n    var dests = state.pipes;\n    var len = state.pipesCount;\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n\n    for (var i = 0; i < len; i++)\n      dests[i].emit('unpipe', this);\n    return this;\n  }\n\n  // try to find the right one.\n  var i = state.pipes.indexOf(dest);\n  if (i === -1)\n    return this;\n\n  state.pipes.splice(i, 1);\n  state.pipesCount -= 1;\n  if (state.pipesCount === 1)\n    state.pipes = state.pipes[0];\n\n  dest.emit('unpipe', this);\n\n  return this;\n};\n\n// set up data events if they are asked for\n// Ensure readable listeners eventually get something\nReadable.prototype.on = function(ev, fn) {\n  var res = Stream.prototype.on.call(this, ev, fn);\n\n  // If listening to data, and it has not explicitly been paused,\n  // then call resume to start the flow of data on the next tick.\n  if (ev === 'data' && false !== this._readableState.flowing) {\n    this.resume();\n  }\n\n  if (ev === 'readable' && this.readable) {\n    var state = this._readableState;\n    if (!state.readableListening) {\n      state.readableListening = true;\n      state.emittedReadable = false;\n      state.needReadable = true;\n      if (!state.reading) {\n        var self = this;\n        process.nextTick(function() {\n          debug('readable nexttick read 0');\n          self.read(0);\n        });\n      } else if (state.length) {\n        emitReadable(this, state);\n      }\n    }\n  }\n\n  return res;\n};\nReadable.prototype.addListener = Readable.prototype.on;\n\n// pause() and resume() are remnants of the legacy readable stream API\n// If the user uses them, then switch into old mode.\nReadable.prototype.resume = function() {\n  var state = this._readableState;\n  if (!state.flowing) {\n    debug('resume');\n    state.flowing = true;\n    resume(this, state);\n  }\n  return this;\n};\n\nfunction resume(stream, state) {\n  if (!state.resumeScheduled) {\n    state.resumeScheduled = true;\n    process.nextTick(function() {\n      resume_(stream, state);\n    });\n  }\n}\n\nfunction resume_(stream, state) {\n  if (!state.reading) {\n    debug('resume read 0');\n    stream.read(0);\n  }\n\n  state.resumeScheduled = false;\n  stream.emit('resume');\n  flow(stream);\n  if (state.flowing && !state.reading)\n    stream.read(0);\n}\n\nReadable.prototype.pause = function() {\n  debug('call pause flowing=%j', this._readableState.flowing);\n  if (false !== this._readableState.flowing) {\n    debug('pause');\n    this._readableState.flowing = false;\n    this.emit('pause');\n  }\n  return this;\n};\n\nfunction flow(stream) {\n  var state = stream._readableState;\n  debug('flow', state.flowing);\n  if (state.flowing) {\n    do {\n      var chunk = stream.read();\n    } while (null !== chunk && state.flowing);\n  }\n}\n\n// wrap an old-style stream as the async data source.\n// This is *not* part of the readable stream interface.\n// It is an ugly unfortunate mess of history.\nReadable.prototype.wrap = function(stream) {\n  var state = this._readableState;\n  var paused = false;\n\n  var self = this;\n  stream.on('end', function() {\n    debug('wrapped end');\n    if (state.decoder && !state.ended) {\n      var chunk = state.decoder.end();\n      if (chunk && chunk.length)\n        self.push(chunk);\n    }\n\n    self.push(null);\n  });\n\n  stream.on('data', function(chunk) {\n    debug('wrapped data');\n    if (state.decoder)\n      chunk = state.decoder.write(chunk);\n    if (!chunk || !state.objectMode && !chunk.length)\n      return;\n\n    var ret = self.push(chunk);\n    if (!ret) {\n      paused = true;\n      stream.pause();\n    }\n  });\n\n  // proxy all the other methods.\n  // important when wrapping filters and duplexes.\n  for (var i in stream) {\n    if (util.isFunction(stream[i]) && util.isUndefined(this[i])) {\n      this[i] = function(method) { return function() {\n        return stream[method].apply(stream, arguments);\n      }}(i);\n    }\n  }\n\n  // proxy certain important events.\n  var events = ['error', 'close', 'destroy', 'pause', 'resume'];\n  events.forEach(function(ev) {\n    stream.on(ev, self.emit.bind(self, ev));\n  });\n\n  // when we try to consume some more bytes, simply unpause the\n  // underlying stream.\n  self._read = function(n) {\n    debug('wrapped _read', n);\n    if (paused) {\n      paused = false;\n      stream.resume();\n    }\n  };\n\n  return self;\n};\n\n\n\n// exposed for testing purposes only.\nReadable._fromList = fromList;\n\n// Pluck off n bytes from an array of buffers.\n// Length is the combined lengths of all the buffers in the list.\nfunction fromList(n, state) {\n  var list = state.buffer;\n  var length = state.length;\n  var stringMode = !!state.decoder;\n  var objectMode = !!state.objectMode;\n  var ret;\n\n  // nothing in the list, definitely empty.\n  if (list.length === 0)\n    return null;\n\n  if (length === 0)\n    ret = null;\n  else if (objectMode)\n    ret = list.shift();\n  else if (!n || n >= length) {\n    // read it all, truncate the array.\n    if (stringMode)\n      ret = list.join('');\n    else\n      ret = Buffer.concat(list, length);\n    list.length = 0;\n  } else {\n    // read just some of it.\n    if (n < list[0].length) {\n      // just take a part of the first list item.\n      // slice is the same for buffers and strings.\n      var buf = list[0];\n      ret = buf.slice(0, n);\n      list[0] = buf.slice(n);\n    } else if (n === list[0].length) {\n      // first list is a perfect match\n      ret = list.shift();\n    } else {\n      // complex case.\n      // we have enough to cover it, but it spans past the first buffer.\n      if (stringMode)\n        ret = '';\n      else\n        ret = new Buffer(n);\n\n      var c = 0;\n      for (var i = 0, l = list.length; i < l && c < n; i++) {\n        var buf = list[0];\n        var cpy = Math.min(n - c, buf.length);\n\n        if (stringMode)\n          ret += buf.slice(0, cpy);\n        else\n          buf.copy(ret, c, 0, cpy);\n\n        if (cpy < buf.length)\n          list[0] = buf.slice(cpy);\n        else\n          list.shift();\n\n        c += cpy;\n      }\n    }\n  }\n\n  return ret;\n}\n\nfunction endReadable(stream) {\n  var state = stream._readableState;\n\n  // If we get here before consuming all the bytes, then that is a\n  // bug in node.  Should never happen.\n  if (state.length > 0)\n    throw new Error('endReadable called on non-empty stream');\n\n  if (!state.endEmitted) {\n    state.ended = true;\n    process.nextTick(function() {\n      // Check that we didn't get one last unshift.\n      if (!state.endEmitted && state.length === 0) {\n        state.endEmitted = true;\n        stream.readable = false;\n        stream.emit('end');\n      }\n    });\n  }\n}\n",
  @"// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// a transform stream is a readable/writable stream where you do\n// something with the data.  Sometimes it's called a \"filter\",\n// but that's not a great name for it, since that implies a thing where\n// some bits pass through, and others are simply ignored.  (That would\n// be a valid example of a transform, of course.)\n//\n// While the output is causally related to the input, it's not a\n// necessarily symmetric or synchronous transformation.  For example,\n// a zlib stream might take multiple plain-text writes(), and then\n// emit a single compressed chunk some time in the future.\n//\n// Here's how this works:\n//\n// The Transform stream has all the aspects of the readable and writable\n// stream classes.  When you write(chunk), that calls _write(chunk,cb)\n// internally, and returns false if there's a lot of pending writes\n// buffered up.  When you call read(), that calls _read(n) until\n// there's enough pending readable data buffered up.\n//\n// In a transform stream, the written data is placed in a buffer.  When\n// _read(n) is called, it transforms the queued up data, calling the\n// buffered _write cb's as it consumes chunks.  If consuming a single\n// written chunk would result in multiple output chunks, then the first\n// outputted bit calls the readcb, and subsequent chunks just go into\n// the read buffer, and will cause it to emit 'readable' if necessary.\n//\n// This way, back-pressure is actually determined by the reading side,\n// since _read has to be called to start processing a new chunk.  However,\n// a pathological inflate type of transform can cause excessive buffering\n// here.  For example, imagine a stream where every byte of input is\n// interpreted as an integer from 0-255, and then results in that many\n// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in\n// 1kb of data being output.  In this case, you could write a very small\n// amount of input, and end up with a very large amount of output.  In\n// such a pathological inflating mechanism, there'd be no way to tell\n// the system to stop doing the transform.  A single 4MB write could\n// cause the system to run out of memory.\n//\n// However, even in such a pathological case, only a single written chunk\n// would be consumed, and then the rest would wait (un-transformed) until\n// the results of the previous transformed chunk were consumed.\n\nmodule.exports = Transform;\n\nvar Duplex = require('_stream_duplex');\nvar util = require('util');\nutil.inherits(Transform, Duplex);\n\n\nfunction TransformState(stream) {\n  this.afterTransform = function(er, data) {\n    return afterTransform(stream, er, data);\n  };\n\n  this.needTransform = false;\n  this.transforming = false;\n  this.writecb = null;\n  this.writechunk = null;\n}\n\nfunction afterTransform(stream, er, data) {\n  var ts = stream._transformState;\n  ts.transforming = false;\n\n  var cb = ts.writecb;\n\n  if (!cb)\n    return stream.emit('error', new Error('no writecb in Transform class'));\n\n  ts.writechunk = null;\n  ts.writecb = null;\n\n  if (!util.isNullOrUndefined(data))\n    stream.push(data);\n\n  if (cb)\n    cb(er);\n\n  var rs = stream._readableState;\n  rs.reading = false;\n  if (rs.needReadable || rs.length < rs.highWaterMark) {\n    stream._read(rs.highWaterMark);\n  }\n}\n\n\nfunction Transform(options) {\n  if (!(this instanceof Transform))\n    return new Transform(options);\n\n  Duplex.call(this, options);\n\n  this._transformState = new TransformState(this);\n\n  // when the writable side finishes, then flush out anything remaining.\n  var stream = this;\n\n  // start out asking for a readable event once data is transformed.\n  this._readableState.needReadable = true;\n\n  // we have implemented the _read method, and done the other things\n  // that Readable wants before the first _read call, so unset the\n  // sync guard flag.\n  this._readableState.sync = false;\n\n  this.once('prefinish', function() {\n    if (util.isFunction(this._flush))\n      this._flush(function(er) {\n        done(stream, er);\n      });\n    else\n      done(stream);\n  });\n}\n\nTransform.prototype.push = function(chunk, encoding) {\n  this._transformState.needTransform = false;\n  return Duplex.prototype.push.call(this, chunk, encoding);\n};\n\n// This is the part where you do stuff!\n// override this function in implementation classes.\n// 'chunk' is an input chunk.\n//\n// Call `push(newChunk)` to pass along transformed output\n// to the readable side.  You may call 'push' zero or more times.\n//\n// Call `cb(err)` when you are done with this chunk.  If you pass\n// an error, then that'll put the hurt on the whole operation.  If you\n// never call cb(), then you'll never get another chunk.\nTransform.prototype._transform = function(chunk, encoding, cb) {\n  throw new Error('not implemented');\n};\n\nTransform.prototype._write = function(chunk, encoding, cb) {\n  var ts = this._transformState;\n  ts.writecb = cb;\n  ts.writechunk = chunk;\n  ts.writeencoding = encoding;\n  if (!ts.transforming) {\n    var rs = this._readableState;\n    if (ts.needTransform ||\n        rs.needReadable ||\n        rs.length < rs.highWaterMark)\n      this._read(rs.highWaterMark);\n  }\n};\n\n// Doesn't matter what the args are here.\n// _transform does all the work.\n// That we got here means that the readable side wants more data.\nTransform.prototype._read = function(n) {\n  var ts = this._transformState;\n\n  if (!util.isNull(ts.writechunk) && ts.writecb && !ts.transforming) {\n    ts.transforming = true;\n    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);\n  } else {\n    // mark that we need a transform, so that any data that comes in\n    // will get processed, now that we've asked for it.\n    ts.needTransform = true;\n  }\n};\n\n\nfunction done(stream, er) {\n  if (er)\n    return stream.emit('error', er);\n\n  // if there's nothing in the write buffer, then that means\n  // that nothing more will ever be provided\n  var ws = stream._writableState;\n  var ts = stream._transformState;\n\n  if (ws.length)\n    throw new Error('calling transform done when ws.length != 0');\n\n  if (ts.transforming)\n    throw new Error('calling transform done when still transforming');\n\n  return stream.push(null);\n}\n",
  @"// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// A bit simpler than readable streams.\n// Implement an async ._write(chunk, cb), and it'll handle all\n// the drain event emission and buffering.\n\nmodule.exports = Writable;\nWritable.WritableState = WritableState;\n\nvar util = require('util');\nvar Stream = require('stream');\n\nutil.inherits(Writable, Stream);\n\nfunction WriteReq(chunk, encoding, cb) {\n  this.chunk = chunk;\n  this.encoding = encoding;\n  this.callback = cb;\n}\n\nfunction WritableState(options, stream) {\n  options = options || {};\n\n  // object stream flag to indicate whether or not this stream\n  // contains buffers or objects.\n  this.objectMode = !!options.objectMode;\n\n  if (stream instanceof Stream.Duplex)\n    this.objectMode = this.objectMode || !!options.writableObjectMode;\n\n  // the point at which write() starts returning false\n  // Note: 0 is a valid value, means that we always return false if\n  // the entire buffer is not flushed immediately on write()\n  var hwm = options.highWaterMark;\n  var defaultHwm = this.objectMode ? 16 : 16 * 1024;\n  this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;\n\n  // cast to ints.\n  this.highWaterMark = ~~this.highWaterMark;\n\n  this.needDrain = false;\n  // at the start of calling end()\n  this.ending = false;\n  // when end() has been called, and returned\n  this.ended = false;\n  // when 'finish' is emitted\n  this.finished = false;\n\n  // should we decode strings into buffers before passing to _write?\n  // this is here so that some node-core streams can optimize string\n  // handling at a lower level.\n  var noDecode = options.decodeStrings === false;\n  this.decodeStrings = !noDecode;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // not an actual buffer we keep track of, but a measurement\n  // of how much we're waiting to get pushed to some underlying\n  // socket or file.\n  this.length = 0;\n\n  // a flag to see when we're in the middle of a write.\n  this.writing = false;\n\n  // when true all writes will be buffered until .uncork() call\n  this.corked = 0;\n\n  // a flag to be able to tell if the onwrite cb is called immediately,\n  // or on a later tick.  We set this to true at first, because any\n  // actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first write call.\n  this.sync = true;\n\n  // a flag to know if we're processing previously buffered items, which\n  // may call the _write() callback in the same tick, so that we don't\n  // end up in an overlapped onwrite situation.\n  this.bufferProcessing = false;\n\n  // the callback that's passed to _write(chunk,cb)\n  this.onwrite = function(er) {\n    onwrite(stream, er);\n  };\n\n  // the callback that the user supplies to write(chunk,encoding,cb)\n  this.writecb = null;\n\n  // the amount that is being written when _write is called.\n  this.writelen = 0;\n\n  this.buffer = [];\n\n  // number of pending user-supplied write callbacks\n  // this must be 0 before 'finish' can be emitted\n  this.pendingcb = 0;\n\n  // emit prefinish if the only thing we're waiting for is _write cbs\n  // This is relevant for synchronous Transform streams\n  this.prefinished = false;\n\n  // True if the error was already emitted and should not be thrown again\n  this.errorEmitted = false;\n}\n\nfunction Writable(options) {\n  // Writable ctor is applied to Duplexes, though they're not\n  // instanceof Writable, they're instanceof Readable.\n  if (!(this instanceof Writable) && !(this instanceof Stream.Duplex))\n    return new Writable(options);\n\n  this._writableState = new WritableState(options, this);\n\n  // legacy.\n  this.writable = true;\n\n  Stream.call(this);\n}\n\n// Otherwise people can pipe Writable streams, which is just wrong.\nWritable.prototype.pipe = function() {\n  this.emit('error', new Error('Cannot pipe. Not readable.'));\n};\n\n\nfunction writeAfterEnd(stream, state, cb) {\n  var er = new Error('write after end');\n  // TODO: defer error events consistently everywhere, not just the cb\n  stream.emit('error', er);\n  process.nextTick(function() {\n    cb(er);\n  });\n}\n\n// If we get something that is not a buffer, string, null, or undefined,\n// and we're not in objectMode, then that's an error.\n// Otherwise stream chunks are all considered to be of length=1, and the\n// watermarks determine how many objects to keep in the buffer, rather than\n// how many bytes or characters.\nfunction validChunk(stream, state, chunk, cb) {\n  var valid = true;\n  if (!util.isBuffer(chunk) &&\n      !util.isString(chunk) &&\n      !util.isNullOrUndefined(chunk) &&\n      !state.objectMode) {\n    var er = new TypeError('Invalid non-string/buffer chunk');\n    stream.emit('error', er);\n    process.nextTick(function() {\n      cb(er);\n    });\n    valid = false;\n  }\n  return valid;\n}\n\nWritable.prototype.write = function(chunk, encoding, cb) {\n  var state = this._writableState;\n  var ret = false;\n\n  if (util.isFunction(encoding)) {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (util.isBuffer(chunk))\n    encoding = 'buffer';\n  else if (!encoding)\n    encoding = state.defaultEncoding;\n\n  if (!util.isFunction(cb))\n    cb = function() {};\n\n  if (state.ended)\n    writeAfterEnd(this, state, cb);\n  else if (validChunk(this, state, chunk, cb)) {\n    state.pendingcb++;\n    ret = writeOrBuffer(this, state, chunk, encoding, cb);\n  }\n\n  return ret;\n};\n\nWritable.prototype.cork = function() {\n  var state = this._writableState;\n\n  state.corked++;\n};\n\nWritable.prototype.uncork = function() {\n  var state = this._writableState;\n\n  if (state.corked) {\n    state.corked--;\n\n    if (!state.writing &&\n        !state.corked &&\n        !state.finished &&\n        !state.bufferProcessing &&\n        state.buffer.length)\n      clearBuffer(this, state);\n  }\n};\n\nfunction decodeChunk(state, chunk, encoding) {\n  if (!state.objectMode &&\n      state.decodeStrings !== false &&\n      util.isString(chunk)) {\n    chunk = new Buffer(chunk, encoding);\n  }\n  return chunk;\n}\n\n// if we're already writing something, then just put this\n// in the queue, and wait our turn.  Otherwise, call _write\n// If we return false, then we need a drain event, so set that flag.\nfunction writeOrBuffer(stream, state, chunk, encoding, cb) {\n  chunk = decodeChunk(state, chunk, encoding);\n  if (util.isBuffer(chunk))\n    encoding = 'buffer';\n  var len = state.objectMode ? 1 : chunk.length;\n\n  state.length += len;\n\n  var ret = state.length < state.highWaterMark;\n  // we must ensure that previous needDrain will not be reset to false.\n  if (!ret)\n    state.needDrain = true;\n\n  if (state.writing || state.corked)\n    state.buffer.push(new WriteReq(chunk, encoding, cb));\n  else\n    doWrite(stream, state, false, len, chunk, encoding, cb);\n\n  return ret;\n}\n\nfunction doWrite(stream, state, writev, len, chunk, encoding, cb) {\n  state.writelen = len;\n  state.writecb = cb;\n  state.writing = true;\n  state.sync = true;\n  if (writev)\n    stream._writev(chunk, state.onwrite);\n  else\n    stream._write(chunk, encoding, state.onwrite);\n  state.sync = false;\n}\n\nfunction onwriteError(stream, state, sync, er, cb) {\n  if (sync)\n    process.nextTick(function() {\n      state.pendingcb--;\n      cb(er);\n    });\n  else {\n    state.pendingcb--;\n    cb(er);\n  }\n\n  stream._writableState.errorEmitted = true;\n  stream.emit('error', er);\n}\n\nfunction onwriteStateUpdate(state) {\n  state.writing = false;\n  state.writecb = null;\n  state.length -= state.writelen;\n  state.writelen = 0;\n}\n\nfunction onwrite(stream, er) {\n  var state = stream._writableState;\n  var sync = state.sync;\n  var cb = state.writecb;\n\n  onwriteStateUpdate(state);\n\n  if (er)\n    onwriteError(stream, state, sync, er, cb);\n  else {\n    // Check if we're actually ready to finish, but don't emit yet\n    var finished = needFinish(stream, state);\n\n    if (!finished &&\n        !state.corked &&\n        !state.bufferProcessing &&\n        state.buffer.length) {\n      clearBuffer(stream, state);\n    }\n\n    if (sync) {\n      process.nextTick(function() {\n        afterWrite(stream, state, finished, cb);\n      });\n    } else {\n      afterWrite(stream, state, finished, cb);\n    }\n  }\n}\n\nfunction afterWrite(stream, state, finished, cb) {\n  if (!finished)\n    onwriteDrain(stream, state);\n  state.pendingcb--;\n  cb();\n  finishMaybe(stream, state);\n}\n\n// Must force callback to be called on nextTick, so that we don't\n// emit 'drain' before the write() consumer gets the 'false' return\n// value, and has a chance to attach a 'drain' listener.\nfunction onwriteDrain(stream, state) {\n  if (state.length === 0 && state.needDrain) {\n    state.needDrain = false;\n    stream.emit('drain');\n  }\n}\n\n\n// if there's something in the buffer waiting, then process it\nfunction clearBuffer(stream, state) {\n  state.bufferProcessing = true;\n\n  if (stream._writev && state.buffer.length > 1) {\n    // Fast case, write everything using _writev()\n    var cbs = [];\n    for (var c = 0; c < state.buffer.length; c++)\n      cbs.push(state.buffer[c].callback);\n\n    // count the one we are adding, as well.\n    // TODO(isaacs) clean this up\n    state.pendingcb++;\n    doWrite(stream, state, true, state.length, state.buffer, '', function(err) {\n      for (var i = 0; i < cbs.length; i++) {\n        state.pendingcb--;\n        cbs[i](err);\n      }\n    });\n\n    // Clear buffer\n    state.buffer = [];\n  } else {\n    // Slow case, write chunks one-by-one\n    for (var c = 0; c < state.buffer.length; c++) {\n      var entry = state.buffer[c];\n      var chunk = entry.chunk;\n      var encoding = entry.encoding;\n      var cb = entry.callback;\n      var len = state.objectMode ? 1 : chunk.length;\n\n      doWrite(stream, state, false, len, chunk, encoding, cb);\n\n      // if we didn't call the onwrite immediately, then\n      // it means that we need to wait until it does.\n      // also, that means that the chunk and cb are currently\n      // being processed, so move the buffer counter past them.\n      if (state.writing) {\n        c++;\n        break;\n      }\n    }\n\n    if (c < state.buffer.length)\n      state.buffer = state.buffer.slice(c);\n    else\n      state.buffer.length = 0;\n  }\n\n  state.bufferProcessing = false;\n}\n\nWritable.prototype._write = function(chunk, encoding, cb) {\n  cb(new Error('not implemented'));\n\n};\n\nWritable.prototype._writev = null;\n\nWritable.prototype.end = function(chunk, encoding, cb) {\n  var state = this._writableState;\n\n  if (util.isFunction(chunk)) {\n    cb = chunk;\n    chunk = null;\n    encoding = null;\n  } else if (util.isFunction(encoding)) {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (!util.isNullOrUndefined(chunk))\n    this.write(chunk, encoding);\n\n  // .end() fully uncorks\n  if (state.corked) {\n    state.corked = 1;\n    this.uncork();\n  }\n\n  // ignore unnecessary end() calls.\n  if (!state.ending && !state.finished)\n    endWritable(this, state, cb);\n};\n\n\nfunction needFinish(stream, state) {\n  return (state.ending &&\n          state.length === 0 &&\n          state.buffer.length === 0 &&\n          !state.finished &&\n          !state.writing);\n}\n\nfunction prefinish(stream, state) {\n  if (!state.prefinished) {\n    state.prefinished = true;\n    stream.emit('prefinish');\n  }\n}\n\nfunction finishMaybe(stream, state) {\n  var need = needFinish(stream, state);\n  if (need) {\n    if (state.pendingcb === 0) {\n      prefinish(stream, state);\n      state.finished = true;\n      stream.emit('finish');\n    } else\n      prefinish(stream, state);\n  }\n  return need;\n}\n\nfunction endWritable(stream, state, cb) {\n  state.ending = true;\n  finishMaybe(stream, state);\n  if (cb) {\n    if (state.finished)\n      process.nextTick(cb);\n    else\n      stream.once('finish', cb);\n  }\n  state.ended = true;\n}\n",
  @"// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar util = require('util');\nvar constants = require('constants');\nvar tls = require('tls');\n\n// Lazily loaded\nvar crypto = null;\n\nvar binding = process.binding('crypto');\nvar NativeSecureContext = binding.SecureContext;\n\nfunction SecureContext(secureProtocol, flags, context) {\n  if (!(this instanceof SecureContext)) {\n    return new SecureContext(secureProtocol, flags, context);\n  }\n\n  if (context) {\n    this.context = context;\n  } else {\n    this.context = new NativeSecureContext();\n\n    if (secureProtocol) {\n      this.context.init(secureProtocol);\n    } else {\n      this.context.init();\n    }\n  }\n\n  if (flags) this.context.setOptions(flags);\n}\n\nexports.SecureContext = SecureContext;\n\n\nexports.createSecureContext = function createSecureContext(options, context) {\n  if (!options) options = {};\n\n  var secureOptions = options.secureOptions;\n  if (options.honorCipherOrder)\n    secureOptions |= constants.SSL_OP_CIPHER_SERVER_PREFERENCE;\n\n  var c = new SecureContext(options.secureProtocol, secureOptions, context);\n\n  if (context) return c;\n\n  if (options.key) {\n    if (options.passphrase) {\n      c.context.setKey(options.key, options.passphrase);\n    } else {\n      c.context.setKey(options.key);\n    }\n  }\n\n  // NOTE: It's important to add CA before the cert to be able to load\n  // cert's issuer in C++ code.\n  if (options.ca) {\n    if (util.isArray(options.ca)) {\n      for (var i = 0, len = options.ca.length; i < len; i++) {\n        c.context.addCACert(options.ca[i]);\n      }\n    } else {\n      c.context.addCACert(options.ca);\n    }\n  } else {\n    c.context.addRootCerts();\n  }\n\n  if (options.cert) c.context.setCert(options.cert);\n\n  if (options.ciphers)\n    c.context.setCiphers(options.ciphers);\n  else\n    c.context.setCiphers(tls.DEFAULT_CIPHERS);\n\n  if (util.isUndefined(options.ecdhCurve))\n    c.context.setECDHCurve(tls.DEFAULT_ECDH_CURVE);\n  else if (options.ecdhCurve)\n    c.context.setECDHCurve(options.ecdhCurve);\n\n  if (options.crl) {\n    if (util.isArray(options.crl)) {\n      for (var i = 0, len = options.crl.length; i < len; i++) {\n        c.context.addCRL(options.crl[i]);\n      }\n    } else {\n      c.context.addCRL(options.crl);\n    }\n  }\n\n  if (options.sessionIdContext) {\n    c.context.setSessionIdContext(options.sessionIdContext);\n  }\n\n  if (options.pfx) {\n    var pfx = options.pfx;\n    var passphrase = options.passphrase;\n\n    if (!crypto)\n      crypto = require('crypto');\n\n    pfx = crypto._toBuf(pfx);\n    if (passphrase)\n      passphrase = crypto._toBuf(passphrase);\n\n    if (passphrase) {\n      c.context.loadPKCS12(pfx, passphrase);\n    } else {\n      c.context.loadPKCS12(pfx);\n    }\n  }\n\n  return c;\n};\n\nexports.translatePeerCertificate = function translatePeerCertificate(c) {\n  if (!c)\n    return null;\n\n  if (c.issuer) c.issuer = tls.parseCertString(c.issuer);\n  if (c.issuerCertificate && c.issuerCertificate !== c) {\n    c.issuerCertificate = translatePeerCertificate(c.issuerCertificate);\n  }\n  if (c.subject) c.subject = tls.parseCertString(c.subject);\n  if (c.infoAccess) {\n    var info = c.infoAccess;\n    c.infoAccess = {};\n\n    // XXX: More key validation?\n    info.replace(/([^\\n:]*):([^\\n]*)(?:\\n|$)/g, function(all, key, val) {\n      if (key === '__proto__')\n        return;\n\n      if (c.infoAccess.hasOwnProperty(key))\n        c.infoAccess[key].push(val);\n      else\n        c.infoAccess[key] = [val];\n    });\n  }\n  return c;\n};\n",
  @"// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar assert = require('assert');\nvar events = require('events');\nvar stream = require('stream');\nvar tls = require('tls');\nvar util = require('util');\nvar common = require('_tls_common');\n\nvar Timer = process.binding('timer_wrap').Timer;\nvar Connection = null;\ntry {\n  Connection = process.binding('crypto').Connection;\n} catch (e) {\n  throw new Error('node.js not compiled with openssl crypto support.');\n}\n\nvar debug = util.debuglog('tls-legacy');\n\nfunction SlabBuffer() {\n  this.create();\n}\n\n\nSlabBuffer.prototype.create = function create() {\n  this.isFull = false;\n  this.pool = new Buffer(tls.SLAB_BUFFER_SIZE);\n  this.offset = 0;\n  this.remaining = this.pool.length;\n};\n\n\nSlabBuffer.prototype.use = function use(context, fn, size) {\n  if (this.remaining === 0) {\n    this.isFull = true;\n    return 0;\n  }\n\n  var actualSize = this.remaining;\n\n  if (!util.isNull(size)) actualSize = Math.min(size, actualSize);\n\n  var bytes = fn.call(context, this.pool, this.offset, actualSize);\n  if (bytes > 0) {\n    this.offset += bytes;\n    this.remaining -= bytes;\n  }\n\n  assert(this.remaining >= 0);\n\n  return bytes;\n};\n\n\nvar slabBuffer = null;\n\n\n// Base class of both CleartextStream and EncryptedStream\nfunction CryptoStream(pair, options) {\n  stream.Duplex.call(this, options);\n\n  this.pair = pair;\n  this._pending = null;\n  this._pendingEncoding = '';\n  this._pendingCallback = null;\n  this._doneFlag = false;\n  this._retryAfterPartial = false;\n  this._halfRead = false;\n  this._sslOutCb = null;\n  this._resumingSession = false;\n  this._reading = true;\n  this._destroyed = false;\n  this._ended = false;\n  this._finished = false;\n  this._opposite = null;\n\n  if (util.isNull(slabBuffer)) slabBuffer = new SlabBuffer();\n  this._buffer = slabBuffer;\n\n  this.once('finish', onCryptoStreamFinish);\n\n  // net.Socket calls .onend too\n  this.once('end', onCryptoStreamEnd);\n}\nutil.inherits(CryptoStream, stream.Duplex);\n\n\nfunction onCryptoStreamFinish() {\n  this._finished = true;\n\n  if (this === this.pair.cleartext) {\n    debug('cleartext.onfinish');\n    if (this.pair.ssl) {\n      // Generate close notify\n      // NOTE: first call checks if client has sent us shutdown,\n      // second call enqueues shutdown into the BIO.\n      if (this.pair.ssl.shutdown() !== 1) {\n        if (this.pair.ssl && this.pair.ssl.error)\n          return this.pair.error();\n\n        this.pair.ssl.shutdown();\n      }\n\n      if (this.pair.ssl && this.pair.ssl.error)\n        return this.pair.error();\n    }\n  } else {\n    debug('encrypted.onfinish');\n  }\n\n  // Try to read just to get sure that we won't miss EOF\n  if (this._opposite.readable) this._opposite.read(0);\n\n  if (this._opposite._ended) {\n    this._done();\n\n    // No half-close, sorry\n    if (this === this.pair.cleartext) this._opposite._done();\n  }\n}\n\n\nfunction onCryptoStreamEnd() {\n  this._ended = true;\n  if (this === this.pair.cleartext) {\n    debug('cleartext.onend');\n  } else {\n    debug('encrypted.onend');\n  }\n}\n\n\n// NOTE: Called once `this._opposite` is set.\nCryptoStream.prototype.init = function init() {\n  var self = this;\n  this._opposite.on('sslOutEnd', function() {\n    if (self._sslOutCb) {\n      var cb = self._sslOutCb;\n      self._sslOutCb = null;\n      cb(null);\n    }\n  });\n};\n\n\nCryptoStream.prototype._write = function write(data, encoding, cb) {\n  assert(util.isNull(this._pending));\n\n  // Black-hole data\n  if (!this.pair.ssl) return cb(null);\n\n  // When resuming session don't accept any new data.\n  // And do not put too much data into openssl, before writing it from encrypted\n  // side.\n  //\n  // TODO(indutny): Remove magic number, use watermark based limits\n  if (!this._resumingSession &&\n      this._opposite._internallyPendingBytes() < 128 * 1024) {\n    // Write current buffer now\n    var written;\n    if (this === this.pair.cleartext) {\n      debug('cleartext.write called with %d bytes', data.length);\n      written = this.pair.ssl.clearIn(data, 0, data.length);\n    } else {\n      debug('encrypted.write called with %d bytes', data.length);\n      written = this.pair.ssl.encIn(data, 0, data.length);\n    }\n\n    // Handle and report errors\n    if (this.pair.ssl && this.pair.ssl.error) {\n      return cb(this.pair.error(true));\n    }\n\n    // Force SSL_read call to cycle some states/data inside OpenSSL\n    this.pair.cleartext.read(0);\n\n    // Cycle encrypted data\n    if (this.pair.encrypted._internallyPendingBytes())\n      this.pair.encrypted.read(0);\n\n    // Get NPN and Server name when ready\n    this.pair.maybeInitFinished();\n\n    // Whole buffer was written\n    if (written === data.length) {\n      if (this === this.pair.cleartext) {\n        debug('cleartext.write succeed with ' + written + ' bytes');\n      } else {\n        debug('encrypted.write succeed with ' + written + ' bytes');\n      }\n\n      // Invoke callback only when all data read from opposite stream\n      if (this._opposite._halfRead) {\n        assert(util.isNull(this._sslOutCb));\n        this._sslOutCb = cb;\n      } else {\n        cb(null);\n      }\n      return;\n    } else if (written !== 0 && written !== -1) {\n      assert(!this._retryAfterPartial);\n      this._retryAfterPartial = true;\n      this._write(data.slice(written), encoding, cb);\n      this._retryAfterPartial = false;\n      return;\n    }\n  } else {\n    debug('cleartext.write queue is full');\n\n    // Force SSL_read call to cycle some states/data inside OpenSSL\n    this.pair.cleartext.read(0);\n  }\n\n  // No write has happened\n  this._pending = data;\n  this._pendingEncoding = encoding;\n  this._pendingCallback = cb;\n\n  if (this === this.pair.cleartext) {\n    debug('cleartext.write queued with %d bytes', data.length);\n  } else {\n    debug('encrypted.write queued with %d bytes', data.length);\n  }\n};\n\n\nCryptoStream.prototype._writePending = function writePending() {\n  var data = this._pending,\n      encoding = this._pendingEncoding,\n      cb = this._pendingCallback;\n\n  this._pending = null;\n  this._pendingEncoding = '';\n  this._pendingCallback = null;\n  this._write(data, encoding, cb);\n};\n\n\nCryptoStream.prototype._read = function read(size) {\n  // XXX: EOF?!\n  if (!this.pair.ssl) return this.push(null);\n\n  // Wait for session to be resumed\n  // Mark that we're done reading, but don't provide data or EOF\n  if (this._resumingSession || !this._reading) return this.push('');\n\n  var out;\n  if (this === this.pair.cleartext) {\n    debug('cleartext.read called with %d bytes', size);\n    out = this.pair.ssl.clearOut;\n  } else {\n    debug('encrypted.read called with %d bytes', size);\n    out = this.pair.ssl.encOut;\n  }\n\n  var bytesRead = 0,\n      start = this._buffer.offset,\n      last = start;\n  do {\n    assert(last === this._buffer.offset);\n    var read = this._buffer.use(this.pair.ssl, out, size - bytesRead);\n    if (read > 0) {\n      bytesRead += read;\n    }\n    last = this._buffer.offset;\n\n    // Handle and report errors\n    if (this.pair.ssl && this.pair.ssl.error) {\n      this.pair.error();\n      break;\n    }\n  } while (read > 0 &&\n           !this._buffer.isFull &&\n           bytesRead < size &&\n           this.pair.ssl !== null);\n\n  // Get NPN and Server name when ready\n  this.pair.maybeInitFinished();\n\n  // Create new buffer if previous was filled up\n  var pool = this._buffer.pool;\n  if (this._buffer.isFull) this._buffer.create();\n\n  assert(bytesRead >= 0);\n\n  if (this === this.pair.cleartext) {\n    debug('cleartext.read succeed with %d bytes', bytesRead);\n  } else {\n    debug('encrypted.read succeed with %d bytes', bytesRead);\n  }\n\n  // Try writing pending data\n  if (!util.isNull(this._pending)) this._writePending();\n  if (!util.isNull(this._opposite._pending)) this._opposite._writePending();\n\n  if (bytesRead === 0) {\n    // EOF when cleartext has finished and we have nothing to read\n    if (this._opposite._finished && this._internallyPendingBytes() === 0 ||\n        this.pair.ssl && this.pair.ssl.receivedShutdown) {\n      // Perform graceful shutdown\n      this._done();\n\n      // No half-open, sorry!\n      if (this === this.pair.cleartext) {\n        this._opposite._done();\n\n        // EOF\n        this.push(null);\n      } else if (!this.pair.ssl || !this.pair.ssl.receivedShutdown) {\n        // EOF\n        this.push(null);\n      }\n    } else {\n      // Bail out\n      this.push('');\n    }\n  } else {\n    // Give them requested data\n    this.push(pool.slice(start, start + bytesRead));\n  }\n\n  // Let users know that we've some internal data to read\n  var halfRead = this._internallyPendingBytes() !== 0;\n\n  // Smart check to avoid invoking 'sslOutEnd' in the most of the cases\n  if (this._halfRead !== halfRead) {\n    this._halfRead = halfRead;\n\n    // Notify listeners about internal data end\n    if (!halfRead) {\n      if (this === this.pair.cleartext) {\n        debug('cleartext.sslOutEnd');\n      } else {\n        debug('encrypted.sslOutEnd');\n      }\n\n      this.emit('sslOutEnd');\n    }\n  }\n};\n\n\nCryptoStream.prototype.setTimeout = function(timeout, callback) {\n  if (this.socket) this.socket.setTimeout(timeout, callback);\n};\n\n\nCryptoStream.prototype.setNoDelay = function(noDelay) {\n  if (this.socket) this.socket.setNoDelay(noDelay);\n};\n\n\nCryptoStream.prototype.setKeepAlive = function(enable, initialDelay) {\n  if (this.socket) this.socket.setKeepAlive(enable, initialDelay);\n};\n\nCryptoStream.prototype.__defineGetter__('bytesWritten', function() {\n  return this.socket ? this.socket.bytesWritten : 0;\n});\n\nCryptoStream.prototype.getPeerCertificate = function(detailed) {\n  if (this.pair.ssl) {\n    return common.translatePeerCertificate(\n        this.pair.ssl.getPeerCertificate(detailed));\n  }\n\n  return null;\n};\n\nCryptoStream.prototype.getSession = function() {\n  if (this.pair.ssl) {\n    return this.pair.ssl.getSession();\n  }\n\n  return null;\n};\n\nCryptoStream.prototype.isSessionReused = function() {\n  if (this.pair.ssl) {\n    return this.pair.ssl.isSessionReused();\n  }\n\n  return null;\n};\n\nCryptoStream.prototype.getCipher = function(err) {\n  if (this.pair.ssl) {\n    return this.pair.ssl.getCurrentCipher();\n  } else {\n    return null;\n  }\n};\n\n\nCryptoStream.prototype.end = function(chunk, encoding) {\n  if (this === this.pair.cleartext) {\n    debug('cleartext.end');\n  } else {\n    debug('encrypted.end');\n  }\n\n  // Write pending data first\n  if (!util.isNull(this._pending)) this._writePending();\n\n  this.writable = false;\n\n  stream.Duplex.prototype.end.call(this, chunk, encoding);\n};\n\n\nCryptoStream.prototype.destroySoon = function(err) {\n  if (this === this.pair.cleartext) {\n    debug('cleartext.destroySoon');\n  } else {\n    debug('encrypted.destroySoon');\n  }\n\n  if (this.writable)\n    this.end();\n\n  if (this._writableState.finished && this._opposite._ended) {\n    this.destroy();\n  } else {\n    // Wait for both `finish` and `end` events to ensure that all data that\n    // was written on this side was read from the other side.\n    var self = this;\n    var waiting = 1;\n    function finish() {\n      if (--waiting === 0) self.destroy();\n    }\n    this._opposite.once('end', finish);\n    if (!this._finished) {\n      this.once('finish', finish);\n      ++waiting;\n    }\n  }\n};\n\n\nCryptoStream.prototype.destroy = function(err) {\n  if (this._destroyed) return;\n  this._destroyed = true;\n  this.readable = this.writable = false;\n\n  // Destroy both ends\n  if (this === this.pair.cleartext) {\n    debug('cleartext.destroy');\n  } else {\n    debug('encrypted.destroy');\n  }\n  this._opposite.destroy();\n\n  var self = this;\n  process.nextTick(function() {\n    // Force EOF\n    self.push(null);\n\n    // Emit 'close' event\n    self.emit('close', err ? true : false);\n  });\n};\n\n\nCryptoStream.prototype._done = function() {\n  this._doneFlag = true;\n\n  if (this === this.pair.encrypted && !this.pair._secureEstablished)\n    return this.pair.error();\n\n  if (this.pair.cleartext._doneFlag &&\n      this.pair.encrypted._doneFlag &&\n      !this.pair._doneFlag) {\n    // If both streams are done:\n    this.pair.destroy();\n  }\n};\n\n\n// readyState is deprecated. Don't use it.\nObject.defineProperty(CryptoStream.prototype, 'readyState', {\n  get: function() {\n    if (this._connecting) {\n      return 'opening';\n    } else if (this.readable && this.writable) {\n      return 'open';\n    } else if (this.readable && !this.writable) {\n      return 'readOnly';\n    } else if (!this.readable && this.writable) {\n      return 'writeOnly';\n    } else {\n      return 'closed';\n    }\n  }\n});\n\n\nfunction CleartextStream(pair, options) {\n  CryptoStream.call(this, pair, options);\n\n  // This is a fake kludge to support how the http impl sits\n  // on top of net Sockets\n  var self = this;\n  this._handle = {\n    readStop: function() {\n      self._reading = false;\n    },\n    readStart: function() {\n      if (self._reading && self._readableState.length > 0) return;\n      self._reading = true;\n      self.read(0);\n      if (self._opposite.readable) self._opposite.read(0);\n    }\n  };\n}\nutil.inherits(CleartextStream, CryptoStream);\n\n\nCleartextStream.prototype._internallyPendingBytes = function() {\n  if (this.pair.ssl) {\n    return this.pair.ssl.clearPending();\n  } else {\n    return 0;\n  }\n};\n\n\nCleartextStream.prototype.address = function() {\n  return this.socket && this.socket.address();\n};\n\n\nCleartextStream.prototype.__defineGetter__('remoteAddress', function() {\n  return this.socket && this.socket.remoteAddress;\n});\n\n\nCleartextStream.prototype.__defineGetter__('remotePort', function() {\n  return this.socket && this.socket.remotePort;\n});\n\n\nCleartextStream.prototype.__defineGetter__('localAddress', function() {\n  return this.socket && this.socket.localAddress;\n});\n\n\nCleartextStream.prototype.__defineGetter__('localPort', function() {\n  return this.socket && this.socket.localPort;\n});\n\n\nfunction EncryptedStream(pair, options) {\n  CryptoStream.call(this, pair, options);\n}\nutil.inherits(EncryptedStream, CryptoStream);\n\n\nEncryptedStream.prototype._internallyPendingBytes = function() {\n  if (this.pair.ssl) {\n    return this.pair.ssl.encPending();\n  } else {\n    return 0;\n  }\n};\n\n\nfunction onhandshakestart() {\n  debug('onhandshakestart');\n\n  var self = this;\n  var ssl = self.ssl;\n  var now = Timer.now();\n\n  assert(now >= ssl.lastHandshakeTime);\n\n  if ((now - ssl.lastHandshakeTime) >= tls.CLIENT_RENEG_WINDOW * 1000) {\n    ssl.handshakes = 0;\n  }\n\n  var first = (ssl.lastHandshakeTime === 0);\n  ssl.lastHandshakeTime = now;\n  if (first) return;\n\n  if (++ssl.handshakes > tls.CLIENT_RENEG_LIMIT) {\n    // Defer the error event to the next tick. We're being called from OpenSSL's\n    // state machine and OpenSSL is not re-entrant. We cannot allow the user's\n    // callback to destroy the connection right now, it would crash and burn.\n    setImmediate(function() {\n      var err = new Error('TLS session renegotiation attack detected.');\n      if (self.cleartext) self.cleartext.emit('error', err);\n    });\n  }\n}\n\n\nfunction onhandshakedone() {\n  // for future use\n  debug('onhandshakedone');\n}\n\n\nfunction onclienthello(hello) {\n  var self = this,\n      once = false;\n\n  this._resumingSession = true;\n  function callback(err, session) {\n    if (once) return;\n    once = true;\n\n    if (err) return self.socket.destroy(err);\n\n    self.ssl.loadSession(session);\n    self.ssl.endParser();\n\n    // Cycle data\n    self._resumingSession = false;\n    self.cleartext.read(0);\n    self.encrypted.read(0);\n  }\n\n  if (hello.sessionId.length <= 0 ||\n      !this.server ||\n      !this.server.emit('resumeSession', hello.sessionId, callback)) {\n    callback(null, null);\n  }\n}\n\n\nfunction onnewsession(key, session) {\n  if (!this.server) return;\n\n  var self = this;\n  var once = false;\n\n  self.server.emit('newSession', key, session, function() {\n    if (once)\n      return;\n    once = true;\n\n    if (self.ssl)\n      self.ssl.newSessionDone();\n  });\n}\n\n\nfunction onocspresponse(resp) {\n  this.emit('OCSPResponse', resp);\n}\n\n\n\n\n\n\nfunction SecurePair(context, isServer, requestCert, rejectUnauthorized,\n                    options) {\n  if (!(this instanceof SecurePair)) {\n    return new SecurePair(context,\n                          isServer,\n                          requestCert,\n                          rejectUnauthorized,\n                          options);\n  }\n\n  var self = this;\n\n  options || (options = {});\n\n  events.EventEmitter.call(this);\n\n  this.server = options.server;\n  this._secureEstablished = false;\n  this._isServer = isServer ? true : false;\n  this._encWriteState = true;\n  this._clearWriteState = true;\n  this._doneFlag = false;\n  this._destroying = false;\n\n  if (!context) {\n    this.credentials = tls.createSecureContext();\n  } else {\n    this.credentials = context;\n  }\n\n  if (!this._isServer) {\n    // For clients, we will always have either a given ca list or be using\n    // default one\n    requestCert = true;\n  }\n\n  this._rejectUnauthorized = rejectUnauthorized ? true : false;\n  this._requestCert = requestCert ? true : false;\n\n  this.ssl = new Connection(this.credentials.context,\n                            this._isServer ? true : false,\n                            this._isServer ? this._requestCert :\n                                             options.servername,\n                            this._rejectUnauthorized);\n\n  if (this._isServer) {\n    this.ssl.onhandshakestart = onhandshakestart.bind(this);\n    this.ssl.onhandshakedone = onhandshakedone.bind(this);\n    this.ssl.onclienthello = onclienthello.bind(this);\n    this.ssl.onnewsession = onnewsession.bind(this);\n    this.ssl.lastHandshakeTime = 0;\n    this.ssl.handshakes = 0;\n  } else {\n    this.ssl.onocspresponse = onocspresponse.bind(this);\n  }\n\n  if (process.features.tls_sni) {\n    if (this._isServer && options.SNICallback) {\n      this.ssl.setSNICallback(options.SNICallback);\n    }\n    this.servername = null;\n  }\n\n  if (process.features.tls_npn && options.NPNProtocols) {\n    this.ssl.setNPNProtocols(options.NPNProtocols);\n    this.npnProtocol = null;\n  }\n\n\n  this.cleartext = new CleartextStream(this, options.cleartext);\n\n\n  this.encrypted = new EncryptedStream(this, options.encrypted);\n\n\n  this.cleartext._opposite = this.encrypted;\n  this.encrypted._opposite = this.cleartext;\n  this.cleartext.init();\n  this.encrypted.init();\n\n  process.nextTick(function() {\n\n    if (self.ssl) {\n      self.ssl.start();\n\n      if (options.requestOCSP)\n        self.ssl.requestOCSP();\n\n\n      if (self.ssl && self.ssl.error)\n        self.error();\n    }\n  });\n}\n\nutil.inherits(SecurePair, events.EventEmitter);\n\n\nexports.createSecurePair = function(context,\n                                    isServer,\n                                    requestCert,\n                                    rejectUnauthorized) {\n  var pair = new SecurePair(context,\n                            isServer,\n                            requestCert,\n                            rejectUnauthorized);\n  return pair;\n};\n\n\nSecurePair.prototype.maybeInitFinished = function() {\n  if (this.ssl && !this._secureEstablished && this.ssl.isInitFinished()) {\n    if (process.features.tls_npn) {\n      this.npnProtocol = this.ssl.getNegotiatedProtocol();\n    }\n\n    if (process.features.tls_sni) {\n      this.servername = this.ssl.getServername();\n    }\n\n    this._secureEstablished = true;\n    debug('secure established');\n    this.emit('secure');\n  }\n};\n\n\nSecurePair.prototype.destroy = function() {\n  if (this._destroying) return;\n\n  if (!this._doneFlag) {\n    debug('SecurePair.destroy');\n    this._destroying = true;\n\n    // SecurePair should be destroyed only after it's streams\n    this.cleartext.destroy();\n    this.encrypted.destroy();\n\n    this._doneFlag = true;\n    this.ssl.error = null;\n    this.ssl.close();\n    this.ssl = null;\n  }\n};\n\n\nSecurePair.prototype.error = function(returnOnly) {\n  var err = this.ssl.error;\n  this.ssl.error = null;\n\n  if (!this._secureEstablished) {\n    // Emit ECONNRESET instead of zero return\n    if (!err || err.message === 'ZERO_RETURN') {\n      var connReset = new Error('socket hang up');\n      connReset.code = 'ECONNRESET';\n      connReset.sslError = err && err.message;\n\n      err = connReset;\n    }\n    this.destroy();\n    if (!returnOnly) this.emit('error', err);\n  } else if (this._isServer &&\n             this._rejectUnauthorized &&\n             /peer did not return a certificate/.test(err.message)) {\n    // Not really an error.\n    this.destroy();\n  } else {\n    if (!returnOnly) this.cleartext.emit('error', err);\n  }\n  return err;\n};\n\n\nexports.pipe = function pipe(pair, socket) {\n  pair.encrypted.pipe(socket);\n  socket.pipe(pair.encrypted);\n\n  pair.encrypted.on('close', function() {\n    process.nextTick(function() {\n      // Encrypted should be unpiped from socket to prevent possible\n      // write after destroy.\n      pair.encrypted.unpipe(socket);\n      socket.destroySoon();\n    });\n  });\n\n  pair.fd = socket.fd;\n  var cleartext = pair.cleartext;\n  cleartext.socket = socket;\n  cleartext.encrypted = pair.encrypted;\n  cleartext.authorized = false;\n\n  // cycle the data whenever the socket drains, so that\n  // we can pull some more into it.  normally this would\n  // be handled by the fact that pipe() triggers read() calls\n  // on writable.drain, but CryptoStreams are a bit more\n  // complicated.  Since the encrypted side actually gets\n  // its data from the cleartext side, we have to give it a\n  // light kick to get in motion again.\n  socket.on('drain', function() {\n    if (pair.encrypted._pending)\n      pair.encrypted._writePending();\n    if (pair.cleartext._pending)\n      pair.cleartext._writePending();\n    pair.encrypted.read(0);\n    pair.cleartext.read(0);\n  });\n\n  function onerror(e) {\n    if (cleartext._controlReleased) {\n      cleartext.emit('error', e);\n    }\n  }\n\n  function onclose() {\n    socket.removeListener('error', onerror);\n    socket.removeListener('timeout', ontimeout);\n  }\n\n  function ontimeout() {\n    cleartext.emit('timeout');\n  }\n\n  socket.on('error', onerror);\n  socket.on('close', onclose);\n  socket.on('timeout', ontimeout);\n\n  return cleartext;\n};\n",
  @"// Copyright Joyent, Inc. and other Node contributors.\n//\n// // Emit `beforeExit` if the loop became alive either after emitting\n// event, or after running some callbacks.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar assert = require('assert');\nvar constants = require('constants');\nvar crypto = require('crypto');\nvar net = require('net');\nvar tls = require('tls');\nvar util = require('util');\nvar common = require('_tls_common');\n\nvar Timer = process.binding('timer_wrap').Timer;\nvar tls_wrap = process.binding('tls_wrap');\n\n// Lazy load\nvar tls_legacy;\n\nvar debug = util.debuglog('tls');\n\nfunction onhandshakestart() {\n  debug('onhandshakestart');\n\n  var self = this;\n  var ssl = self.ssl;\n  var now = Timer.now();\n\n  assert(now >= ssl.lastHandshakeTime);\n\n  if ((now - ssl.lastHandshakeTime) >= tls.CLIENT_RENEG_WINDOW * 1000) {\n    ssl.handshakes = 0;\n  }\n\n  var first = (ssl.lastHandshakeTime === 0);\n  ssl.lastHandshakeTime = now;\n  if (first) return;\n\n  if (++ssl.handshakes > tls.CLIENT_RENEG_LIMIT) {\n    // Defer the error event to the next tick. We're being called from OpenSSL's\n    // state machine and OpenSSL is not re-entrant. We cannot allow the user's\n    // callback to destroy the connection right now, it would crash and burn.\n    setImmediate(function() {\n      var err = new Error('TLS session renegotiation attack detected.');\n      self._tlsError(err);\n    });\n  }\n}\n\n\nfunction onhandshakedone() {\n  // for future use\n  debug('onhandshakedone');\n  this._finishInit();\n}\n\n\nfunction loadSession(self, hello, cb) {\n  var once = false;\n  function onSession(err, session) {\n    if (once)\n      return cb(new Error('TLS session callback was called 2 times'));\n    once = true;\n\n    if (err)\n      return cb(err);\n\n    // NOTE: That we have disabled OpenSSL's internal session storage in\n    // `node_crypto.cc` and hence its safe to rely on getting servername only\n    // from clienthello or this place.\n    var ret = self.ssl.loadSession(session);\n\n    cb(null, ret);\n  }\n\n  if (hello.sessionId.length <= 0 ||\n      hello.tlsTicket ||\n      self.server &&\n      !self.server.emit('resumeSession', hello.sessionId, onSession)) {\n    cb(null);\n  }\n}\n\n\nfunction loadSNI(self, servername, cb) {\n  if (!servername || !self._SNICallback)\n    return cb(null);\n\n  var once = false;\n  self._SNICallback(servername, function(err, context) {\n    if (once)\n      return cb(new Error('TLS SNI callback was called 2 times'));\n    once = true;\n\n    if (err)\n      return cb(err);\n\n    // TODO(indutny): eventually disallow raw `SecureContext`\n    if (context)\n      self.ssl.sni_context = context.context || context;\n\n    cb(null, self.ssl.sni_context);\n  });\n}\n\n\nfunction requestOCSP(self, hello, ctx, cb) {\n  if (!hello.OCSPRequest || !self.server)\n    return cb(null);\n\n  if (!ctx)\n    ctx = self.server._sharedCreds;\n  if (ctx.context)\n    ctx = ctx.context;\n\n  if (self.server.listeners('OCSPRequest').length === 0) {\n    return cb(null);\n  } else {\n    self.server.emit('OCSPRequest',\n                     ctx.getCertificate(),\n                     ctx.getIssuer(),\n                     onOCSP);\n  }\n\n  var once = false;\n  function onOCSP(err, response) {\n    if (once)\n      return cb(new Error('TLS OCSP callback was called 2 times'));\n    once = true;\n\n    if (err)\n      return cb(err);\n\n    if (response)\n      self.ssl.setOCSPResponse(response);\n    cb(null);\n  }\n}\n\n\nfunction onclienthello(hello) {\n  var self = this;\n\n  loadSession(self, hello, function(err, session) {\n    if (err)\n      return self.destroy(err);\n\n    // Servername came from SSL session\n    // NOTE: TLS Session ticket doesn't include servername information\n    //\n    // Another note, From RFC3546:\n    //\n    //   If, on the other hand, the older\n    //   session is resumed, then the server MUST ignore extensions appearing\n    //   in the client hello, and send a server hello containing no\n    //   extensions; in this case the extension functionality negotiated\n    //   during the original session initiation is applied to the resumed\n    //   session.\n    //\n    // Therefore we should account session loading when dealing with servername\n    var servername = session && session.servername || hello.servername;\n    loadSNI(self, servername, function(err, ctx) {\n      if (err)\n        return self.destroy(err);\n      requestOCSP(self, hello, ctx, function(err) {\n        if (err)\n          return self.destroy(err);\n\n        self.ssl.endParser();\n      });\n    });\n  });\n}\n\n\nfunction onnewsession(key, session) {\n  if (!this.server)\n    return;\n\n  var self = this;\n  var once = false;\n\n  this._newSessionPending = true;\n  this.server.emit('newSession', key, session, function() {\n    if (once)\n      return;\n    once = true;\n\n    self.ssl.newSessionDone();\n\n    self._newSessionPending = false;\n    if (self._securePending)\n      self._finishInit();\n    self._securePending = false;\n  });\n}\n\n\nfunction onocspresponse(resp) {\n  this.emit('OCSPResponse', resp);\n}\n\n\n\n\n\n\nfunction TLSSocket(socket, options) {\n  // Disallow wrapping TLSSocket in TLSSocket\n  assert(!(socket instanceof TLSSocket));\n\n  net.Socket.call(this, {\n    handle: socket && socket._handle,\n    allowHalfOpen: socket && socket.allowHalfOpen,\n    readable: false,\n    writable: false\n  });\n\n  // To prevent assertion in afterConnect()\n  if (socket)\n    this._connecting = socket._connecting;\n\n  this._tlsOptions = options;\n  this._secureEstablished = false;\n  this._securePending = false;\n  this._newSessionPending = false;\n  this._controlReleased = false;\n  this._SNICallback = null;\n  this.ssl = null;\n  this.servername = null;\n  this.npnProtocol = null;\n  this.authorized = false;\n  this.authorizationError = null;\n\n  // Just a documented property to make secure sockets\n  // distinguishable from regular ones.\n  this.encrypted = true;\n\n  this.on('error', this._tlsError);\n\n  if (!this._handle) {\n    this.once('connect', function() {\n      this._init(null);\n    });\n  } else {\n    this._init(socket);\n  }\n\n  // Make sure to setup all required properties like: `_connecting` before\n  // starting the flow of the data\n  this.readable = true;\n  this.writable = true;\n  this.read(0);\n}\nutil.inherits(TLSSocket, net.Socket);\nexports.TLSSocket = TLSSocket;\n\nTLSSocket.prototype._init = function(socket) {\n  assert(this._handle);\n\n  // lib/net.js expect this value to be non-zero if write hasn't been flushed\n  // immediately\n  // TODO(indutny): rewise this solution, it might be 1 before handshake and\n  // represent real writeQueueSize during regular writes.\n  this._handle.writeQueueSize = 1;\n\n  var self = this;\n  var options = this._tlsOptions;\n\n  // Wrap socket's handle\n  var context = options.secureContext ||\n                options.credentials ||\n                tls.createSecureContext();\n  this.ssl = tls_wrap.wrap(this._handle, context.context, options.isServer);\n  this.server = options.server || null;\n\n  // For clients, we will always have either a given ca list or be using\n  // default one\n  var requestCert = !!options.requestCert || !options.isServer,\n      rejectUnauthorized = !!options.rejectUnauthorized;\n\n  this._requestCert = requestCert;\n  this._rejectUnauthorized = rejectUnauthorized;\n  if (requestCert || rejectUnauthorized)\n    this.ssl.setVerifyMode(requestCert, rejectUnauthorized);\n\n  if (options.isServer) {\n    this.ssl.onhandshakestart = onhandshakestart.bind(this);\n    this.ssl.onhandshakedone = onhandshakedone.bind(this);\n    this.ssl.onclienthello = onclienthello.bind(this);\n    this.ssl.onnewsession = onnewsession.bind(this);\n    this.ssl.lastHandshakeTime = 0;\n    this.ssl.handshakes = 0;\n\n    if (this.server &&\n        (this.server.listeners('resumeSession').length > 0 ||\n         this.server.listeners('newSession').length > 0 ||\n         this.server.listeners('OCSPRequest').length > 0)) {\n      this.ssl.enableSessionCallbacks();\n    }\n  } else {\n    this.ssl.onhandshakestart = function() {};\n    this.ssl.onhandshakedone = this._finishInit.bind(this);\n    this.ssl.onocspresponse = onocspresponse.bind(this);\n\n    if (options.session)\n      this.ssl.setSession(options.session);\n  }\n\n  this.ssl.onerror = function(err) {\n    if (self._writableState.errorEmitted)\n      return;\n    self._writableState.errorEmitted = true;\n\n    // Destroy socket if error happened before handshake's finish\n    if (!this._secureEstablished) {\n      self._tlsError(err);\n      self.destroy();\n    } else if (options.isServer &&\n               rejectUnauthorized &&\n               /peer did not return a certificate/.test(err.message)) {\n      // Ignore server's authorization errors\n      self.destroy();\n    } else {\n      // Throw error\n      self._tlsError(err);\n    }\n  };\n\n  // If custom SNICallback was given, or if\n  // there're SNI contexts to perform match against -\n  // set `.onsniselect` callback.\n  if (process.features.tls_sni &&\n      options.isServer &&\n      options.server &&\n      (options.SNICallback !== SNICallback ||\n       options.server._contexts.length)) {\n    assert(typeof options.SNICallback === 'function');\n    this._SNICallback = options.SNICallback;\n    this.ssl.enableHelloParser();\n  }\n\n  if (process.features.tls_npn && options.NPNProtocols)\n    this.ssl.setNPNProtocols(options.NPNProtocols);\n\n  if (options.handshakeTimeout > 0)\n    this.setTimeout(options.handshakeTimeout, this._handleTimeout);\n\n  // Socket already has some buffered data - emulate receiving it\n  if (socket && socket._readableState.length) {\n    var buf;\n    while ((buf = socket.read()) !== null)\n      this.ssl.receive(buf);\n  }\n};\n\nTLSSocket.prototype.renegotiate = function(options, callback) {\n  var requestCert = this._requestCert,\n      rejectUnauthorized = this._rejectUnauthorized;\n\n  if (typeof options.requestCert !== 'undefined')\n    requestCert = !!options.requestCert;\n  if (typeof options.rejectUnauthorized !== 'undefined')\n    rejectUnauthorized = !!options.rejectUnauthorized;\n\n  if (requestCert !== this._requestCert ||\n      rejectUnauthorized !== this._rejectUnauthorized) {\n    this.ssl.setVerifyMode(requestCert, rejectUnauthorized);\n    this._requestCert = requestCert;\n    this._rejectUnauthorized = rejectUnauthorized;\n  }\n  if (!this.ssl.renegotiate()) {\n    if (callback) {\n      process.nextTick(function() {\n        callback(new Error('Failed to renegotiate'));\n      });\n    }\n    return false;\n  }\n\n  // Ensure that we'll cycle through internal openssl's state\n  this.write('');\n\n  if (callback) {\n    this.once('secure', function() {\n      callback(null);\n    });\n  }\n\n  return true;\n};\n\nTLSSocket.prototype.setMaxSendFragment = function setMaxSendFragment(size) {\n  return this.ssl.setMaxSendFragment(size) == 1;\n};\n\nTLSSocket.prototype.getTLSTicket = function getTLSTicket() {\n  return this.ssl.getTLSTicket();\n};\n\nTLSSocket.prototype._handleTimeout = function() {\n  this._tlsError(new Error('TLS handshake timeout'));\n};\n\nTLSSocket.prototype._tlsError = function(err) {\n  this.emit('_tlsError', err);\n  if (this._controlReleased)\n    this.emit('error', err);\n};\n\nTLSSocket.prototype._releaseControl = function() {\n  if (this._controlReleased)\n    return false;\n  this._controlReleased = true;\n  this.removeListener('error', this._tlsError);\n  return true;\n};\n\nTLSSocket.prototype._finishInit = function() {\n  // `newSession` callback wasn't called yet\n  if (this._newSessionPending) {\n    this._securePending = true;\n    return;\n  }\n\n  if (process.features.tls_npn) {\n    this.npnProtocol = this.ssl.getNegotiatedProtocol();\n  }\n\n  if (process.features.tls_sni && this._tlsOptions.isServer) {\n    this.servername = this.ssl.getServername();\n  }\n\n  debug('secure established');\n  this._secureEstablished = true;\n  if (this._tlsOptions.handshakeTimeout > 0)\n    this.setTimeout(0, this._handleTimeout);\n  this.emit('secure');\n};\n\nTLSSocket.prototype._start = function() {\n  if (this._tlsOptions.requestOCSP)\n    this.ssl.requestOCSP();\n  this.ssl.start();\n};\n\nTLSSocket.prototype.setServername = function(name) {\n  this.ssl.setServername(name);\n};\n\nTLSSocket.prototype.setSession = function(session) {\n  if (util.isString(session))\n    session = new Buffer(session, 'binary');\n  this.ssl.setSession(session);\n};\n\nTLSSocket.prototype.getPeerCertificate = function(detailed) {\n  if (this.ssl) {\n    return common.translatePeerCertificate(\n        this.ssl.getPeerCertificate(detailed));\n  }\n\n  return null;\n};\n\nTLSSocket.prototype.getSession = function() {\n  if (this.ssl) {\n    return this.ssl.getSession();\n  }\n\n  return null;\n};\n\nTLSSocket.prototype.isSessionReused = function() {\n  if (this.ssl) {\n    return this.ssl.isSessionReused();\n  }\n\n  return null;\n};\n\nTLSSocket.prototype.getCipher = function(err) {\n  if (this.ssl) {\n    return this.ssl.getCurrentCipher();\n  } else {\n    return null;\n  }\n};\n\n// TODO: support anonymous (nocert) and PSK\n\n\n// AUTHENTICATION MODES\n//\n// There are several levels of authentication that TLS/SSL supports.\n// Read more about this in \"man SSL_set_verify\".\n//\n// 1. The server sends a certificate to the client but does not request a\n// cert from the client. This is common for most HTTPS servers. The browser\n// can verify the identity of the server, but the server does not know who\n// the client is. Authenticating the client is usually done over HTTP using\n// login boxes and cookies and stuff.\n//\n// 2. The server sends a cert to the client and requests that the client\n// also send it a cert. The client knows who the server is and the server is\n// requesting the client also identify themselves. There are several\n// outcomes:\n//\n//   A) verifyError returns null meaning the client's certificate is signed\n//   by one of the server's CAs. The server know's the client idenity now\n//   and the client is authorized.\n//\n//   B) For some reason the client's certificate is not acceptable -\n//   verifyError returns a string indicating the problem. The server can\n//   either (i) reject the client or (ii) allow the client to connect as an\n//   unauthorized connection.\n//\n// The mode is controlled by two boolean variables.\n//\n// requestCert\n//   If true the server requests a certificate from client connections. For\n//   the common HTTPS case, users will want this to be false, which is what\n//   it defaults to.\n//\n// rejectUnauthorized\n//   If true clients whose certificates are invalid for any reason will not\n//   be allowed to make connections. If false, they will simply be marked as\n//   unauthorized but secure communication will continue. By default this is\n//   true.\n//\n//\n//\n// Options:\n// - requestCert. Send verify request. Default to false.\n// - rejectUnauthorized. Boolean, default to true.\n// - key. string.\n// - cert: string.\n// - ca: string or array of strings.\n// - sessionTimeout: integer.\n//\n// emit 'secureConnection'\n//   function (tlsSocket) { }\n//\n//   \"UNABLE_TO_GET_ISSUER_CERT\", \"UNABLE_TO_GET_CRL\",\n//   \"UNABLE_TO_DECRYPT_CERT_SIGNATURE\", \"UNABLE_TO_DECRYPT_CRL_SIGNATURE\",\n//   \"UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY\", \"CERT_SIGNATURE_FAILURE\",\n//   \"CRL_SIGNATURE_FAILURE\", \"CERT_NOT_YET_VALID\" \"CERT_HAS_EXPIRED\",\n//   \"CRL_NOT_YET_VALID\", \"CRL_HAS_EXPIRED\" \"ERROR_IN_CERT_NOT_BEFORE_FIELD\",\n//   \"ERROR_IN_CERT_NOT_AFTER_FIELD\", \"ERROR_IN_CRL_LAST_UPDATE_FIELD\",\n//   \"ERROR_IN_CRL_NEXT_UPDATE_FIELD\", \"OUT_OF_MEM\",\n//   \"DEPTH_ZERO_SELF_SIGNED_CERT\", \"SELF_SIGNED_CERT_IN_CHAIN\",\n//   \"UNABLE_TO_GET_ISSUER_CERT_LOCALLY\", \"UNABLE_TO_VERIFY_LEAF_SIGNATURE\",\n//   \"CERT_CHAIN_TOO_LONG\", \"CERT_REVOKED\" \"INVALID_CA\",\n//   \"PATH_LENGTH_EXCEEDED\", \"INVALID_PURPOSE\" \"CERT_UNTRUSTED\",\n//   \"CERT_REJECTED\"\n//\nfunction Server() {\n  var options, listener;\n  if (util.isObject(arguments[0])) {\n    options = arguments[0];\n    listener = arguments[1];\n  } else if (util.isFunction(arguments[0])) {\n    options = {};\n    listener = arguments[0];\n  }\n\n  if (!(this instanceof Server)) return new Server(options, listener);\n\n  this._contexts = [];\n\n  var self = this;\n\n  // Handle option defaults:\n  this.setOptions(options);\n\n  var sharedCreds = tls.createSecureContext({\n    pfx: self.pfx,\n    key: self.key,\n    passphrase: self.passphrase,\n    cert: self.cert,\n    ca: self.ca,\n    ciphers: self.ciphers,\n    ecdhCurve: self.ecdhCurve,\n    secureProtocol: self.secureProtocol,\n    secureOptions: self.secureOptions,\n    honorCipherOrder: self.honorCipherOrder,\n    crl: self.crl,\n    sessionIdContext: self.sessionIdContext\n  });\n  this._sharedCreds = sharedCreds;\n\n  var timeout = options.handshakeTimeout || (120 * 1000);\n\n  if (!util.isNumber(timeout)) {\n    throw new TypeError('handshakeTimeout must be a number');\n  }\n\n  if (self.sessionTimeout) {\n    sharedCreds.context.setSessionTimeout(self.sessionTimeout);\n  }\n\n  if (self.ticketKeys) {\n    sharedCreds.context.setTicketKeys(self.ticketKeys);\n  }\n\n  // constructor call\n  net.Server.call(this, function(raw_socket) {\n    var socket = new TLSSocket(raw_socket, {\n      secureContext: sharedCreds,\n      isServer: true,\n      server: self,\n      requestCert: self.requestCert,\n      rejectUnauthorized: self.rejectUnauthorized,\n      handshakeTimeout: timeout,\n      NPNProtocols: self.NPNProtocols,\n      SNICallback: options.SNICallback || SNICallback\n    });\n\n    socket.on('secure', function() {\n      if (socket._requestCert) {\n        var verifyError = socket.ssl.verifyError();\n        if (verifyError) {\n          socket.authorizationError = verifyError.code;\n\n          if (socket._rejectUnauthorized)\n            socket.destroy();\n        } else {\n          socket.authorized = true;\n        }\n      }\n\n      if (!socket.destroyed && socket._releaseControl())\n        self.emit('secureConnection', socket);\n    });\n\n    var errorEmitted = false;\n    socket.on('close', function() {\n      // Emit ECONNRESET\n      if (!socket._controlReleased && !errorEmitted) {\n        errorEmitted = true;\n        var connReset = new Error('socket hang up');\n        connReset.code = 'ECONNRESET';\n        self.emit('clientError', connReset, socket);\n      }\n    });\n\n    socket.on('_tlsError', function(err) {\n      if (!socket._controlReleased && !errorEmitted) {\n        errorEmitted = true;\n        self.emit('clientError', err, socket);\n      }\n    });\n  });\n\n  if (listener) {\n    this.on('secureConnection', listener);\n  }\n}\n\nutil.inherits(Server, net.Server);\nexports.Server = Server;\nexports.createServer = function(options, listener) {\n  return new Server(options, listener);\n};\n\n\nServer.prototype._getServerData = function() {\n  return {\n    ticketKeys: this._sharedCreds.context.getTicketKeys().toString('hex')\n  };\n};\n\n\nServer.prototype._setServerData = function(data) {\n  this._sharedCreds.context.setTicketKeys(new Buffer(data.ticketKeys, 'hex'));\n};\n\n\nServer.prototype.setOptions = function(options) {\n  if (util.isBoolean(options.requestCert)) {\n    this.requestCert = options.requestCert;\n  } else {\n    this.requestCert = false;\n  }\n\n  if (util.isBoolean(options.rejectUnauthorized)) {\n    this.rejectUnauthorized = options.rejectUnauthorized;\n  } else {\n    this.rejectUnauthorized = false;\n  }\n\n  if (options.pfx) this.pfx = options.pfx;\n  if (options.key) this.key = options.key;\n  if (options.passphrase) this.passphrase = options.passphrase;\n  if (options.cert) this.cert = options.cert;\n  if (options.ca) this.ca = options.ca;\n  if (options.secureProtocol) this.secureProtocol = options.secureProtocol;\n  if (options.crl) this.crl = options.crl;\n  if (options.ciphers) this.ciphers = options.ciphers;\n  if (!util.isUndefined(options.ecdhCurve))\n    this.ecdhCurve = options.ecdhCurve;\n  if (options.sessionTimeout) this.sessionTimeout = options.sessionTimeout;\n  if (options.ticketKeys) this.ticketKeys = options.ticketKeys;\n  var secureOptions = options.secureOptions || 0;\n  if (options.honorCipherOrder)\n    this.honorCipherOrder = true;\n  else\n    this.honorCipherOrder = false;\n  if (secureOptions) this.secureOptions = secureOptions;\n  if (options.NPNProtocols) tls.convertNPNProtocols(options.NPNProtocols, this);\n  if (options.sessionIdContext) {\n    this.sessionIdContext = options.sessionIdContext;\n  } else {\n    this.sessionIdContext = crypto.createHash('md5')\n                                  .update(process.argv.join(' '))\n                                  .digest('hex');\n  }\n};\n\n// SNI Contexts High-Level API\nServer.prototype.addContext = function(servername, context) {\n  if (!servername) {\n    throw 'Servername is required parameter for Server.addContext';\n  }\n\n  var re = new RegExp('^' +\n                      servername.replace(/([\\.^$+?\\-\\\\[\\]{}])/g, '\\\\$1')\n                                .replace(/\\*/g, '[^\\.]*') +\n                      '$');\n  this._contexts.push([re, tls.createSecureContext(context).context]);\n};\n\nfunction SNICallback(servername, callback) {\n  var ctx;\n\n  this.server._contexts.some(function(elem) {\n    if (!util.isNull(servername.match(elem[0]))) {\n      ctx = elem[1];\n      return true;\n    }\n  });\n\n  callback(null, ctx);\n}\n\n\n// Target API:\n//\n//  var s = tls.connect({port: 8000, host: \"google.com\"}, function() {\n//    if (!s.authorized) {\n//      s.destroy();\n//      return;\n//    }\n//\n//    // s.socket;\n//\n//    s.end(\"hello world\\n\");\n//  });\n//\n//\nfunction normalizeConnectArgs(listArgs) {\n  var args = net._normalizeConnectArgs(listArgs);\n  var options = args[0];\n  var cb = args[1];\n\n  if (util.isObject(listArgs[1])) {\n    options = util._extend(options, listArgs[1]);\n  } else if (util.isObject(listArgs[2])) {\n    options = util._extend(options, listArgs[2]);\n  }\n\n  return (cb) ? [options, cb] : [options];\n}\n\nfunction legacyConnect(hostname, options, NPN, context) {\n  assert(options.socket);\n  if (!tls_legacy)\n    tls_legacy = require('_tls_legacy');\n\n  var pair = tls_legacy.createSecurePair(context,\n                                         false,\n                                         true,\n                                         !!options.rejectUnauthorized,\n                                         {\n                                           NPNProtocols: NPN.NPNProtocols,\n                                           servername: hostname\n                                         });\n  tls_legacy.pipe(pair, options.socket);\n  pair.cleartext._controlReleased = true;\n  pair.on('error', function(err) {\n    pair.cleartext.emit('error', err);\n  });\n\n  return pair;\n}\n\nexports.connect = function() {\n  var args = normalizeConnectArgs(arguments);\n  var options = args[0];\n  var cb = args[1];\n\n  var defaults = {\n    rejectUnauthorized: '0' !== process.env.NODE_TLS_REJECT_UNAUTHORIZED,\n    ciphers: tls.DEFAULT_CIPHERS\n  };\n  options = util._extend(defaults, options || {});\n\n  var hostname = options.servername ||\n                 options.host ||\n                 options.socket && options.socket._host,\n      NPN = {},\n      context = tls.createSecureContext(options);\n  tls.convertNPNProtocols(options.NPNProtocols, NPN);\n\n  // Wrapping TLS socket inside another TLS socket was requested -\n  // create legacy secure pair\n  var socket;\n  var legacy;\n  var result;\n  if (options.socket instanceof TLSSocket) {\n    debug('legacy connect');\n    legacy = true;\n    socket = legacyConnect(hostname, options, NPN, context);\n    result = socket.cleartext;\n  } else {\n    legacy = false;\n    socket = new TLSSocket(options.socket, {\n      secureContext: context,\n      isServer: false,\n      requestCert: true,\n      rejectUnauthorized: options.rejectUnauthorized,\n      session: options.session,\n      NPNProtocols: NPN.NPNProtocols,\n      requestOCSP: options.requestOCSP\n    });\n    result = socket;\n  }\n\n  if (socket._handle && !socket._connecting) {\n    onHandle();\n  } else {\n    // Not even started connecting yet (or probably resolving dns address),\n    // catch socket errors and assign handle.\n    if (!legacy && options.socket) {\n      options.socket.once('connect', function() {\n        assert(options.socket._handle);\n        socket._handle = options.socket._handle;\n        socket._handle.owner = socket;\n        socket.emit('connect');\n      });\n    }\n    socket.once('connect', onHandle);\n  }\n\n  if (cb)\n    result.once('secureConnect', cb);\n\n  if (!options.socket) {\n    assert(!legacy);\n    var connect_opt;\n    if (options.path && !options.port) {\n      connect_opt = { path: options.path };\n    } else {\n      connect_opt = {\n        port: options.port,\n        host: options.host,\n        localAddress: options.localAddress\n      };\n    }\n    socket.connect(connect_opt);\n  }\n\n  return result;\n\n  function onHandle() {\n    if (!legacy)\n      socket._releaseControl();\n\n    if (options.session)\n      socket.setSession(options.session);\n\n    if (!legacy) {\n      if (options.servername)\n        socket.setServername(options.servername);\n\n      socket._start();\n    }\n    socket.on('secure', function() {\n      var verifyError = socket.ssl.verifyError();\n\n      // Verify that server's identity matches it's certificate's names\n      if (!verifyError) {\n        var cert = result.getPeerCertificate();\n        verifyError = tls.checkServerIdentity(hostname, cert);\n      }\n\n      if (verifyError) {\n        result.authorized = false;\n        result.authorizationError = verifyError.code || verifyError.message;\n\n        if (options.rejectUnauthorized) {\n          result.emit('error', verifyError);\n          result.destroy();\n          return;\n        } else {\n          result.emit('secureConnect');\n        }\n      } else {\n        result.authorized = true;\n        result.emit('secureConnect');\n      }\n\n      // Uncork incoming data\n      result.removeListener('end', onHangUp);\n    });\n\n    function onHangUp() {\n      // NOTE: This logic is shared with _http_client.js\n      if (!socket._hadError) {\n        socket._hadError = true;\n        var error = new Error('socket hang up');\n        error.code = 'ECONNRESET';\n        socket.destroy();\n        socket.emit('error', error);\n      }\n    }\n    result.once('end', onHangUp);\n  }\n};\n",
  @"// http://wiki.commonjs.org/wiki/Unit_Testing/1.0\n//\n// THIS IS NOT TESTED NOR LIKELY TO WORK OUTSIDE V8!\n//\n// Originally from narwhal.js (http://narwhaljs.org)\n// Copyright (c) 2009 Thomas Robinson <280north.com>\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the 'Software'), to\n// deal in the Software without restriction, including without limitation the\n// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n// sell copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// UTILITY\nvar util = require('util');\nvar pSlice = Array.prototype.slice;\n\n// 1. The assert module provides functions that throw\n// AssertionError's when particular conditions are not met. The\n// assert module must conform to the following interface.\n\nvar assert = module.exports = ok;\n\n// 2. The AssertionError is defined in assert.\n// new assert.AssertionError({ message: message,\n//                             actual: actual,\n//                             expected: expected })\n\nassert.AssertionError = function AssertionError(options) {\n  this.name = 'AssertionError';\n  this.actual = options.actual;\n  this.expected = options.expected;\n  this.operator = options.operator;\n  if (options.message) {\n    this.message = options.message;\n    this.generatedMessage = false;\n  } else {\n    this.message = getMessage(this);\n    this.generatedMessage = true;\n  }\n  var stackStartFunction = options.stackStartFunction || fail;\n  Error.captureStackTrace(this, stackStartFunction);\n};\n\n// assert.AssertionError instanceof Error\nutil.inherits(assert.AssertionError, Error);\n\nfunction replacer(key, value) {\n  if (util.isUndefined(value)) {\n    return '' + value;\n  }\n  if (util.isNumber(value) && (isNaN(value) || !isFinite(value))) {\n    return value.toString();\n  }\n  if (util.isFunction(value) || util.isRegExp(value)) {\n    return value.toString();\n  }\n  return value;\n}\n\nfunction truncate(s, n) {\n  if (util.isString(s)) {\n    return s.length < n ? s : s.slice(0, n);\n  } else {\n    return s;\n  }\n}\n\nfunction getMessage(self) {\n  return truncate(JSON.stringify(self.actual, replacer), 128) + ' ' +\n         self.operator + ' ' +\n         truncate(JSON.stringify(self.expected, replacer), 128);\n}\n\n// At present only the three keys mentioned above are used and\n// understood by the spec. Implementations or sub modules can pass\n// other keys to the AssertionError's constructor - they will be\n// ignored.\n\n// 3. All of the following functions must throw an AssertionError\n// when a corresponding condition is not met, with a message that\n// may be undefined if not provided.  All assertion methods provide\n// both the actual and expected values to the assertion error for\n// display purposes.\n\nfunction fail(actual, expected, message, operator, stackStartFunction) {\n  throw new assert.AssertionError({\n    message: message,\n    actual: actual,\n    expected: expected,\n    operator: operator,\n    stackStartFunction: stackStartFunction\n  });\n}\n\n// EXTENSION! allows for well behaved errors defined elsewhere.\nassert.fail = fail;\n\n// 4. Pure assertion tests whether a value is truthy, as determined\n// by !!guard.\n// assert.ok(guard, message_opt);\n// This statement is equivalent to assert.equal(true, !!guard,\n// message_opt);. To test strictly for the value true, use\n// assert.strictEqual(true, guard, message_opt);.\n\nfunction ok(value, message) {\n  if (!value) fail(value, true, message, '==', assert.ok);\n}\nassert.ok = ok;\n\n// 5. The equality assertion tests shallow, coercive equality with\n// ==.\n// assert.equal(actual, expected, message_opt);\n\nassert.equal = function equal(actual, expected, message) {\n  if (actual != expected) fail(actual, expected, message, '==', assert.equal);\n};\n\n// 6. The non-equality assertion tests for whether two objects are not equal\n// with != assert.notEqual(actual, expected, message_opt);\n\nassert.notEqual = function notEqual(actual, expected, message) {\n  if (actual == expected) {\n    fail(actual, expected, message, '!=', assert.notEqual);\n  }\n};\n\n// 7. The equivalence assertion tests a deep equality relation.\n// assert.deepEqual(actual, expected, message_opt);\n\nassert.deepEqual = function deepEqual(actual, expected, message) {\n  if (!_deepEqual(actual, expected)) {\n    fail(actual, expected, message, 'deepEqual', assert.deepEqual);\n  }\n};\n\nfunction _deepEqual(actual, expected) {\n  // 7.1. All identical values are equivalent, as determined by ===.\n  if (actual === expected) {\n    return true;\n\n  } else if (util.isBuffer(actual) && util.isBuffer(expected)) {\n    if (actual.length != expected.length) return false;\n\n    for (var i = 0; i < actual.length; i++) {\n      if (actual[i] !== expected[i]) return false;\n    }\n\n    return true;\n\n  // 7.2. If the expected value is a Date object, the actual value is\n  // equivalent if it is also a Date object that refers to the same time.\n  } else if (util.isDate(actual) && util.isDate(expected)) {\n    return actual.getTime() === expected.getTime();\n\n  // 7.3 If the expected value is a RegExp object, the actual value is\n  // equivalent if it is also a RegExp object with the same source and\n  // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).\n  } else if (util.isRegExp(actual) && util.isRegExp(expected)) {\n    return actual.source === expected.source &&\n           actual.global === expected.global &&\n           actual.multiline === expected.multiline &&\n           actual.lastIndex === expected.lastIndex &&\n           actual.ignoreCase === expected.ignoreCase;\n\n  // 7.4. Other pairs that do not both pass typeof value == 'object',\n  // equivalence is determined by ==.\n  } else if (!util.isObject(actual) && !util.isObject(expected)) {\n    return actual == expected;\n\n  // 7.5 For all other Object pairs, including Array objects, equivalence is\n  // determined by having the same number of owned properties (as verified\n  // with Object.prototype.hasOwnProperty.call), the same set of keys\n  // (although not necessarily the same order), equivalent values for every\n  // corresponding key, and an identical 'prototype' property. Note: this\n  // accounts for both named and indexed properties on Arrays.\n  } else {\n    return objEquiv(actual, expected);\n  }\n}\n\nfunction isArguments(object) {\n  return Object.prototype.toString.call(object) == '[object Arguments]';\n}\n\nfunction objEquiv(a, b) {\n  if (util.isNullOrUndefined(a) || util.isNullOrUndefined(b))\n    return false;\n  // an identical 'prototype' property.\n  if (a.prototype !== b.prototype) return false;\n  //~~~I've managed to break Object.keys through screwy arguments passing.\n  //   Converting to array solves the problem.\n  var aIsArgs = isArguments(a),\n      bIsArgs = isArguments(b);\n  if ((aIsArgs && !bIsArgs) || (!aIsArgs && bIsArgs))\n    return false;\n  if (aIsArgs) {\n    a = pSlice.call(a);\n    b = pSlice.call(b);\n    return _deepEqual(a, b);\n  }\n  try {\n    var ka = Object.keys(a),\n        kb = Object.keys(b),\n        key, i;\n  } catch (e) {//happens when one is a string literal and the other isn't\n    return false;\n  }\n  // having the same number of owned properties (keys incorporates\n  // hasOwnProperty)\n  if (ka.length != kb.length)\n    return false;\n  //the same set of keys (although not necessarily the same order),\n  ka.sort();\n  kb.sort();\n  //~~~cheap key test\n  for (i = ka.length - 1; i >= 0; i--) {\n    if (ka[i] != kb[i])\n      return false;\n  }\n  //equivalent values for every corresponding key, and\n  //~~~possibly expensive deep test\n  for (i = ka.length - 1; i >= 0; i--) {\n    key = ka[i];\n    if (!_deepEqual(a[key], b[key])) return false;\n  }\n  return true;\n}\n\n// 8. The non-equivalence assertion tests for any deep inequality.\n// assert.notDeepEqual(actual, expected, message_opt);\n\nassert.notDeepEqual = function notDeepEqual(actual, expected, message) {\n  if (_deepEqual(actual, expected)) {\n    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);\n  }\n};\n\n// 9. The strict equality assertion tests strict equality, as determined by ===.\n// assert.strictEqual(actual, expected, message_opt);\n\nassert.strictEqual = function strictEqual(actual, expected, message) {\n  if (actual !== expected) {\n    fail(actual, expected, message, '===', assert.strictEqual);\n  }\n};\n\n// 10. The strict non-equality assertion tests for strict inequality, as\n// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);\n\nassert.notStrictEqual = function notStrictEqual(actual, expected, message) {\n  if (actual === expected) {\n    fail(actual, expected, message, '!==', assert.notStrictEqual);\n  }\n};\n\nfunction expectedException(actual, expected) {\n  if (!actual || !expected) {\n    return false;\n  }\n\n  if (Object.prototype.toString.call(expected) == '[object RegExp]') {\n    return expected.test(actual);\n  } else if (actual instanceof expected) {\n    return true;\n  } else if (expected.call({}, actual) === true) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction _throws(shouldThrow, block, expected, message) {\n  var actual;\n\n  if (util.isString(expected)) {\n    message = expected;\n    expected = null;\n  }\n\n  try {\n    block();\n  } catch (e) {\n    actual = e;\n  }\n\n  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +\n            (message ? ' ' + message : '.');\n\n  if (shouldThrow && !actual) {\n    fail(actual, expected, 'Missing expected exception' + message);\n  }\n\n  if (!shouldThrow && expectedException(actual, expected)) {\n    fail(actual, expected, 'Got unwanted exception' + message);\n  }\n\n  if ((shouldThrow && actual && expected &&\n      !expectedException(actual, expected)) || (!shouldThrow && actual)) {\n    throw actual;\n  }\n}\n\n// 11. Expected to throw an error:\n// assert.throws(block, Error_opt, message_opt);\n\nassert.throws = function(block, error, message) {\n  _throws.apply(this, [true].concat(pSlice.call(arguments)));\n};\n\n// EXTENSION! This is annoying to write outside this module.\nassert.doesNotThrow = function(block, message) {\n  _throws.apply(this, [false].concat(pSlice.call(arguments)));\n};\n\nassert.ifError = function(err) { if (err) {throw err;}};\n",
  @"// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar buffer = process.binding('buffer');\nvar smalloc = process.binding('smalloc');\nvar util = require('util');\nvar alloc = smalloc.alloc;\nvar truncate = smalloc.truncate;\nvar sliceOnto = smalloc.sliceOnto;\nvar kMaxLength = smalloc.kMaxLength;\nvar internal = {};\n\nexports.Buffer = Buffer;\nexports.SlowBuffer = SlowBuffer;\nexports.INSPECT_MAX_BYTES = 50;\n\n\nBuffer.poolSize = 8 * 1024;\nvar poolSize, poolOffset, allocPool;\n\n\nfunction createPool() {\n  poolSize = Buffer.poolSize;\n  allocPool = alloc({}, poolSize);\n  poolOffset = 0;\n}\ncreatePool();\n\n\nfunction Buffer(subject, encoding) {\n  if (!util.isBuffer(this))\n    return new Buffer(subject, encoding);\n\n  if (util.isNumber(subject))\n    this.length = subject > 0 ? subject >>> 0 : 0;\n  else if (util.isString(subject))\n    this.length = Buffer.byteLength(subject, encoding = encoding || 'utf8');\n  else if (util.isObject(subject)) {\n    if (subject.type === 'Buffer' && util.isArray(subject.data))\n      subject = subject.data;\n\n    this.length = +subject.length > 0 ? Math.floor(+subject.length) : 0;\n  } else\n    throw new TypeError('must start with number, buffer, array or string');\n\n  if (this.length > kMaxLength) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + kMaxLength.toString(16) + ' bytes');\n  }\n\n  if (this.length <= (Buffer.poolSize >>> 1) && this.length > 0) {\n    if (this.length > poolSize - poolOffset)\n      createPool();\n    this.parent = sliceOnto(allocPool,\n                            this,\n                            poolOffset,\n                            poolOffset + this.length);\n    poolOffset += this.length;\n  } else {\n    alloc(this, this.length);\n  }\n\n  if (!util.isNumber(subject)) {\n    if (util.isString(subject)) {\n      // In the case of base64 it's possible that the size of the buffer\n      // allocated was slightly too large. In this case we need to rewrite\n      // the length to the actual length written.\n      var len = this.write(subject, encoding);\n\n      // Buffer was truncated after decode, realloc internal ExternalArray\n      if (len !== this.length) {\n        this.length = len;\n        truncate(this, this.length);\n      }\n    } else {\n      if (util.isBuffer(subject))\n        subject.copy(this, 0, 0, this.length);\n      else if (util.isNumber(subject.length) || util.isArray(subject))\n        for (var i = 0; i < this.length; i++)\n          this[i] = subject[i];\n    }\n  }\n}\n\n\nfunction SlowBuffer(length) {\n  length = length >>> 0;\n  if (length > kMaxLength) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + kMaxLength.toString(16) + ' bytes');\n  }\n  var b = new NativeBuffer(length);\n  alloc(b, length);\n  return b;\n}\n\n\n// Bypass all checks for instantiating unallocated Buffer required for\n// Objects created in C++. Significantly faster than calling the Buffer\n// function.\nfunction NativeBuffer(length) {\n  this.length = length;\n}\nNativeBuffer.prototype = Buffer.prototype;\n\n\n// add methods to Buffer prototype\nbuffer.setupBufferJS(NativeBuffer, internal);\n\n\n// Static methods\n\nBuffer.isBuffer = function isBuffer(b) {\n  return util.isBuffer(b);\n};\n\n\nBuffer.compare = function compare(a, b) {\n  if (!(a instanceof Buffer) ||\n      !(b instanceof Buffer))\n    throw new TypeError('Arguments must be Buffers');\n\n  return internal.compare(a, b);\n};\n\n\nBuffer.isEncoding = function(encoding) {\n  switch ((encoding + '').toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n    case 'raw':\n      return true;\n\n    default:\n      return false;\n  }\n};\n\n\nBuffer.concat = function(list, length) {\n  if (!util.isArray(list))\n    throw new TypeError('Usage: Buffer.concat(list[, length])');\n\n  if (util.isUndefined(length)) {\n    length = 0;\n    for (var i = 0; i < list.length; i++)\n      length += list[i].length;\n  } else {\n    length = length >>> 0;\n  }\n\n  if (list.length === 0)\n    return new Buffer(0);\n  else if (list.length === 1)\n    return list[0];\n\n  var buffer = new Buffer(length);\n  var pos = 0;\n  for (var i = 0; i < list.length; i++) {\n    var buf = list[i];\n    buf.copy(buffer, pos);\n    pos += buf.length;\n  }\n\n  return buffer;\n};\n\n\nBuffer.byteLength = function(str, enc) {\n  var ret;\n  str = str + '';\n  switch (enc) {\n    case 'ascii':\n    case 'binary':\n    case 'raw':\n      ret = str.length;\n      break;\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      ret = str.length * 2;\n      break;\n    case 'hex':\n      ret = str.length >>> 1;\n      break;\n    default:\n      ret = internal.byteLength(str, enc);\n  }\n  return ret;\n};\n\n\n// pre-set for values that may exist in the future\nBuffer.prototype.length = undefined;\nBuffer.prototype.parent = undefined;\n\n\n// toString(encoding, start=0, end=buffer.length)\nBuffer.prototype.toString = function(encoding, start, end) {\n  var loweredCase = false;\n\n  start = start >>> 0;\n  end = util.isUndefined(end) || end === Infinity ? this.length : end >>> 0;\n\n  if (!encoding) encoding = 'utf8';\n  if (start < 0) start = 0;\n  if (end > this.length) end = this.length;\n  if (end <= start) return '';\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return this.hexSlice(start, end);\n\n      case 'utf8':\n      case 'utf-8':\n        return this.utf8Slice(start, end);\n\n      case 'ascii':\n        return this.asciiSlice(start, end);\n\n      case 'binary':\n        return this.binarySlice(start, end);\n\n      case 'base64':\n        return this.base64Slice(start, end);\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return this.ucs2Slice(start, end);\n\n      default:\n        if (loweredCase)\n          throw new TypeError('Unknown encoding: ' + encoding);\n        encoding = (encoding + '').toLowerCase();\n        loweredCase = true;\n    }\n  }\n};\n\n\nBuffer.prototype.equals = function equals(b) {\n  if (!(b instanceof Buffer))\n    throw new TypeError('Argument must be a Buffer');\n\n  return internal.compare(this, b) === 0;\n};\n\n\n// Inspect\nBuffer.prototype.inspect = function inspect() {\n  var str = '';\n  var max = exports.INSPECT_MAX_BYTES;\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');\n    if (this.length > max)\n      str += ' ... ';\n  }\n  return '<' + this.constructor.name + ' ' + str + '>';\n};\n\n\nBuffer.prototype.compare = function compare(b) {\n  if (!(b instanceof Buffer))\n    throw new TypeError('Argument must be a Buffer');\n\n  return internal.compare(this, b);\n};\n\n\n// XXX remove in v0.13\nBuffer.prototype.get = util.deprecate(function get(offset) {\n  offset = ~~offset;\n  if (offset < 0 || offset >= this.length)\n    throw new RangeError('index out of range');\n  return this[offset];\n}, '.get() is deprecated. Access using array indexes instead.');\n\n\n// XXX remove in v0.13\nBuffer.prototype.set = util.deprecate(function set(offset, v) {\n  offset = ~~offset;\n  if (offset < 0 || offset >= this.length)\n    throw new RangeError('index out of range');\n  return this[offset] = v;\n}, '.set() is deprecated. Set using array indexes instead.');\n\n\n// TODO(trevnorris): fix these checks to follow new standard\n// write(string, offset = 0, length = buffer.length, encoding = 'utf8')\nvar writeWarned = false;\nvar writeMsg = '.write(string, encoding, offset, length) is deprecated.' +\n               ' Use write(string[, offset[, length]][, encoding]) instead.';\nBuffer.prototype.write = function(string, offset, length, encoding) {\n  // Buffer#write(string);\n  if (util.isUndefined(offset)) {\n    encoding = 'utf8';\n    length = this.length;\n    offset = 0;\n\n  // Buffer#write(string, encoding)\n  } else if (util.isUndefined(length) && util.isString(offset)) {\n    encoding = offset;\n    length = this.length;\n    offset = 0;\n\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset >>> 0;\n    if (isFinite(length)) {\n      length = length >>> 0;\n      if (util.isUndefined(encoding))\n        encoding = 'utf8';\n    } else {\n      encoding = length;\n      length = undefined;\n    }\n\n  // XXX legacy write(string, encoding, offset, length) - remove in v0.13\n  } else {\n    if (!writeWarned) {\n      if (process.throwDeprecation)\n        throw new Error(writeMsg);\n      else if (process.traceDeprecation)\n        console.trace(writeMsg);\n      else\n        console.error(writeMsg);\n      writeWarned = true;\n    }\n\n    var swap = encoding;\n    encoding = offset;\n    offset = length >>> 0;\n    length = swap;\n  }\n\n  var remaining = this.length - offset;\n  if (util.isUndefined(length) || length > remaining)\n    length = remaining;\n\n  encoding = !!encoding ? (encoding + '').toLowerCase() : 'utf8';\n\n  if (string.length > 0 && (length < 0 || offset < 0))\n    throw new RangeError('attempt to write outside buffer bounds');\n\n  var ret;\n  switch (encoding) {\n    case 'hex':\n      ret = this.hexWrite(string, offset, length);\n      break;\n\n    case 'utf8':\n    case 'utf-8':\n      ret = this.utf8Write(string, offset, length);\n      break;\n\n    case 'ascii':\n      ret = this.asciiWrite(string, offset, length);\n      break;\n\n    case 'binary':\n      ret = this.binaryWrite(string, offset, length);\n      break;\n\n    case 'base64':\n      // Warning: maxLength not taken into account in base64Write\n      ret = this.base64Write(string, offset, length);\n      break;\n\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      ret = this.ucs2Write(string, offset, length);\n      break;\n\n    default:\n      throw new TypeError('Unknown encoding: ' + encoding);\n  }\n\n  return ret;\n};\n\n\nBuffer.prototype.toJSON = function() {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this, 0)\n  };\n};\n\n\n// TODO(trevnorris): currently works like Array.prototype.slice(), which\n// doesn't follow the new standard for throwing on out of range indexes.\nBuffer.prototype.slice = function(start, end) {\n  var len = this.length;\n  start = ~~start;\n  end = util.isUndefined(end) ? len : ~~end;\n\n  if (start < 0) {\n    start += len;\n    if (start < 0)\n      start = 0;\n  } else if (start > len) {\n    start = len;\n  }\n\n  if (end < 0) {\n    end += len;\n    if (end < 0)\n      end = 0;\n  } else if (end > len) {\n    end = len;\n  }\n\n  if (end < start)\n    end = start;\n\n  var buf = new NativeBuffer();\n  sliceOnto(this, buf, start, end);\n  buf.length = end - start;\n  if (buf.length > 0)\n    buf.parent = util.isUndefined(this.parent) ? this : this.parent;\n\n  return buf;\n};\n\n\nfunction checkOffset(offset, ext, length) {\n  if (offset + ext > length)\n    throw new RangeError('index out of range');\n}\n\n\nBuffer.prototype.readUInt8 = function(offset, noAssert) {\n  offset = offset >>> 0;\n  if (!noAssert)\n    checkOffset(offset, 1, this.length);\n  return this[offset];\n};\n\n\nBuffer.prototype.readUInt16LE = function(offset, noAssert) {\n  offset = offset >>> 0;\n  if (!noAssert)\n    checkOffset(offset, 2, this.length);\n  return this[offset] | (this[offset + 1] << 8);\n};\n\n\nBuffer.prototype.readUInt16BE = function(offset, noAssert) {\n  offset = offset >>> 0;\n  if (!noAssert)\n    checkOffset(offset, 2, this.length);\n  return (this[offset] << 8) | this[offset + 1];\n};\n\n\nBuffer.prototype.readUInt32LE = function(offset, noAssert) {\n  offset = offset >>> 0;\n  if (!noAssert)\n    checkOffset(offset, 4, this.length);\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000);\n};\n\n\nBuffer.prototype.readUInt32BE = function(offset, noAssert) {\n  offset = offset >>> 0;\n  if (!noAssert)\n    checkOffset(offset, 4, this.length);\n\n  return (this[offset] * 0x1000000) +\n      ((this[offset + 1] << 16) |\n      (this[offset + 2] << 8) |\n      (this[offset + 3]) >>> 0);\n};\n\n\nBuffer.prototype.readInt8 = function(offset, noAssert) {\n  offset = offset >>> 0;\n  if (!noAssert)\n    checkOffset(offset, 1, this.length);\n  var val = this[offset];\n  return !(val & 0x80) ? val : (0xff - val + 1) * -1;\n};\n\n\nBuffer.prototype.readInt16LE = function(offset, noAssert) {\n  offset = offset >>> 0;\n  if (!noAssert)\n    checkOffset(offset, 2, this.length);\n  var val = this[offset] | (this[offset + 1] << 8);\n  return (val & 0x8000) ? val | 0xFFFF0000 : val;\n};\n\n\nBuffer.prototype.readInt16BE = function(offset, noAssert) {\n  offset = offset >>> 0;\n  if (!noAssert)\n    checkOffset(offset, 2, this.length);\n  var val = this[offset + 1] | (this[offset] << 8);\n  return (val & 0x8000) ? val | 0xFFFF0000 : val;\n};\n\n\nBuffer.prototype.readInt32LE = function(offset, noAssert) {\n  offset = offset >>> 0;\n  if (!noAssert)\n    checkOffset(offset, 4, this.length);\n\n  return (this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16) |\n      (this[offset + 3] << 24);\n};\n\n\nBuffer.prototype.readInt32BE = function(offset, noAssert) {\n  offset = offset >>> 0;\n  if (!noAssert)\n    checkOffset(offset, 4, this.length);\n\n  return (this[offset] << 24) |\n      (this[offset + 1] << 16) |\n      (this[offset + 2] << 8) |\n      (this[offset + 3]);\n};\n\n\nfunction checkInt(buffer, value, offset, ext, max, min) {\n  if (!(buffer instanceof Buffer))\n    throw new TypeError('buffer must be a Buffer instance');\n  if (value > max || value < min)\n    throw new TypeError('value is out of bounds');\n  if (offset + ext > buffer.length)\n    throw new RangeError('index out of range');\n}\n\n\nBuffer.prototype.writeUInt8 = function(value, offset, noAssert) {\n  value = +value;\n  offset = offset >>> 0;\n  if (!noAssert)\n    checkInt(this, value, offset, 1, 0xff, 0);\n  this[offset] = value;\n  return offset + 1;\n};\n\n\nBuffer.prototype.writeUInt16LE = function(value, offset, noAssert) {\n  value = +value;\n  offset = offset >>> 0;\n  if (!noAssert)\n    checkInt(this, value, offset, 2, 0xffff, 0);\n  this[offset] = value;\n  this[offset + 1] = (value >>> 8);\n  return offset + 2;\n};\n\n\nBuffer.prototype.writeUInt16BE = function(value, offset, noAssert) {\n  value = +value;\n  offset = offset >>> 0;\n  if (!noAssert)\n    checkInt(this, value, offset, 2, 0xffff, 0);\n  this[offset] = (value >>> 8);\n  this[offset + 1] = value;\n  return offset + 2;\n};\n\n\nBuffer.prototype.writeUInt32LE = function(value, offset, noAssert) {\n  value = +value;\n  offset = offset >>> 0;\n  if (!noAssert)\n    checkInt(this, value, offset, 4, 0xffffffff, 0);\n  this[offset + 3] = (value >>> 24);\n  this[offset + 2] = (value >>> 16);\n  this[offset + 1] = (value >>> 8);\n  this[offset] = value;\n  return offset + 4;\n};\n\n\nBuffer.prototype.writeUInt32BE = function(value, offset, noAssert) {\n  value = +value;\n  offset = offset >>> 0;\n  if (!noAssert)\n    checkInt(this, value, offset, 4, 0xffffffff, 0);\n  this[offset] = (value >>> 24);\n  this[offset + 1] = (value >>> 16);\n  this[offset + 2] = (value >>> 8);\n  this[offset + 3] = value;\n  return offset + 4;\n};\n\n\nBuffer.prototype.writeInt8 = function(value, offset, noAssert) {\n  value = +value;\n  offset = offset >>> 0;\n  if (!noAssert)\n    checkInt(this, value, offset, 1, 0x7f, -0x80);\n  this[offset] = value;\n  return offset + 1;\n};\n\n\nBuffer.prototype.writeInt16LE = function(value, offset, noAssert) {\n  value = +value;\n  offset = offset >>> 0;\n  if (!noAssert)\n    checkInt(this, value, offset, 2, 0x7fff, -0x8000);\n  this[offset] = value;\n  this[offset + 1] = (value >>> 8);\n  return offset + 2;\n};\n\n\nBuffer.prototype.writeInt16BE = function(value, offset, noAssert) {\n  value = +value;\n  offset = offset >>> 0;\n  if (!noAssert)\n    checkInt(this, value, offset, 2, 0x7fff, -0x8000);\n  this[offset] = (value >>> 8);\n  this[offset + 1] = value;\n  return offset + 2;\n};\n\n\nBuffer.prototype.writeInt32LE = function(value, offset, noAssert) {\n  value = +value;\n  offset = offset >>> 0;\n  if (!noAssert)\n    checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);\n  this[offset] = value;\n  this[offset + 1] = (value >>> 8);\n  this[offset + 2] = (value >>> 16);\n  this[offset + 3] = (value >>> 24);\n  return offset + 4;\n};\n\n\nBuffer.prototype.writeInt32BE = function(value, offset, noAssert) {\n  value = +value;\n  offset = offset >>> 0;\n  if (!noAssert)\n    checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);\n  this[offset] = (value >>> 24);\n  this[offset + 1] = (value >>> 16);\n  this[offset + 2] = (value >>> 8);\n  this[offset + 3] = value;\n  return offset + 4;\n};\n",
  @"// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar StringDecoder = require('string_decoder').StringDecoder;\nvar EventEmitter = require('events').EventEmitter;\nvar net = require('net');\nvar dgram = require('dgram');\nvar assert = require('assert');\nvar util = require('util');\n\nvar Process = process.binding('process_wrap').Process;\nvar uv = process.binding('uv');\n\nvar spawn_sync; // Lazy-loaded process.binding('spawn_sync')\nvar constants;  // Lazy-loaded process.binding('constants')\n\nvar errnoException = util._errnoException;\nvar handleWraps = {};\n\nfunction handleWrapGetter(name, callback) {\n  var cons;\n\n  Object.defineProperty(handleWraps, name, {\n    get: function() {\n      if (!util.isUndefined(cons)) return cons;\n      return cons = callback();\n    }\n  });\n}\n\nhandleWrapGetter('Pipe', function() {\n  return process.binding('pipe_wrap').Pipe;\n});\n\nhandleWrapGetter('TTY', function() {\n  return process.binding('tty_wrap').TTY;\n});\n\nhandleWrapGetter('TCP', function() {\n  return process.binding('tcp_wrap').TCP;\n});\n\nhandleWrapGetter('UDP', function() {\n  return process.binding('udp_wrap').UDP;\n});\n\n// constructors for lazy loading\nfunction createPipe(ipc) {\n  return new handleWraps.Pipe(ipc);\n}\n\nfunction createSocket(pipe, readable) {\n  var s = new net.Socket({ handle: pipe });\n\n  if (readable) {\n    s.writable = false;\n    s.readable = true;\n  } else {\n    s.writable = true;\n    s.readable = false;\n  }\n\n  return s;\n}\n\n\n// this object contain function to convert TCP objects to native handle objects\n// and back again.\nvar handleConversion = {\n  'net.Native': {\n    simultaneousAccepts: true,\n\n    send: function(message, handle) {\n      return handle;\n    },\n\n    got: function(message, handle, emit) {\n      emit(handle);\n    }\n  },\n\n  'net.Server': {\n    simultaneousAccepts: true,\n\n    send: function(message, server) {\n      return server._handle;\n    },\n\n    got: function(message, handle, emit) {\n      var server = new net.Server();\n      server.listen(handle, function() {\n        emit(server);\n      });\n    }\n  },\n\n  'net.Socket': {\n    send: function(message, socket) {\n      if (!socket._handle)\n        return;\n\n      // if the socket was created by net.Server\n      if (socket.server) {\n        // the slave should keep track of the socket\n        message.key = socket.server._connectionKey;\n\n        var firstTime = !this._channel.sockets.send[message.key];\n        var socketList = getSocketList('send', this, message.key);\n\n        // the server should no longer expose a .connection property\n        // and when asked to close it should query the socket status from\n        // the slaves\n        if (firstTime) socket.server._setupSlave(socketList);\n\n        // Act like socket is detached\n        socket.server._connections--;\n      }\n\n      // remove handle from socket object, it will be closed when the socket\n      // will be sent\n      var handle = socket._handle;\n      handle.onread = function() {};\n      socket._handle = null;\n\n      return handle;\n    },\n\n    postSend: function(handle) {\n      // Close the Socket handle after sending it\n      if (handle)\n        handle.close();\n    },\n\n    got: function(message, handle, emit) {\n      var socket = new net.Socket({handle: handle});\n      socket.readable = socket.writable = true;\n\n      // if the socket was created by net.Server we will track the socket\n      if (message.key) {\n\n        // add socket to connections list\n        var socketList = getSocketList('got', this, message.key);\n        socketList.add({\n          socket: socket\n        });\n      }\n\n      emit(socket);\n    }\n  },\n\n  'dgram.Native': {\n    simultaneousAccepts: false,\n\n    send: function(message, handle) {\n      return handle;\n    },\n\n    got: function(message, handle, emit) {\n      emit(handle);\n    }\n  },\n\n  'dgram.Socket': {\n    simultaneousAccepts: false,\n\n    send: function(message, socket) {\n      message.dgramType = socket.type;\n\n      return socket._handle;\n    },\n\n    got: function(message, handle, emit) {\n      var socket = new dgram.Socket(message.dgramType);\n\n      socket.bind(handle, function() {\n        emit(socket);\n      });\n    }\n  }\n};\n\n// This object keep track of the socket there are sended\nfunction SocketListSend(slave, key) {\n  EventEmitter.call(this);\n\n  this.key = key;\n  this.slave = slave;\n}\nutil.inherits(SocketListSend, EventEmitter);\n\nSocketListSend.prototype._request = function(msg, cmd, callback) {\n  var self = this;\n\n  if (!this.slave.connected) return onclose();\n  this.slave.send(msg);\n\n  function onclose() {\n    self.slave.removeListener('internalMessage', onreply);\n    callback(new Error('Slave closed before reply'));\n  };\n\n  function onreply(msg) {\n    if (!(msg.cmd === cmd && msg.key === self.key)) return;\n    self.slave.removeListener('disconnect', onclose);\n    self.slave.removeListener('internalMessage', onreply);\n\n    callback(null, msg);\n  };\n\n  this.slave.once('disconnect', onclose);\n  this.slave.on('internalMessage', onreply);\n};\n\nSocketListSend.prototype.close = function close(callback) {\n  this._request({\n    cmd: 'NODE_SOCKET_NOTIFY_CLOSE',\n    key: this.key\n  }, 'NODE_SOCKET_ALL_CLOSED', callback);\n};\n\nSocketListSend.prototype.getConnections = function getConnections(callback) {\n  this._request({\n    cmd: 'NODE_SOCKET_GET_COUNT',\n    key: this.key\n  }, 'NODE_SOCKET_COUNT', function(err, msg) {\n    if (err) return callback(err);\n    callback(null, msg.count);\n  });\n};\n\n// This object keep track of the socket there are received\nfunction SocketListReceive(slave, key) {\n  EventEmitter.call(this);\n\n  var self = this;\n\n  this.connections = 0;\n  this.key = key;\n  this.slave = slave;\n\n  function onempty() {\n    if (!self.slave.connected) return;\n\n    self.slave.send({\n      cmd: 'NODE_SOCKET_ALL_CLOSED',\n      key: self.key\n    });\n  }\n\n  this.slave.on('internalMessage', function(msg) {\n    if (msg.key !== self.key) return;\n\n    if (msg.cmd === 'NODE_SOCKET_NOTIFY_CLOSE') {\n      // Already empty\n      if (self.connections === 0) return onempty();\n\n      // Wait for sockets to get closed\n      self.once('empty', onempty);\n    } else if (msg.cmd === 'NODE_SOCKET_GET_COUNT') {\n      if (!self.slave.connected) return;\n      self.slave.send({\n        cmd: 'NODE_SOCKET_COUNT',\n        key: self.key,\n        count: self.connections\n      });\n    }\n  });\n}\nutil.inherits(SocketListReceive, EventEmitter);\n\nSocketListReceive.prototype.add = function(obj) {\n  var self = this;\n\n  this.connections++;\n\n  // Notify previous owner of socket about its state change\n  obj.socket.once('close', function() {\n    self.connections--;\n\n    if (self.connections === 0) self.emit('empty');\n  });\n};\n\nfunction getSocketList(type, slave, key) {\n  var sockets = slave._channel.sockets[type];\n  var socketList = sockets[key];\n  if (!socketList) {\n    var Construct = type === 'send' ? SocketListSend : SocketListReceive;\n    socketList = sockets[key] = new Construct(slave, key);\n  }\n  return socketList;\n}\n\nvar INTERNAL_PREFIX = 'NODE_';\nfunction handleMessage(target, message, handle) {\n  var eventName = 'message';\n  if (!util.isNull(message) &&\n      util.isObject(message) &&\n      util.isString(message.cmd) &&\n      message.cmd.length > INTERNAL_PREFIX.length &&\n      message.cmd.slice(0, INTERNAL_PREFIX.length) === INTERNAL_PREFIX) {\n    eventName = 'internalMessage';\n  }\n  target.emit(eventName, message, handle);\n}\n\nfunction setupChannel(target, channel) {\n  target._channel = channel;\n  target._handleQueue = null;\n\n  var decoder = new StringDecoder('utf8');\n  var jsonBuffer = '';\n  channel.buffering = false;\n  channel.onread = function(nread, pool, recvHandle) {\n    // TODO(bnoordhuis) Check that nread > 0.\n    if (pool) {\n      jsonBuffer += decoder.write(pool);\n\n      var i, start = 0;\n\n      //Linebreak is used as a message end sign\n      while ((i = jsonBuffer.indexOf('\\n', start)) >= 0) {\n        var json = jsonBuffer.slice(start, i);\n        var message = JSON.parse(json);\n\n        // There will be at most one NODE_HANDLE message in every chunk we\n        // read because SCM_RIGHTS messages don't get coalesced. Make sure\n        // that we deliver the handle with the right message however.\n        if (message && message.cmd === 'NODE_HANDLE')\n          handleMessage(target, message, recvHandle);\n        else\n          handleMessage(target, message, undefined);\n\n        start = i + 1;\n      }\n      jsonBuffer = jsonBuffer.slice(start);\n      this.buffering = jsonBuffer.length !== 0;\n\n    } else {\n      this.buffering = false;\n      target.disconnect();\n      channel.onread = nop;\n      channel.close();\n      maybeClose(target);\n    }\n  };\n\n  // object where socket lists will live\n  channel.sockets = { got: {}, send: {} };\n\n  // handlers will go through this\n  target.on('internalMessage', function(message, handle) {\n    // Once acknowledged - continue sending handles.\n    if (message.cmd === 'NODE_HANDLE_ACK') {\n      assert(util.isArray(target._handleQueue));\n      var queue = target._handleQueue;\n      target._handleQueue = null;\n\n      queue.forEach(function(args) {\n        target._send(args.message, args.handle, false);\n      });\n\n      // Process a pending disconnect (if any).\n      if (!target.connected && target._channel && !target._handleQueue)\n        target._disconnect();\n\n      return;\n    }\n\n    if (message.cmd !== 'NODE_HANDLE') return;\n\n    // Acknowledge handle receival. Don't emit error events (for example if\n    // the other side has disconnected) because this call to send() is not\n    // initiated by the user and it shouldn't be fatal to be unable to ACK\n    // a message.\n    target._send({ cmd: 'NODE_HANDLE_ACK' }, null, true);\n\n    var obj = handleConversion[message.type];\n\n    // Update simultaneous accepts on Windows\n    if (process.platform === 'win32') {\n      handle._simultaneousAccepts = false;\n      net._setSimultaneousAccepts(handle);\n    }\n\n    // Convert handle object\n    obj.got.call(this, message, handle, function(handle) {\n      handleMessage(target, message.msg, handle);\n    });\n  });\n\n  target.send = function(message, handle) {\n    if (!this.connected)\n      this.emit('error', new Error('channel closed'));\n    else\n      this._send(message, handle, false);\n  };\n\n  target._send = function(message, handle, swallowErrors) {\n    assert(this.connected || this._channel);\n\n    if (util.isUndefined(message))\n      throw new TypeError('message cannot be undefined');\n\n    // package messages with a handle object\n    if (handle) {\n      // this message will be handled by an internalMessage event handler\n      message = {\n        cmd: 'NODE_HANDLE',\n        type: null,\n        msg: message\n      };\n\n      if (handle instanceof net.Socket) {\n        message.type = 'net.Socket';\n      } else if (handle instanceof net.Server) {\n        message.type = 'net.Server';\n      } else if (handle instanceof process.binding('tcp_wrap').TCP ||\n                 handle instanceof process.binding('pipe_wrap').Pipe) {\n        message.type = 'net.Native';\n      } else if (handle instanceof dgram.Socket) {\n        message.type = 'dgram.Socket';\n      } else if (handle instanceof process.binding('udp_wrap').UDP) {\n        message.type = 'dgram.Native';\n      } else {\n        throw new TypeError(\"This handle type can't be sent\");\n      }\n\n      // Queue-up message and handle if we haven't received ACK yet.\n      if (this._handleQueue) {\n        this._handleQueue.push({ message: message.msg, handle: handle });\n        return;\n      }\n\n      var obj = handleConversion[message.type];\n\n      // convert TCP object to native handle object\n      handle = handleConversion[message.type].send.apply(target, arguments);\n\n      // If handle was sent twice, or it is impossible to get native handle\n      // out of it - just send a text without the handle.\n      if (!handle)\n        message = message.msg;\n\n      // Update simultaneous accepts on Windows\n      if (obj.simultaneousAccepts) {\n        net._setSimultaneousAccepts(handle);\n      }\n    } else if (this._handleQueue &&\n               !(message && message.cmd === 'NODE_HANDLE_ACK')) {\n      // Queue request anyway to avoid out-of-order messages.\n      this._handleQueue.push({ message: message, handle: null });\n      return;\n    }\n\n    var req = { oncomplete: nop };\n    var string = JSON.stringify(message) + '\\n';\n    var err = channel.writeUtf8String(req, string, handle);\n\n    if (err) {\n      if (!swallowErrors)\n        this.emit('error', errnoException(err, 'write'));\n    } else if (handle && !this._handleQueue) {\n      this._handleQueue = [];\n    }\n\n    if (obj && obj.postSend) {\n      req.oncomplete = obj.postSend.bind(null, handle);\n    }\n\n\n    return channel.writeQueueSize < (65536 * 2);\n  };\n\n  // connected will be set to false immediately when a disconnect() is\n  // requested, even though the channel might still be alive internally to\n  // process queued messages. The three states are distinguished as follows:\n  // - disconnect() never requested: _channel is not null and connected\n  //   is true\n  // - disconnect() requested, messages in the queue: _channel is not null\n  //   and connected is false\n  // - disconnect() requested, channel actually disconnected: _channel is\n  //   null and connected is false\n  target.connected = true;\n\n  target.disconnect = function() {\n    if (!this.connected) {\n      this.emit('error', new Error('IPC channel is already disconnected'));\n      return;\n    }\n\n    // Do not allow any new messages to be written.\n    this.connected = false;\n\n    // If there are no queued messages, disconnect immediately. Otherwise,\n    // postpone the disconnect so that it happens internally after the\n    // queue is flushed.\n    if (!this._handleQueue)\n      this._disconnect();\n  };\n\n  target._disconnect = function() {\n    assert(this._channel);\n\n    // This marks the fact that the channel is actually disconnected.\n    this._channel = null;\n\n    var fired = false;\n    function finish() {\n      if (fired) return;\n      fired = true;\n\n      channel.close();\n      target.emit('disconnect');\n    }\n\n    // If a message is being read, then wait for it to complete.\n    if (channel.buffering) {\n      this.once('message', finish);\n      this.once('internalMessage', finish);\n\n      return;\n    }\n\n    process.nextTick(finish);\n  };\n\n  channel.readStart();\n}\n\n\nfunction nop() { }\n\nexports.fork = function(modulePath ) {\n\n  // Get options and args arguments.\n  var options, args, execArgv;\n  if (util.isArray(arguments[1])) {\n    args = arguments[1];\n    options = util._extend({}, arguments[2]);\n  } else {\n    args = [];\n    options = util._extend({}, arguments[1]);\n  }\n\n  // Prepare arguments for fork:\n  execArgv = options.execArgv || process.execArgv;\n  args = execArgv.concat([modulePath], args);\n\n  // Leave stdin open for the IPC channel. stdout and stderr should be the\n  // same as the parent's if silent isn't set.\n  options.stdio = options.silent ? ['pipe', 'pipe', 'pipe', 'ipc'] :\n      [0, 1, 2, 'ipc'];\n\n  options.execPath = options.execPath || process.execPath;\n\n  return spawn(options.execPath, args, options);\n};\n\n\nexports._forkChild = function(fd) {\n  // set process.send()\n  var p = createPipe(true);\n  p.open(fd);\n  p.unref();\n  setupChannel(process, p);\n\n  var refs = 0;\n  process.on('newListener', function(name) {\n    if (name !== 'message' && name !== 'disconnect') return;\n    if (++refs === 1) p.ref();\n  });\n  process.on('removeListener', function(name) {\n    if (name !== 'message' && name !== 'disconnect') return;\n    if (--refs === 0) p.unref();\n  });\n};\n\n\nfunction normalizeExecArgs(command ) {\n  var file, args, options, callback;\n\n  if (util.isFunction(arguments[1])) {\n    options = undefined;\n    callback = arguments[1];\n  } else {\n    options = arguments[1];\n    callback = arguments[2];\n  }\n\n  if (process.platform === 'win32') {\n    file = process.env.comspec || 'cmd.exe';\n    args = ['/s', '/c', '\"' + command + '\"'];\n    // Make a shallow copy before patching so we don't clobber the user's\n    // options object.\n    options = util._extend({}, options);\n    options.windowsVerbatimArguments = true;\n  } else {\n    file = '/bin/sh';\n    args = ['-c', command];\n  }\n\n  if (options && options.shell)\n    file = options.shell;\n\n  return {\n    cmd: command,\n    file: file,\n    args: args,\n    options: options,\n    callback: callback\n  };\n}\n\n\nexports.exec = function(command ) {\n  var opts = normalizeExecArgs.apply(null, arguments);\n  return exports.execFile(opts.file,\n                          opts.args,\n                          opts.options,\n                          opts.callback);\n};\n\n\nexports.execFile = function(file ) {\n  var args, callback;\n  var options = {\n    encoding: 'utf8',\n    timeout: 0,\n    maxBuffer: 200 * 1024,\n    killSignal: 'SIGTERM',\n    cwd: null,\n    env: null\n  };\n\n  // Parse the parameters.\n\n  if (util.isFunction(arguments[arguments.length - 1])) {\n    callback = arguments[arguments.length - 1];\n  }\n\n  if (util.isArray(arguments[1])) {\n    args = arguments[1];\n    options = util._extend(options, arguments[2]);\n  } else {\n    args = [];\n    options = util._extend(options, arguments[1]);\n  }\n\n  var child = spawn(file, args, {\n    cwd: options.cwd,\n    env: options.env,\n    gid: options.gid,\n    uid: options.uid,\n    windowsVerbatimArguments: !!options.windowsVerbatimArguments\n  });\n\n  var encoding;\n  var _stdout;\n  var _stderr;\n  if (options.encoding !== 'buffer' && Buffer.isEncoding(options.encoding)) {\n    encoding = options.encoding;\n    _stdout = '';\n    _stderr = '';\n  } else {\n    _stdout = [];\n    _stderr = [];\n    encoding = null;\n  }\n  var stdoutLen = 0;\n  var stderrLen = 0;\n  var killed = false;\n  var exited = false;\n  var timeoutId;\n\n  var ex = null;\n\n  function exithandler(code, signal) {\n    if (exited) return;\n    exited = true;\n\n    if (timeoutId) {\n      clearTimeout(timeoutId);\n      timeoutId = null;\n    }\n\n    if (!callback) return;\n\n    // merge chunks\n    var stdout;\n    var stderr;\n    if (!encoding) {\n      stdout = Buffer.concat(_stdout);\n      stderr = Buffer.concat(_stderr);\n    } else {\n      stdout = _stdout;\n      stderr = _stderr;\n    }\n\n    if (ex) {\n      // Will be handled later\n    } else if (code === 0 && signal === null) {\n      callback(null, stdout, stderr);\n      return;\n    }\n\n    var cmd = file;\n    if (args.length !== 0)\n      cmd += ' ' + args.join(' ');\n\n    if (!ex) {\n      ex = new Error('Command failed: ' + cmd + '\\n' + stderr);\n      ex.killed = child.killed || killed;\n      ex.code = code < 0 ? uv.errname(code) : code;\n      ex.signal = signal;\n    }\n\n    ex.cmd = cmd;\n    callback(ex, stdout, stderr);\n  }\n\n  function errorhandler(e) {\n    ex = e;\n    child.stdout.destroy();\n    child.stderr.destroy();\n    exithandler();\n  }\n\n  function kill() {\n    child.stdout.destroy();\n    child.stderr.destroy();\n\n    killed = true;\n    try {\n      child.kill(options.killSignal);\n    } catch (e) {\n      ex = e;\n      exithandler();\n    }\n  }\n\n  if (options.timeout > 0) {\n    timeoutId = setTimeout(function() {\n      kill();\n      timeoutId = null;\n    }, options.timeout);\n  }\n\n  child.stdout.addListener('data', function(chunk) {\n    stdoutLen += chunk.length;\n\n    if (stdoutLen > options.maxBuffer) {\n      ex = new Error('stdout maxBuffer exceeded.');\n      kill();\n    } else {\n      if (!encoding)\n        _stdout.push(chunk);\n      else\n        _stdout += chunk;\n    }\n  });\n\n  child.stderr.addListener('data', function(chunk) {\n    stderrLen += chunk.length;\n\n    if (stderrLen > options.maxBuffer) {\n      ex = new Error('stderr maxBuffer exceeded.');\n      kill();\n    } else {\n      if (!encoding)\n        _stderr.push(chunk);\n      else\n        _stderr += chunk;\n    }\n  });\n\n  if (encoding) {\n    child.stderr.setEncoding(encoding);\n    child.stdout.setEncoding(encoding);\n  }\n\n  child.addListener('close', exithandler);\n  child.addListener('error', errorhandler);\n\n  return child;\n};\n\nvar _deprecatedCustomFds = util.deprecate(function(options) {\n  options.stdio = options.customFds.map(function(fd) {\n    return fd === -1 ? 'pipe' : fd;\n  });\n}, 'child_process: customFds option is deprecated, use stdio instead.');\n\nfunction _convertCustomFds(options) {\n  if (options && options.customFds && !options.stdio) {\n    _deprecatedCustomFds(options);\n  }\n}\n\n\nfunction _validateStdio(stdio, sync) {\n  var ipc,\n      ipcFd;\n\n  // Replace shortcut with an array\n  if (util.isString(stdio)) {\n    switch (stdio) {\n      case 'ignore': stdio = ['ignore', 'ignore', 'ignore']; break;\n      case 'pipe': stdio = ['pipe', 'pipe', 'pipe']; break;\n      case 'inherit': stdio = [0, 1, 2]; break;\n      default: throw new TypeError('Incorrect value of stdio option: ' + stdio);\n    }\n  } else if (!util.isArray(stdio)) {\n    throw new TypeError('Incorrect value of stdio option: ' +\n        util.inspect(stdio));\n  }\n\n  // At least 3 stdio will be created\n  // Don't concat() a new Array() because it would be sparse, and\n  // stdio.reduce() would skip the sparse elements of stdio.\n  // See http://stackoverflow.com/a/5501711/3561\n  while (stdio.length < 3) stdio.push(undefined);\n\n  // Translate stdio into C++-readable form\n  // (i.e. PipeWraps or fds)\n  stdio = stdio.reduce(function(acc, stdio, i) {\n    function cleanup() {\n      acc.filter(function(stdio) {\n        return stdio.type === 'pipe' || stdio.type === 'ipc';\n      }).forEach(function(stdio) {\n        if (stdio.handle)\n          stdio.handle.close();\n      });\n    }\n\n    // Defaults\n    if (util.isNullOrUndefined(stdio)) {\n      stdio = i < 3 ? 'pipe' : 'ignore';\n    }\n\n    if (stdio === null || stdio === 'ignore') {\n      acc.push({type: 'ignore'});\n    } else if (stdio === 'pipe' || util.isNumber(stdio) && stdio < 0) {\n      var a = {\n        type: 'pipe',\n        readable: i === 0,\n        writable: i !== 0\n      };\n\n      if (!sync)\n        a.handle = createPipe();\n\n      acc.push(a);\n    } else if (stdio === 'ipc') {\n      if (sync || !util.isUndefined(ipc)) {\n        // Cleanup previously created pipes\n        cleanup();\n        if (!sync)\n          throw Error('Child process can have only one IPC pipe');\n        else\n          throw Error('You cannot use IPC with synchronous forks');\n      }\n\n      ipc = createPipe(true);\n      ipcFd = i;\n\n      acc.push({\n        type: 'pipe',\n        handle: ipc,\n        ipc: true\n      });\n    } else if (stdio === 'inherit') {\n      acc.push({\n        type: 'inherit',\n        fd: i\n      });\n    } else if (util.isNumber(stdio) || util.isNumber(stdio.fd)) {\n      acc.push({\n        type: 'fd',\n        fd: stdio.fd || stdio\n      });\n    } else if (getHandleWrapType(stdio) || getHandleWrapType(stdio.handle) ||\n               getHandleWrapType(stdio._handle)) {\n      var handle = getHandleWrapType(stdio) ?\n          stdio :\n          getHandleWrapType(stdio.handle) ? stdio.handle : stdio._handle;\n\n      acc.push({\n        type: 'wrap',\n        wrapType: getHandleWrapType(handle),\n        handle: handle\n      });\n    } else if (util.isBuffer(stdio) || util.isString(stdio)) {\n      if (!sync) {\n        cleanup();\n        throw new TypeError('Asynchronous forks do not support Buffer input: ' +\n            util.inspect(stdio));\n      }\n    } else {\n      // Cleanup\n      cleanup();\n      throw new TypeError('Incorrect value for stdio stream: ' +\n          util.inspect(stdio));\n    }\n\n    return acc;\n  }, []);\n\n  return {stdio: stdio, ipc: ipc, ipcFd: ipcFd};\n}\n\n\nfunction normalizeSpawnArguments() {\n  var args, options;\n\n  var file = arguments[0];\n\n  if (Array.isArray(arguments[1])) {\n    args = arguments[1].slice(0);\n    options = arguments[2];\n  } else if (arguments[1] && !Array.isArray(arguments[1])) {\n    throw new TypeError('Incorrect value of args option');\n  } else {\n    args = [];\n    options = arguments[1];\n  }\n\n  if (!options)\n    options = {};\n\n  args.unshift(file);\n\n  var env = (options && options.env ? options.env : null) || process.env;\n  var envPairs = [];\n  for (var key in env) {\n    envPairs.push(key + '=' + env[key]);\n  }\n\n  _convertCustomFds(options);\n\n  return {\n    file: file,\n    args: args,\n    options: options,\n    envPairs: envPairs\n  };\n}\n\n\nvar spawn = exports.spawn = function() {\n  var opts = normalizeSpawnArguments.apply(null, arguments);\n\n  var file = opts.file;\n  var args = opts.args;\n  var options = opts.options;\n  var envPairs = opts.envPairs;\n\n  var child = new ChildProcess();\n\n  child.spawn({\n    file: file,\n    args: args,\n    cwd: options ? options.cwd : null,\n    windowsVerbatimArguments: !!(options && options.windowsVerbatimArguments),\n    detached: !!(options && options.detached),\n    envPairs: envPairs,\n    stdio: options ? options.stdio : null,\n    uid: options ? options.uid : null,\n    gid: options ? options.gid : null\n  });\n\n  return child;\n};\n\n\nfunction maybeClose(subprocess) {\n  subprocess._closesGot++;\n\n  if (subprocess._closesGot == subprocess._closesNeeded) {\n    subprocess.emit('close', subprocess.exitCode, subprocess.signalCode);\n  }\n}\n\n\nfunction ChildProcess() {\n  EventEmitter.call(this);\n\n  // Initialize TCPWrap and PipeWrap\n  process.binding('tcp_wrap');\n  process.binding('pipe_wrap');\n\n  var self = this;\n\n  this._closesNeeded = 1;\n  this._closesGot = 0;\n  this.connected = false;\n\n  this.signalCode = null;\n  this.exitCode = null;\n  this.killed = false;\n  this.spawnfile = null;\n\n  this._handle = new Process();\n  this._handle.owner = this;\n\n  this._handle.onexit = function(exitCode, signalCode) {\n    //\n    // follow 0.4.x behaviour:\n    //\n    // - normally terminated processes don't touch this.signalCode\n    // - signaled processes don't touch this.exitCode\n    //\n    // new in 0.9.x:\n    //\n    // - spawn failures are reported with exitCode < 0\n    //\n    var syscall = self.spawnfile ? 'spawn ' + self.spawnfile : 'spawn';\n    var err = (exitCode < 0) ? errnoException(exitCode, syscall) : null;\n\n    if (signalCode) {\n      self.signalCode = signalCode;\n    } else {\n      self.exitCode = exitCode;\n    }\n\n    if (self.stdin) {\n      self.stdin.destroy();\n    }\n\n    self._handle.close();\n    self._handle = null;\n\n    if (exitCode < 0) {\n      if (self.spawnfile)\n        err.path = self.spawnfile;\n\n      self.emit('error', err);\n    } else {\n      self.emit('exit', self.exitCode, self.signalCode);\n    }\n\n    // if any of the stdio streams have not been touched,\n    // then pull all the data through so that it can get the\n    // eof and emit a 'close' event.\n    // Do it on nextTick so that the user has one last chance\n    // to consume the output, if for example they only want to\n    // start reading the data once the process exits.\n    process.nextTick(function() {\n      flushStdio(self);\n    });\n\n    maybeClose(self);\n  };\n}\nutil.inherits(ChildProcess, EventEmitter);\n\n\nfunction flushStdio(subprocess) {\n  if (subprocess.stdio == null) return;\n  subprocess.stdio.forEach(function(stream, fd, stdio) {\n    if (!stream || !stream.readable || stream._consuming ||\n        stream._readableState.flowing)\n      return;\n    stream.resume();\n  });\n}\n\n\n\nfunction getHandleWrapType(stream) {\n  if (stream instanceof handleWraps.Pipe) return 'pipe';\n  if (stream instanceof handleWraps.TTY) return 'tty';\n  if (stream instanceof handleWraps.TCP) return 'tcp';\n  if (stream instanceof handleWraps.UDP) return 'udp';\n\n  return false;\n}\n\n\nChildProcess.prototype.spawn = function(options) {\n  var self = this,\n      ipc,\n      ipcFd,\n      // If no `stdio` option was given - use default\n      stdio = options.stdio || 'pipe';\n\n  stdio = _validateStdio(stdio, false);\n\n  ipc = stdio.ipc;\n  ipcFd = stdio.ipcFd;\n  stdio = options.stdio = stdio.stdio;\n\n  if (!util.isUndefined(ipc)) {\n    // Let child process know about opened IPC channel\n    options.envPairs = options.envPairs || [];\n    options.envPairs.push('NODE_CHANNEL_FD=' + ipcFd);\n  }\n\n  this.spawnfile = options.file;\n\n  var err = this._handle.spawn(options);\n\n  // Run-time errors should emit an error, not throw an exception.\n  if (err === uv.UV_EAGAIN ||\n      err === uv.UV_EMFILE ||\n      err === uv.UV_ENFILE ||\n      err === uv.UV_ENOENT) {\n    process.nextTick(function() {\n      self._handle.onexit(err);\n    });\n    // There is no point in continuing when we've hit EMFILE or ENFILE\n    // because we won't be able to set up the stdio file descriptors.\n    // It's kind of silly that the de facto spec for ENOENT (the test suite)\n    // mandates that stdio _is_ set up, even if there is no process on the\n    // receiving end, but it is what it is.\n    if (err !== uv.UV_ENOENT) return err;\n  } else if (err) {\n    // Close all opened fds on error\n    stdio.forEach(function(stdio) {\n      if (stdio.type === 'pipe') {\n        stdio.handle.close();\n      }\n    });\n\n    this._handle.close();\n    this._handle = null;\n    throw errnoException(err, 'spawn');\n  }\n\n  this.pid = this._handle.pid;\n\n  stdio.forEach(function(stdio, i) {\n    if (stdio.type === 'ignore') return;\n\n    if (stdio.ipc) {\n      self._closesNeeded++;\n      return;\n    }\n\n    if (stdio.handle) {\n      // when i === 0 - we're dealing with stdin\n      // (which is the only one writable pipe)\n      stdio.socket = createSocket(self.pid !== 0 ? stdio.handle : null, i > 0);\n\n      if (i > 0 && self.pid !== 0) {\n        self._closesNeeded++;\n        stdio.socket.on('close', function() {\n          maybeClose(self);\n        });\n      }\n    }\n  });\n\n  this.stdin = stdio.length >= 1 && !util.isUndefined(stdio[0].socket) ?\n      stdio[0].socket : null;\n  this.stdout = stdio.length >= 2 && !util.isUndefined(stdio[1].socket) ?\n      stdio[1].socket : null;\n  this.stderr = stdio.length >= 3 && !util.isUndefined(stdio[2].socket) ?\n      stdio[2].socket : null;\n\n  this.stdio = stdio.map(function(stdio) {\n    return util.isUndefined(stdio.socket) ? null : stdio.socket;\n  });\n\n  // Add .send() method and start listening for IPC data\n  if (!util.isUndefined(ipc)) setupChannel(this, ipc);\n\n  return err;\n};\n\n\nChildProcess.prototype.kill = function(sig) {\n  var signal;\n\n  if (!constants) {\n    constants = process.binding('constants');\n  }\n\n  if (sig === 0) {\n    signal = 0;\n  } else if (!sig) {\n    signal = constants['SIGTERM'];\n  } else {\n    signal = constants[sig];\n  }\n\n  if (util.isUndefined(signal)) {\n    throw new Error('Unknown signal: ' + sig);\n  }\n\n  if (this._handle) {\n    var err = this._handle.kill(signal);\n    if (err === 0) {\n\n      this.killed = true;\n      return true;\n    }\n    if (err === uv.UV_ESRCH) {\n\n    } else if (err === uv.UV_EINVAL || err === uv.UV_ENOSYS) {\n\n      throw errnoException(err, 'kill');\n    } else {\n\n      this.emit('error', errnoException(err, 'kill'));\n    }\n  }\n\n\n  return false;\n};\n\n\nChildProcess.prototype.ref = function() {\n  if (this._handle) this._handle.ref();\n};\n\n\nChildProcess.prototype.unref = function() {\n  if (this._handle) this._handle.unref();\n};\n\n\nfunction lookupSignal(signal) {\n  if (typeof signal === 'number')\n    return signal;\n\n  if (!constants)\n    constants = process.binding('constants');\n\n  if (!(signal in constants))\n    throw new Error('Unknown signal: ' + signal);\n\n  return constants[signal];\n}\n\n\nfunction spawnSync() {\n  var opts = normalizeSpawnArguments.apply(null, arguments);\n\n  var options = opts.options;\n\n  var i;\n\n  options.file = opts.file;\n  options.args = opts.args;\n\n  if (options.killSignal)\n    options.killSignal = lookupSignal(options.killSignal);\n\n  options.stdio = _validateStdio(options.stdio || 'pipe', true).stdio;\n\n  if (options.input) {\n    var stdin = options.stdio[0] = util._extend({}, options.stdio[0]);\n    stdin.input = options.input;\n  }\n\n  // We may want to pass data in on any given fd, ensure it is a valid buffer\n  for (i = 0; i < options.stdio.length; i++) {\n    var input = options.stdio[i] && options.stdio[i].input;\n    if (input != null) {\n      var pipe = options.stdio[i] = util._extend({}, options.stdio[i]);\n      if (Buffer.isBuffer(input))\n        pipe.input = input;\n      else if (util.isString(input))\n        pipe.input = new Buffer(input, options.encoding);\n      else\n        throw new TypeError(util.format(\n            'stdio[%d] should be Buffer or string not %s',\n            i,\n            typeof input));\n    }\n  }\n\n  if (!spawn_sync)\n    spawn_sync = process.binding('spawn_sync');\n\n  var result = spawn_sync.spawn(options);\n\n  if (result.output && options.encoding) {\n    for (i = 0; i < result.output.length; i++) {\n      if (!result.output[i])\n        continue;\n      result.output[i] = result.output[i].toString(options.encoding);\n    }\n  }\n\n  result.stdout = result.output && result.output[1];\n  result.stderr = result.output && result.output[2];\n\n  if (result.error)\n    result.error = errnoException(result.error, 'spawnSync');\n\n  util._extend(result, opts);\n\n  return result;\n}\nexports.spawnSync = spawnSync;\n\n\nfunction checkExecSyncError(ret) {\n  if (ret.error || ret.status !== 0) {\n    var err = ret.error;\n    ret.error = null;\n\n    if (!err) {\n      var cmd = ret.cmd ? ret.cmd : ret.args.join(' ');\n      err = new Error(util.format('Command failed: %s\\n%s',\n                                  cmd,\n                                  ret.stderr.toString()));\n    }\n\n    util._extend(err, ret);\n    return err;\n  }\n\n  return false;\n}\n\n\nfunction execFileSync() {\n  var opts = normalizeSpawnArguments.apply(null, arguments);\n  var inheritStderr = !!!opts.options.stdio;\n\n  var ret = spawnSync(opts.file, opts.args.slice(1), opts.options);\n\n  if (inheritStderr)\n    process.stderr.write(ret.stderr);\n\n  var err = checkExecSyncError(ret);\n\n  if (err)\n    throw err;\n  else\n    return ret.stdout;\n}\nexports.execFileSync = execFileSync;\n\n\nfunction execSync() {\n  var opts = normalizeExecArgs.apply(null, arguments);\n  var inheritStderr = opts.options ? !!!opts.options.stdio : true;\n\n  var ret = spawnSync(opts.file, opts.args, opts.options);\n  ret.cmd = opts.cmd;\n\n  if (inheritStderr)\n    process.stderr.write(ret.stderr);\n\n  var err = checkExecSyncError(ret);\n\n  if (err)\n    throw err;\n  else\n    return ret.stdout;\n}\nexports.execSync = execSync;\n",
  @"// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar EventEmitter = require('events').EventEmitter;\nvar assert = require('assert');\nvar dgram = require('dgram');\nvar fork = require('child_process').fork;\nvar net = require('net');\nvar util = require('util');\nvar SCHED_NONE = 1;\nvar SCHED_RR = 2;\n\nvar cluster = new EventEmitter;\nmodule.exports = cluster;\ncluster.Worker = Worker;\ncluster.isWorker = ('NODE_UNIQUE_ID' in process.env);\ncluster.isMaster = (cluster.isWorker === false);\n\n\nfunction Worker() {\n  if (!(this instanceof Worker)) return new Worker;\n  EventEmitter.call(this);\n  this.suicide = undefined;\n  this.state = 'none';\n  this.id = 0;\n}\nutil.inherits(Worker, EventEmitter);\n\nWorker.prototype.kill = function() {\n  this.destroy.apply(this, arguments);\n};\n\nWorker.prototype.send = function() {\n  this.process.send.apply(this.process, arguments);\n};\n\n// Master/worker specific methods are defined in the *Init() functions.\n\nfunction SharedHandle(key, address, port, addressType, backlog, fd) {\n  this.key = key;\n  this.workers = [];\n  this.handle = null;\n  this.errno = 0;\n\n  // FIXME(bnoordhuis) Polymorphic return type for lack of a better solution.\n  var rval;\n  if (addressType === 'udp4' || addressType === 'udp6')\n    rval = dgram._createSocketHandle(address, port, addressType, fd);\n  else\n    rval = net._createServerHandle(address, port, addressType, fd);\n\n  if (util.isNumber(rval))\n    this.errno = rval;\n  else\n    this.handle = rval;\n}\n\nSharedHandle.prototype.add = function(worker, send) {\n  assert(this.workers.indexOf(worker) === -1);\n  this.workers.push(worker);\n  send(this.errno, null, this.handle);\n};\n\nSharedHandle.prototype.remove = function(worker) {\n  var index = this.workers.indexOf(worker);\n  assert(index !== -1);\n  this.workers.splice(index, 1);\n  if (this.workers.length !== 0) return false;\n  this.handle.close();\n  this.handle = null;\n  return true;\n};\n\n\n// Start a round-robin server. Master accepts connections and distributes\n// them over the workers.\nfunction RoundRobinHandle(key, address, port, addressType, backlog, fd) {\n  this.key = key;\n  this.all = {};\n  this.free = [];\n  this.handles = [];\n  this.handle = null;\n  this.server = net.createServer(assert.fail);\n\n  if (fd >= 0)\n    this.server.listen({ fd: fd });\n  else if (port >= 0)\n    this.server.listen(port, address);\n  else\n    this.server.listen(address);  // UNIX socket path.\n\n  var self = this;\n  this.server.once('listening', function() {\n    self.handle = self.server._handle;\n    self.handle.onconnection = self.distribute.bind(self);\n    self.server._handle = null;\n    self.server = null;\n  });\n}\n\nRoundRobinHandle.prototype.add = function(worker, send) {\n  assert(worker.id in this.all === false);\n  this.all[worker.id] = worker;\n\n  var self = this;\n  function done() {\n    if (self.handle.getsockname) {\n      var out = {};\n      var err = self.handle.getsockname(out);\n      // TODO(bnoordhuis) Check err.\n      send(null, { sockname: out }, null);\n    }\n    else {\n      send(null, null, null);  // UNIX socket.\n    }\n    self.handoff(worker);  // In case there are connections pending.\n  }\n\n  if (util.isNull(this.server)) return done();\n  // Still busy binding.\n  this.server.once('listening', done);\n  this.server.once('error', function(err) {\n    // Hack: translate 'EADDRINUSE' error string back to numeric error code.\n    // It works but ideally we'd have some backchannel between the net and\n    // cluster modules for stuff like this.\n    var errno = process.binding('uv')['UV_' + err.errno];\n    send(errno, null);\n  });\n};\n\nRoundRobinHandle.prototype.remove = function(worker) {\n  if (worker.id in this.all === false) return false;\n  delete this.all[worker.id];\n  var index = this.free.indexOf(worker);\n  if (index !== -1) this.free.splice(index, 1);\n  if (Object.getOwnPropertyNames(this.all).length !== 0) return false;\n  for (var handle; handle = this.handles.shift(); handle.close());\n  this.handle.close();\n  this.handle = null;\n  return true;\n};\n\nRoundRobinHandle.prototype.distribute = function(err, handle) {\n  this.handles.push(handle);\n  var worker = this.free.shift();\n  if (worker) this.handoff(worker);\n};\n\nRoundRobinHandle.prototype.handoff = function(worker) {\n  if (worker.id in this.all === false) {\n    return;  // Worker is closing (or has closed) the server.\n  }\n  var handle = this.handles.shift();\n  if (util.isUndefined(handle)) {\n    this.free.push(worker);  // Add to ready queue again.\n    return;\n  }\n  var message = { act: 'newconn', key: this.key };\n  var self = this;\n  sendHelper(worker.process, message, handle, function(reply) {\n    if (reply.accepted)\n      handle.close();\n    else\n      self.distribute(0, handle);  // Worker is shutting down. Send to another.\n    self.handoff(worker);\n  });\n};\n\n\nif (cluster.isMaster)\n  masterInit();\nelse\n  workerInit();\n\n\nfunction createWorkerExecArgv(masterExecArgv, worker) {\n  var args = masterExecArgv.slice();\n  var debugPort = process.debugPort + worker.id;\n  var hasDebugArg = false;\n\n  for (var i = 0; i < args.length; i++) {\n    var match = args[i].match(/^(--debug|--debug-brk)(=\\d+)?$/);\n    if (!match) continue;\n    args[i] = match[1] + '=' + debugPort;\n    hasDebugArg = true;\n  }\n\n  if (!hasDebugArg)\n    args = ['--debug-port=' + debugPort].concat(args);\n\n  return args;\n}\n\n\nfunction masterInit() {\n  cluster.workers = {};\n\n  var intercom = new EventEmitter;\n  cluster.settings = {};\n\n  // XXX(bnoordhuis) Fold cluster.schedulingPolicy into cluster.settings?\n  var schedulingPolicy = {\n    'none': SCHED_NONE,\n    'rr': SCHED_RR\n  }[process.env.NODE_CLUSTER_SCHED_POLICY];\n\n  if (util.isUndefined(schedulingPolicy)) {\n    // FIXME Round-robin doesn't perform well on Windows right now due to the\n    // way IOCP is wired up. Bert is going to fix that, eventually.\n    schedulingPolicy = (process.platform === 'win32') ? SCHED_NONE : SCHED_RR;\n  }\n\n  cluster.schedulingPolicy = schedulingPolicy;\n  cluster.SCHED_NONE = SCHED_NONE;  // Leave it to the operating system.\n  cluster.SCHED_RR = SCHED_RR;      // Master distributes connections.\n\n  // Keyed on address:port:etc. When a worker dies, we walk over the handles\n  // and remove() the worker from each one. remove() may do a linear scan\n  // itself so we might end up with an O(n*m) operation. Ergo, FIXME.\n  var handles = {};\n\n  var initialized = false;\n  cluster.setupMaster = function(options) {\n    if (initialized === true) return;\n    initialized = true;\n    var settings = {\n      args: process.argv.slice(2),\n      exec: process.argv[1],\n      execArgv: process.execArgv,\n      silent: false\n    };\n    settings = util._extend(settings, options || {});\n    // Tell V8 to write profile data for each process to a separate file.\n    // Without --logfile=v8-%p.log, everything ends up in a single, unusable\n    // file. (Unusable because what V8 logs are memory addresses and each\n    // process has its own memory mappings.)\n    if (settings.execArgv.some(function(s) { return /^--prof/.test(s); }) &&\n        !settings.execArgv.some(function(s) { return /^--logfile=/.test(s); }))\n    {\n      settings.execArgv = settings.execArgv.concat(['--logfile=v8-%p.log']);\n    }\n    schedulingPolicy = cluster.schedulingPolicy;  // Freeze policy.\n    assert(schedulingPolicy === SCHED_NONE || schedulingPolicy === SCHED_RR,\n           'Bad cluster.schedulingPolicy: ' + schedulingPolicy);\n    cluster.settings = settings;\n\n    process.on('internalMessage', function(message) {\n      if (message.cmd !== 'NODE_DEBUG_ENABLED') return;\n      var key;\n      for (key in cluster.workers)\n        process._debugProcess(cluster.workers[key].process.pid);\n    });\n\n    process.nextTick(function() {\n      cluster.emit('setup');\n    });\n  };\n\n  var ids = 0;\n  cluster.fork = function(env) {\n    cluster.setupMaster();\n    var worker = new Worker;\n    worker.id = ++ids;\n    var workerEnv = util._extend({}, process.env);\n    workerEnv = util._extend(workerEnv, env);\n    workerEnv.NODE_UNIQUE_ID = '' + worker.id;\n    worker.process = fork(cluster.settings.exec, cluster.settings.args, {\n      env: workerEnv,\n      silent: cluster.settings.silent,\n      execArgv: createWorkerExecArgv(cluster.settings.execArgv, worker),\n      gid: cluster.settings.gid,\n      uid: cluster.settings.uid\n    });\n    worker.process.once('exit', function(exitCode, signalCode) {\n      worker.suicide = !!worker.suicide;\n      worker.state = 'dead';\n      worker.emit('exit', exitCode, signalCode);\n      cluster.emit('exit', worker, exitCode, signalCode);\n      delete cluster.workers[worker.id];\n    });\n    worker.process.once('disconnect', function() {\n      worker.suicide = !!worker.suicide;\n      worker.state = 'disconnected';\n      worker.emit('disconnect');\n      cluster.emit('disconnect', worker);\n      delete cluster.workers[worker.id];\n    });\n    worker.process.on('error', worker.emit.bind(worker, 'error'));\n    worker.process.on('message', worker.emit.bind(worker, 'message'));\n    worker.process.on('internalMessage', internal(worker, onmessage));\n    process.nextTick(function() {\n      cluster.emit('fork', worker);\n    });\n    cluster.workers[worker.id] = worker;\n    return worker;\n  };\n\n  cluster.disconnect = function(cb) {\n    var workers = Object.keys(cluster.workers);\n    if (workers.length === 0) {\n      process.nextTick(intercom.emit.bind(intercom, 'disconnect'));\n    } else {\n      for (var key in workers) {\n        key = workers[key];\n        cluster.workers[key].disconnect();\n      }\n    }\n    if (cb) intercom.once('disconnect', cb);\n  };\n\n  cluster.on('disconnect', function(worker) {\n    delete cluster.workers[worker.id];\n    for (var key in handles) {\n      var handle = handles[key];\n      if (handle.remove(worker)) delete handles[key];\n    }\n    if (Object.keys(cluster.workers).length === 0) {\n      assert(Object.keys(handles).length === 0, 'Resource leak detected.');\n      intercom.emit('disconnect');\n    }\n  });\n\n  Worker.prototype.disconnect = function() {\n    this.suicide = true;\n    send(this, { act: 'disconnect' });\n  };\n\n  Worker.prototype.destroy = function(signo) {\n    signo = signo || 'SIGTERM';\n    var proc = this.process;\n    if (proc.connected) {\n      this.once('disconnect', proc.kill.bind(proc, signo));\n      this.disconnect();\n      return;\n    }\n    proc.kill(signo);\n  };\n\n  function onmessage(message, handle) {\n    var worker = this;\n    if (message.act === 'online')\n      online(worker);\n    else if (message.act === 'queryServer')\n      queryServer(worker, message);\n    else if (message.act === 'listening')\n      listening(worker, message);\n    else if (message.act === 'suicide')\n      worker.suicide = true;\n    else if (message.act === 'close')\n      close(worker, message);\n  }\n\n  function online(worker) {\n    worker.state = 'online';\n    worker.emit('online');\n    cluster.emit('online', worker);\n  }\n\n  function queryServer(worker, message) {\n    var args = [message.address,\n                message.port,\n                message.addressType,\n                message.fd];\n    var key = args.join(':');\n    var handle = handles[key];\n    if (util.isUndefined(handle)) {\n      var constructor = RoundRobinHandle;\n      // UDP is exempt from round-robin connection balancing for what should\n      // be obvious reasons: it's connectionless. There is nothing to send to\n      // the workers except raw datagrams and that's pointless.\n      if (schedulingPolicy !== SCHED_RR ||\n          message.addressType === 'udp4' ||\n          message.addressType === 'udp6') {\n        constructor = SharedHandle;\n      }\n      handles[key] = handle = new constructor(key,\n                                              message.address,\n                                              message.port,\n                                              message.addressType,\n                                              message.backlog,\n                                              message.fd);\n    }\n    if (!handle.data) handle.data = message.data;\n\n    // Set custom server data\n    handle.add(worker, function(errno, reply, handle) {\n      reply = util._extend({\n        errno: errno,\n        key: key,\n        ack: message.seq,\n        data: handles[key].data\n      }, reply);\n      if (errno) delete handles[key];  // Gives other workers a chance to retry.\n      send(worker, reply, handle);\n    });\n  }\n\n  function listening(worker, message) {\n    var info = {\n      addressType: message.addressType,\n      address: message.address,\n      port: message.port,\n      fd: message.fd\n    };\n    worker.state = 'listening';\n    worker.emit('listening', info);\n    cluster.emit('listening', worker, info);\n  }\n\n  // Round-robin only. Server in worker is closing, remove from list.\n  function close(worker, message) {\n    var key = message.key;\n    var handle = handles[key];\n    if (handle.remove(worker)) delete handles[key];\n  }\n\n  function send(worker, message, handle, cb) {\n    sendHelper(worker.process, message, handle, cb);\n  }\n}\n\n\nfunction workerInit() {\n  var handles = {};\n\n  // Called from src/node.js\n  cluster._setupWorker = function() {\n    var worker = new Worker;\n    cluster.worker = worker;\n    worker.id = +process.env.NODE_UNIQUE_ID | 0;\n    worker.state = 'online';\n    worker.process = process;\n    process.once('disconnect', function() {\n      if (!worker.suicide) {\n        // Unexpected disconnect, master exited, or some such nastiness, so\n        // worker exits immediately.\n        process.exit(0);\n      }\n    });\n    process.on('internalMessage', internal(worker, onmessage));\n    send({ act: 'online' });\n    function onmessage(message, handle) {\n      if (message.act === 'newconn')\n        onconnection(message, handle);\n      else if (message.act === 'disconnect')\n        worker.disconnect();\n    }\n  };\n\n  // obj is a net#Server or a dgram#Socket object.\n  cluster._getServer = function(obj, address, port, addressType, fd, cb) {\n    var message = {\n      addressType: addressType,\n      address: address,\n      port: port,\n      act: 'queryServer',\n      fd: fd,\n      data: null\n    };\n    // Set custom data on handle (i.e. tls tickets key)\n    if (obj._getServerData) message.data = obj._getServerData();\n    send(message, function(reply, handle) {\n      if (obj._setServerData) obj._setServerData(reply.data);\n\n      if (handle)\n        shared(reply, handle, cb);  // Shared listen socket.\n      else\n        rr(reply, cb);              // Round-robin.\n    });\n    obj.once('listening', function() {\n      cluster.worker.state = 'listening';\n      var address = obj.address();\n      message.act = 'listening';\n      message.port = address && address.port || port;\n      send(message);\n    });\n  };\n\n  // Shared listen socket.\n  function shared(message, handle, cb) {\n    var key = message.key;\n    // Monkey-patch the close() method so we can keep track of when it's\n    // closed. Avoids resource leaks when the handle is short-lived.\n    var close = handle.close;\n    handle.close = function() {\n      delete handles[key];\n      return close.apply(this, arguments);\n    };\n    assert(util.isUndefined(handles[key]));\n    handles[key] = handle;\n    cb(message.errno, handle);\n  }\n\n  // Round-robin. Master distributes handles across workers.\n  function rr(message, cb) {\n    if (message.errno)\n      return cb(message.errno, null);\n\n    var key = message.key;\n    function listen(backlog) {\n      // TODO(bnoordhuis) Send a message to the master that tells it to\n      // update the backlog size. The actual backlog should probably be\n      // the largest requested size by any worker.\n      return 0;\n    }\n\n    function close() {\n      // lib/net.js treats server._handle.close() as effectively synchronous.\n      // That means there is a time window between the call to close() and\n      // the ack by the master process in which we can still receive handles.\n      // onconnection() below handles that by sending those handles back to\n      // the master.\n      if (util.isUndefined(key)) return;\n      send({ act: 'close', key: key });\n      delete handles[key];\n      key = undefined;\n    }\n\n    function getsockname(out) {\n      if (key) util._extend(out, message.sockname);\n      return 0;\n    }\n\n    // Faux handle. Mimics a TCPWrap with just enough fidelity to get away\n    // with it. Fools net.Server into thinking that it's backed by a real\n    // handle.\n    var handle = {\n      close: close,\n      listen: listen\n    };\n    if (message.sockname) {\n      handle.getsockname = getsockname;  // TCP handles only.\n    }\n    assert(util.isUndefined(handles[key]));\n    handles[key] = handle;\n    cb(0, handle);\n  }\n\n  // Round-robin connection.\n  function onconnection(message, handle) {\n    var key = message.key;\n    var server = handles[key];\n    var accepted = !util.isUndefined(server);\n    send({ ack: message.seq, accepted: accepted });\n    if (accepted) server.onconnection(0, handle);\n  }\n\n  Worker.prototype.disconnect = function() {\n    this.suicide = true;\n    for (var key in handles) {\n      var handle = handles[key];\n      delete handles[key];\n      handle.close();\n    }\n    process.disconnect();\n  };\n\n  Worker.prototype.destroy = function() {\n    this.suicide = true;\n    if (!process.connected) process.exit(0);\n    var exit = process.exit.bind(null, 0);\n    send({ act: 'suicide' }, exit);\n    process.once('disconnect', exit);\n    process.disconnect();\n  };\n\n  function send(message, cb) {\n    sendHelper(process, message, null, cb);\n  }\n}\n\n\nvar seq = 0;\nvar callbacks = {};\nfunction sendHelper(proc, message, handle, cb) {\n  // Mark message as internal. See INTERNAL_PREFIX in lib/child_process.js\n  message = util._extend({ cmd: 'NODE_CLUSTER' }, message);\n  if (cb) callbacks[seq] = cb;\n  message.seq = seq;\n  seq += 1;\n  proc.send(message, handle);\n}\n\n\n// Returns an internalMessage listener that hands off normal messages\n// to the callback but intercepts and redirects ACK messages.\nfunction internal(worker, cb) {\n  return function(message, handle) {\n    if (message.cmd !== 'NODE_CLUSTER') return;\n    var fn = cb;\n    if (!util.isUndefined(message.ack)) {\n      fn = callbacks[message.ack];\n      delete callbacks[message.ack];\n    }\n    fn.apply(worker, arguments);\n  };\n}\n",
  @"// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar util = require('util');\n\nfunction Console(stdout, stderr) {\n  if (!(this instanceof Console)) {\n    return new Console(stdout, stderr);\n  }\n  if (!stdout || !util.isFunction(stdout.write)) {\n    throw new TypeError('Console expects a writable stream instance');\n  }\n  if (!stderr) {\n    stderr = stdout;\n  }\n  var prop = {\n    writable: true,\n    enumerable: false,\n    configurable: true\n  };\n  prop.value = stdout;\n  Object.defineProperty(this, '_stdout', prop);\n  prop.value = stderr;\n  Object.defineProperty(this, '_stderr', prop);\n  prop.value = {};\n  Object.defineProperty(this, '_times', prop);\n\n  // bind the prototype functions to this Console instance\n  Object.keys(Console.prototype).forEach(function(k) {\n    this[k] = this[k].bind(this);\n  }, this);\n}\n\nConsole.prototype.log = function() {\n  this._stdout.write(util.format.apply(this, arguments) + '\\n');\n};\n\n\nConsole.prototype.info = Console.prototype.log;\n\n\nConsole.prototype.warn = function() {\n  this._stderr.write(util.format.apply(this, arguments) + '\\n');\n};\n\n\nConsole.prototype.error = Console.prototype.warn;\n\n\nConsole.prototype.dir = function(object, options) {\n  this._stdout.write(util.inspect(object, util._extend({\n    customInspect: false\n  }, options)) + '\\n');\n};\n\n\nConsole.prototype.time = function(label) {\n  this._times[label] = Date.now();\n};\n\n\nConsole.prototype.timeEnd = function(label) {\n  var time = this._times[label];\n  if (!time) {\n    throw new Error('No such label: ' + label);\n  }\n  var duration = Date.now() - time;\n  this.log('%s: %dms', label, duration);\n};\n\n\nConsole.prototype.trace = function() {\n  // TODO probably can to do this better with V8's debug object once that is\n  // exposed.\n  var err = new Error;\n  err.name = 'Trace';\n  err.message = util.format.apply(this, arguments);\n  Error.captureStackTrace(err, arguments.callee);\n  this.error(err.stack);\n};\n\n\nConsole.prototype.assert = function(expression) {\n  if (!expression) {\n    var arr = Array.prototype.slice.call(arguments, 1);\n    require('assert').ok(false, util.format.apply(this, arr));\n  }\n};\n\n\nmodule.exports = new Console(process.stdout, process.stderr);\nmodule.exports.Console = Console;\n",
  @"// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nmodule.exports = process.binding('constants');\n",
  @"// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Note: In 0.8 and before, crypto functions all defaulted to using\n// binary-encoded strings rather than buffers.\n\nexports.DEFAULT_ENCODING = 'buffer';\n\ntry {\n  var binding = process.binding('crypto');\n  var randomBytes = binding.randomBytes;\n  var pseudoRandomBytes = binding.pseudoRandomBytes;\n  var getCiphers = binding.getCiphers;\n  var getHashes = binding.getHashes;\n} catch (e) {\n  throw new Error('node.js not compiled with openssl crypto support.');\n}\n\nvar constants = require('constants');\nvar stream = require('stream');\nvar util = require('util');\n\nvar DH_GENERATOR = 2;\n\n// This is here because many functions accepted binary strings without\n// any explicit encoding in older versions of node, and we don't want\n// to break them unnecessarily.\nfunction toBuf(str, encoding) {\n  encoding = encoding || 'binary';\n  if (util.isString(str)) {\n    if (encoding === 'buffer')\n      encoding = 'binary';\n    str = new Buffer(str, encoding);\n  }\n  return str;\n}\nexports._toBuf = toBuf;\n\n\nvar assert = require('assert');\nvar StringDecoder = require('string_decoder').StringDecoder;\n\n\nfunction LazyTransform(options) {\n  this._options = options;\n}\nutil.inherits(LazyTransform, stream.Transform);\n\n[\n  '_readableState',\n  '_writableState',\n  '_transformState'\n].forEach(function(prop, i, props) {\n  Object.defineProperty(LazyTransform.prototype, prop, {\n    get: function() {\n      stream.Transform.call(this, this._options);\n      this._writableState.decodeStrings = false;\n      this._writableState.defaultEncoding = 'binary';\n      return this[prop];\n    },\n    set: function(val) {\n      Object.defineProperty(this, prop, {\n        value: val,\n        enumerable: true,\n        configurable: true,\n        writable: true\n      });\n    },\n    configurable: true,\n    enumerable: true\n  });\n});\n\n\nexports.createHash = exports.Hash = Hash;\nfunction Hash(algorithm, options) {\n  if (!(this instanceof Hash))\n    return new Hash(algorithm, options);\n  this._handle = new binding.Hash(algorithm);\n  LazyTransform.call(this, options);\n}\n\nutil.inherits(Hash, LazyTransform);\n\nHash.prototype._transform = function(chunk, encoding, callback) {\n  this._handle.update(chunk, encoding);\n  callback();\n};\n\nHash.prototype._flush = function(callback) {\n  var encoding = this._readableState.encoding || 'buffer';\n  this.push(this._handle.digest(encoding), encoding);\n  callback();\n};\n\nHash.prototype.update = function(data, encoding) {\n  encoding = encoding || exports.DEFAULT_ENCODING;\n  if (encoding === 'buffer' && util.isString(data))\n    encoding = 'binary';\n  this._handle.update(data, encoding);\n  return this;\n};\n\n\nHash.prototype.digest = function(outputEncoding) {\n  outputEncoding = outputEncoding || exports.DEFAULT_ENCODING;\n  return this._handle.digest(outputEncoding);\n};\n\n\nexports.createHmac = exports.Hmac = Hmac;\n\nfunction Hmac(hmac, key, options) {\n  if (!(this instanceof Hmac))\n    return new Hmac(hmac, key, options);\n  this._handle = new binding.Hmac();\n  this._handle.init(hmac, toBuf(key));\n  LazyTransform.call(this, options);\n}\n\nutil.inherits(Hmac, LazyTransform);\n\nHmac.prototype.update = Hash.prototype.update;\nHmac.prototype.digest = Hash.prototype.digest;\nHmac.prototype._flush = Hash.prototype._flush;\nHmac.prototype._transform = Hash.prototype._transform;\n\n\nfunction getDecoder(decoder, encoding) {\n  if (encoding === 'utf-8') encoding = 'utf8';  // Normalize encoding.\n  decoder = decoder || new StringDecoder(encoding);\n  assert(decoder.encoding === encoding, 'Cannot change encoding');\n  return decoder;\n}\n\n\nexports.createCipher = exports.Cipher = Cipher;\nfunction Cipher(cipher, password, options) {\n  if (!(this instanceof Cipher))\n    return new Cipher(cipher, password, options);\n  this._handle = new binding.CipherBase(true);\n\n  this._handle.init(cipher, toBuf(password));\n  this._decoder = null;\n\n  LazyTransform.call(this, options);\n}\n\nutil.inherits(Cipher, LazyTransform);\n\nCipher.prototype._transform = function(chunk, encoding, callback) {\n  this.push(this._handle.update(chunk, encoding));\n  callback();\n};\n\nCipher.prototype._flush = function(callback) {\n  try {\n    this.push(this._handle.final());\n  } catch (e) {\n    callback(e);\n    return;\n  }\n  callback();\n};\n\nCipher.prototype.update = function(data, inputEncoding, outputEncoding) {\n  inputEncoding = inputEncoding || exports.DEFAULT_ENCODING;\n  outputEncoding = outputEncoding || exports.DEFAULT_ENCODING;\n\n  var ret = this._handle.update(data, inputEncoding);\n\n  if (outputEncoding && outputEncoding !== 'buffer') {\n    this._decoder = getDecoder(this._decoder, outputEncoding);\n    ret = this._decoder.write(ret);\n  }\n\n  return ret;\n};\n\n\nCipher.prototype.final = function(outputEncoding) {\n  outputEncoding = outputEncoding || exports.DEFAULT_ENCODING;\n  var ret = this._handle.final();\n\n  if (outputEncoding && outputEncoding !== 'buffer') {\n    this._decoder = getDecoder(this._decoder, outputEncoding);\n    ret = this._decoder.end(ret);\n  }\n\n  return ret;\n};\n\n\nCipher.prototype.setAutoPadding = function(ap) {\n  this._handle.setAutoPadding(ap);\n  return this;\n};\n\n\n\nexports.createCipheriv = exports.Cipheriv = Cipheriv;\nfunction Cipheriv(cipher, key, iv, options) {\n  if (!(this instanceof Cipheriv))\n    return new Cipheriv(cipher, key, iv, options);\n  this._handle = new binding.CipherBase(true);\n  this._handle.initiv(cipher, toBuf(key), toBuf(iv));\n  this._decoder = null;\n\n  LazyTransform.call(this, options);\n}\n\nutil.inherits(Cipheriv, LazyTransform);\n\nCipheriv.prototype._transform = Cipher.prototype._transform;\nCipheriv.prototype._flush = Cipher.prototype._flush;\nCipheriv.prototype.update = Cipher.prototype.update;\nCipheriv.prototype.final = Cipher.prototype.final;\nCipheriv.prototype.setAutoPadding = Cipher.prototype.setAutoPadding;\n\nCipheriv.prototype.getAuthTag = function() {\n  return this._handle.getAuthTag();\n};\n\n\nCipheriv.prototype.setAuthTag = function(tagbuf) {\n  this._handle.setAuthTag(tagbuf);\n};\n\nCipheriv.prototype.setAAD = function(aadbuf) {\n  this._handle.setAAD(aadbuf);\n};\n\n\nexports.createDecipher = exports.Decipher = Decipher;\nfunction Decipher(cipher, password, options) {\n  if (!(this instanceof Decipher))\n    return new Decipher(cipher, password, options);\n\n  this._handle = new binding.CipherBase(false);\n  this._handle.init(cipher, toBuf(password));\n  this._decoder = null;\n\n  LazyTransform.call(this, options);\n}\n\nutil.inherits(Decipher, LazyTransform);\n\nDecipher.prototype._transform = Cipher.prototype._transform;\nDecipher.prototype._flush = Cipher.prototype._flush;\nDecipher.prototype.update = Cipher.prototype.update;\nDecipher.prototype.final = Cipher.prototype.final;\nDecipher.prototype.finaltol = Cipher.prototype.final;\nDecipher.prototype.setAutoPadding = Cipher.prototype.setAutoPadding;\n\n\n\nexports.createDecipheriv = exports.Decipheriv = Decipheriv;\nfunction Decipheriv(cipher, key, iv, options) {\n  if (!(this instanceof Decipheriv))\n    return new Decipheriv(cipher, key, iv, options);\n\n  this._handle = new binding.CipherBase(false);\n  this._handle.initiv(cipher, toBuf(key), toBuf(iv));\n  this._decoder = null;\n\n  LazyTransform.call(this, options);\n}\n\nutil.inherits(Decipheriv, LazyTransform);\n\nDecipheriv.prototype._transform = Cipher.prototype._transform;\nDecipheriv.prototype._flush = Cipher.prototype._flush;\nDecipheriv.prototype.update = Cipher.prototype.update;\nDecipheriv.prototype.final = Cipher.prototype.final;\nDecipheriv.prototype.finaltol = Cipher.prototype.final;\nDecipheriv.prototype.setAutoPadding = Cipher.prototype.setAutoPadding;\nDecipheriv.prototype.getAuthTag = Cipheriv.prototype.getAuthTag;\nDecipheriv.prototype.setAuthTag = Cipheriv.prototype.setAuthTag;\nDecipheriv.prototype.setAAD = Cipheriv.prototype.setAAD;\n\n\n\nexports.createSign = exports.Sign = Sign;\nfunction Sign(algorithm, options) {\n  if (!(this instanceof Sign))\n    return new Sign(algorithm, options);\n  this._handle = new binding.Sign();\n  this._handle.init(algorithm);\n\n  stream.Writable.call(this, options);\n}\n\nutil.inherits(Sign, stream.Writable);\n\nSign.prototype._write = function(chunk, encoding, callback) {\n  this._handle.update(chunk, encoding);\n  callback();\n};\n\nSign.prototype.update = Hash.prototype.update;\n\nSign.prototype.sign = function(options, encoding) {\n  if (!options)\n    throw new Error('No key provided to sign');\n\n  var key = options.key || options;\n  var passphrase = options.passphrase || null;\n  var ret = this._handle.sign(toBuf(key), null, passphrase);\n\n  encoding = encoding || exports.DEFAULT_ENCODING;\n  if (encoding && encoding !== 'buffer')\n    ret = ret.toString(encoding);\n\n  return ret;\n};\n\n\n\nexports.createVerify = exports.Verify = Verify;\nfunction Verify(algorithm, options) {\n  if (!(this instanceof Verify))\n    return new Verify(algorithm, options);\n\n  this._handle = new binding.Verify;\n  this._handle.init(algorithm);\n\n  stream.Writable.call(this, options);\n}\n\nutil.inherits(Verify, stream.Writable);\n\nVerify.prototype._write = Sign.prototype._write;\nVerify.prototype.update = Sign.prototype.update;\n\nVerify.prototype.verify = function(object, signature, sigEncoding) {\n  sigEncoding = sigEncoding || exports.DEFAULT_ENCODING;\n  return this._handle.verify(toBuf(object), toBuf(signature, sigEncoding));\n};\n\n\n\nexports.createDiffieHellman = exports.DiffieHellman = DiffieHellman;\n\nfunction DiffieHellman(sizeOrKey, keyEncoding, generator, genEncoding) {\n  if (!(this instanceof DiffieHellman))\n    return new DiffieHellman(sizeOrKey, keyEncoding, generator, genEncoding);\n\n  if (keyEncoding) {\n    if (typeof keyEncoding !== 'string' ||\n        (!Buffer.isEncoding(keyEncoding) && keyEncoding !== 'buffer')) {\n      genEncoding = generator;\n      generator = keyEncoding;\n      keyEncoding = false;\n    }\n  }\n\n  keyEncoding = keyEncoding || exports.DEFAULT_ENCODING;\n  genEncoding = genEncoding || exports.DEFAULT_ENCODING;\n\n  if (typeof sizeOrKey !== 'number')\n    sizeOrKey = toBuf(sizeOrKey, keyEncoding);\n\n  if (!generator)\n    generator = DH_GENERATOR;\n  else if (typeof generator !== 'number')\n    generator = toBuf(generator, genEncoding);\n\n  this._handle = new binding.DiffieHellman(sizeOrKey, generator);\n  Object.defineProperty(this, 'verifyError', {\n    enumerable: true,\n    value: this._handle.verifyError,\n    writable: false\n  });\n}\n\n\nexports.DiffieHellmanGroup =\n    exports.createDiffieHellmanGroup =\n    exports.getDiffieHellman = DiffieHellmanGroup;\n\nfunction DiffieHellmanGroup(name) {\n  if (!(this instanceof DiffieHellmanGroup))\n    return new DiffieHellmanGroup(name);\n  this._handle = new binding.DiffieHellmanGroup(name);\n  Object.defineProperty(this, 'verifyError', {\n    enumerable: true,\n    value: this._handle.verifyError,\n    writable: false\n  });\n}\n\n\nDiffieHellmanGroup.prototype.generateKeys =\n    DiffieHellman.prototype.generateKeys =\n    dhGenerateKeys;\n\nfunction dhGenerateKeys(encoding) {\n  var keys = this._handle.generateKeys();\n  encoding = encoding || exports.DEFAULT_ENCODING;\n  if (encoding && encoding !== 'buffer')\n    keys = keys.toString(encoding);\n  return keys;\n}\n\n\nDiffieHellmanGroup.prototype.computeSecret =\n    DiffieHellman.prototype.computeSecret =\n    dhComputeSecret;\n\nfunction dhComputeSecret(key, inEnc, outEnc) {\n  inEnc = inEnc || exports.DEFAULT_ENCODING;\n  outEnc = outEnc || exports.DEFAULT_ENCODING;\n  var ret = this._handle.computeSecret(toBuf(key, inEnc));\n  if (outEnc && outEnc !== 'buffer')\n    ret = ret.toString(outEnc);\n  return ret;\n}\n\n\nDiffieHellmanGroup.prototype.getPrime =\n    DiffieHellman.prototype.getPrime =\n    dhGetPrime;\n\nfunction dhGetPrime(encoding) {\n  var prime = this._handle.getPrime();\n  encoding = encoding || exports.DEFAULT_ENCODING;\n  if (encoding && encoding !== 'buffer')\n    prime = prime.toString(encoding);\n  return prime;\n}\n\n\nDiffieHellmanGroup.prototype.getGenerator =\n    DiffieHellman.prototype.getGenerator =\n    dhGetGenerator;\n\nfunction dhGetGenerator(encoding) {\n  var generator = this._handle.getGenerator();\n  encoding = encoding || exports.DEFAULT_ENCODING;\n  if (encoding && encoding !== 'buffer')\n    generator = generator.toString(encoding);\n  return generator;\n}\n\n\nDiffieHellmanGroup.prototype.getPublicKey =\n    DiffieHellman.prototype.getPublicKey =\n    dhGetPublicKey;\n\nfunction dhGetPublicKey(encoding) {\n  var key = this._handle.getPublicKey();\n  encoding = encoding || exports.DEFAULT_ENCODING;\n  if (encoding && encoding !== 'buffer')\n    key = key.toString(encoding);\n  return key;\n}\n\n\nDiffieHellmanGroup.prototype.getPrivateKey =\n    DiffieHellman.prototype.getPrivateKey =\n    dhGetPrivateKey;\n\nfunction dhGetPrivateKey(encoding) {\n  var key = this._handle.getPrivateKey();\n  encoding = encoding || exports.DEFAULT_ENCODING;\n  if (encoding && encoding !== 'buffer')\n    key = key.toString(encoding);\n  return key;\n}\n\n\nDiffieHellman.prototype.setPublicKey = function(key, encoding) {\n  encoding = encoding || exports.DEFAULT_ENCODING;\n  this._handle.setPublicKey(toBuf(key, encoding));\n  return this;\n};\n\n\nDiffieHellman.prototype.setPrivateKey = function(key, encoding) {\n  encoding = encoding || exports.DEFAULT_ENCODING;\n  this._handle.setPrivateKey(toBuf(key, encoding));\n  return this;\n};\n\n\n\nexports.pbkdf2 = function(password,\n                          salt,\n                          iterations,\n                          keylen,\n                          digest,\n                          callback) {\n  if (util.isFunction(digest)) {\n    callback = digest;\n    digest = undefined;\n  }\n\n  if (!util.isFunction(callback))\n    throw new Error('No callback provided to pbkdf2');\n\n  return pbkdf2(password, salt, iterations, keylen, digest, callback);\n};\n\n\nexports.pbkdf2Sync = function(password, salt, iterations, keylen, digest) {\n  return pbkdf2(password, salt, iterations, keylen, digest);\n};\n\n\nfunction pbkdf2(password, salt, iterations, keylen, digest, callback) {\n  password = toBuf(password);\n  salt = toBuf(salt);\n\n  if (exports.DEFAULT_ENCODING === 'buffer')\n    return binding.PBKDF2(password, salt, iterations, keylen, digest, callback);\n\n  // at this point, we need to handle encodings.\n  var encoding = exports.DEFAULT_ENCODING;\n  if (callback) {\n    function next(er, ret) {\n      if (ret)\n        ret = ret.toString(encoding);\n      callback(er, ret);\n    }\n    binding.PBKDF2(password, salt, iterations, keylen, digest, next);\n  } else {\n    var ret = binding.PBKDF2(password, salt, iterations, keylen, digest);\n    return ret.toString(encoding);\n  }\n}\n\n\nexports.Certificate = Certificate;\n\nfunction Certificate() {\n  if (!(this instanceof Certificate))\n    return new Certificate();\n\n  this._handle = new binding.Certificate();\n}\n\n\nCertificate.prototype.verifySpkac = function(object) {\n  return this._handle.verifySpkac(object);\n};\n\n\nCertificate.prototype.exportPublicKey = function(object, encoding) {\n  return this._handle.exportPublicKey(toBuf(object, encoding));\n};\n\n\nCertificate.prototype.exportChallenge = function(object, encoding) {\n  return this._handle.exportChallenge(toBuf(object, encoding));\n};\n\n\nexports.setEngine = function setEngine(id, flags) {\n  if (!util.isString(id))\n    throw new TypeError('id should be a string');\n\n  if (flags && !util.isNumber(flags))\n    throw new TypeError('flags should be a number, if present');\n  flags = flags >>> 0;\n\n  // Use provided engine for everything by default\n  if (flags === 0)\n    flags = constants.ENGINE_METHOD_ALL;\n\n  return binding.setEngine(id, flags);\n};\n\nexports.randomBytes = randomBytes;\nexports.pseudoRandomBytes = pseudoRandomBytes;\n\nexports.rng = randomBytes;\nexports.prng = pseudoRandomBytes;\n\n\nexports.getCiphers = function() {\n  return filterDuplicates(getCiphers.call(null, arguments));\n};\n\n\nexports.getHashes = function() {\n  return filterDuplicates(getHashes.call(null, arguments));\n\n};\n\n\nfunction filterDuplicates(names) {\n  // Drop all-caps names in favor of their lowercase aliases,\n  // for example, 'sha1' instead of 'SHA1'.\n  var ctx = {};\n  names.forEach(function(name) {\n    var key = name;\n    if (/^[0-9A-Z\\-]+$/.test(key)) key = key.toLowerCase();\n    if (!ctx.hasOwnProperty(key) || ctx[key] < name)\n      ctx[key] = name;\n  });\n\n  return Object.getOwnPropertyNames(ctx).map(function(key) {\n    return ctx[key];\n  }).sort();\n}\n\n// Legacy API\nexports.__defineGetter__('createCredentials', util.deprecate(function() {\n  return require('tls').createSecureContext;\n}, 'createCredentials() is deprecated, use tls.createSecureContext instead'));\n\nexports.__defineGetter__('Credentials', util.deprecate(function() {\n  return require('tls').SecureContext;\n}, 'Credentials is deprecated, use tls.createSecureContext instead'));\n",
  @"// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar assert = require('assert');\nvar util = require('util');\nvar events = require('events');\nvar constants = require('constants');\n\nvar UDP = process.binding('udp_wrap').UDP;\n\nvar BIND_STATE_UNBOUND = 0;\nvar BIND_STATE_BINDING = 1;\nvar BIND_STATE_BOUND = 2;\n\n// lazily loaded\nvar cluster = null;\nvar dns = null;\n\nvar errnoException = util._errnoException;\n\nfunction lookup(address, family, callback) {\n  if (!dns)\n    dns = require('dns');\n\n  return dns.lookup(address, family, callback);\n}\n\n\nfunction lookup4(address, callback) {\n  return lookup(address || '0.0.0.0', 4, callback);\n}\n\n\nfunction lookup6(address, callback) {\n  return lookup(address || '::0', 6, callback);\n}\n\n\nfunction newHandle(type) {\n  if (type == 'udp4') {\n    var handle = new UDP;\n    handle.lookup = lookup4;\n    return handle;\n  }\n\n  if (type == 'udp6') {\n    var handle = new UDP;\n    handle.lookup = lookup6;\n    handle.bind = handle.bind6;\n    handle.send = handle.send6;\n    return handle;\n  }\n\n  if (type == 'unix_dgram')\n    throw new Error('unix_dgram sockets are not supported any more.');\n\n  throw new Error('Bad socket type specified. Valid types are: udp4, udp6');\n}\n\n\nexports._createSocketHandle = function(address, port, addressType, fd) {\n  // Opening an existing fd is not supported for UDP handles.\n  assert(!util.isNumber(fd) || fd < 0);\n\n  var handle = newHandle(addressType);\n\n  if (port || address) {\n    var err = handle.bind(address, port || 0, 0);\n    if (err) {\n      handle.close();\n      return err;\n    }\n  }\n\n  return handle;\n};\n\n\nfunction Socket(type, listener) {\n  events.EventEmitter.call(this);\n\n  if (typeof type === 'object') {\n    var options = type;\n    type = options.type;\n  }\n\n  var handle = newHandle(type);\n  handle.owner = this;\n\n  this._handle = handle;\n  this._receiving = false;\n  this._bindState = BIND_STATE_UNBOUND;\n  this.type = type;\n  this.fd = null; // compatibility hack\n\n  // If true - UV_UDP_REUSEADDR flag will be set\n  this._reuseAddr = options && options.reuseAddr;\n\n  if (util.isFunction(listener))\n    this.on('message', listener);\n}\nutil.inherits(Socket, events.EventEmitter);\nexports.Socket = Socket;\n\n\nexports.createSocket = function(type, listener) {\n  return new Socket(type, listener);\n};\n\n\nfunction startListening(socket) {\n  socket._handle.onmessage = onMessage;\n  // Todo: handle errors\n  socket._handle.recvStart();\n  socket._receiving = true;\n  socket._bindState = BIND_STATE_BOUND;\n  socket.fd = -42; // compatibility hack\n\n  socket.emit('listening');\n}\n\nfunction replaceHandle(self, newHandle) {\n\n  // Set up the handle that we got from master.\n  newHandle.lookup = self._handle.lookup;\n  newHandle.bind = self._handle.bind;\n  newHandle.send = self._handle.send;\n  newHandle.owner = self;\n\n  // Replace the existing handle by the handle we got from master.\n  self._handle.close();\n  self._handle = newHandle;\n}\n\nSocket.prototype.bind = function() {\n  var self = this;\n\n  self._healthCheck();\n\n  if (this._bindState != BIND_STATE_UNBOUND)\n    throw new Error('Socket is already bound');\n\n  this._bindState = BIND_STATE_BINDING;\n\n  if (util.isFunction(arguments[arguments.length - 1]))\n    self.once('listening', arguments[arguments.length - 1]);\n\n  var UDP = process.binding('udp_wrap').UDP;\n  if (arguments[0] instanceof UDP) {\n    replaceHandle(self, arguments[0]);\n    startListening(self);\n    return;\n  }\n\n  var port = arguments[0];\n  var address = arguments[1];\n  if (util.isFunction(address)) address = '';  // a.k.a. \"any address\"\n\n  // resolve address first\n  self._handle.lookup(address, function(err, ip) {\n    if (err) {\n      self._bindState = BIND_STATE_UNBOUND;\n      self.emit('error', err);\n      return;\n    }\n\n    if (!cluster)\n      cluster = require('cluster');\n\n    if (cluster.isWorker) {\n      cluster._getServer(self, ip, port, self.type, -1, function(err, handle) {\n        if (err) {\n          self.emit('error', errnoException(err, 'bind'));\n          self._bindState = BIND_STATE_UNBOUND;\n          return;\n        }\n\n        if (!self._handle)\n          // handle has been closed in the mean time.\n          return handle.close();\n\n        replaceHandle(self, handle);\n        startListening(self);\n      });\n\n    } else {\n      if (!self._handle)\n        return; // handle has been closed in the mean time\n\n      var flags = 0;\n      if (self._reuseAddr)\n        flags |= constants.UV_UDP_REUSEADDR;\n\n      var err = self._handle.bind(ip, port || 0, flags);\n      if (err) {\n        self.emit('error', errnoException(err, 'bind'));\n        self._bindState = BIND_STATE_UNBOUND;\n        // Todo: close?\n        return;\n      }\n\n      startListening(self);\n    }\n  });\n};\n\n\n// thin wrapper around `send`, here for compatibility with dgram_legacy.js\nSocket.prototype.sendto = function(buffer,\n                                   offset,\n                                   length,\n                                   port,\n                                   address,\n                                   callback) {\n  if (!util.isNumber(offset) || !util.isNumber(length))\n    throw new Error('send takes offset and length as args 2 and 3');\n\n  if (!util.isString(address))\n    throw new Error(this.type + ' sockets must send to port, address');\n\n  this.send(buffer, offset, length, port, address, callback);\n};\n\n\nSocket.prototype.send = function(buffer,\n                                 offset,\n                                 length,\n                                 port,\n                                 address,\n                                 callback) {\n  var self = this;\n\n  if (util.isString(buffer))\n    buffer = new Buffer(buffer);\n\n  if (!util.isBuffer(buffer))\n    throw new TypeError('First argument must be a buffer or string.');\n\n  offset = offset | 0;\n  if (offset < 0)\n    throw new RangeError('Offset should be >= 0');\n\n  if ((length == 0 && offset > buffer.length) ||\n      (length > 0 && offset >= buffer.length))\n    throw new RangeError('Offset into buffer too large');\n\n  // Sending a zero-length datagram is kind of pointless but it _is_\n  // allowed, hence check that length >= 0 rather than > 0.\n  length = length | 0;\n  if (length < 0)\n    throw new RangeError('Length should be >= 0');\n\n  if (offset + length > buffer.length)\n    throw new RangeError('Offset + length beyond buffer length');\n\n  port = port | 0;\n  if (port <= 0 || port > 65535)\n    throw new RangeError('Port should be > 0 and < 65536');\n\n  // Normalize callback so it's either a function or undefined but not anything\n  // else.\n  if (!util.isFunction(callback))\n    callback = undefined;\n\n  self._healthCheck();\n\n  if (self._bindState == BIND_STATE_UNBOUND)\n    self.bind(0, null);\n\n  // If the socket hasn't been bound yet, push the outbound packet onto the\n  // send queue and send after binding is complete.\n  if (self._bindState != BIND_STATE_BOUND) {\n    // If the send queue hasn't been initialized yet, do it, and install an\n    // event handler that flushes the send queue after binding is done.\n    if (!self._sendQueue) {\n      self._sendQueue = [];\n      self.once('listening', function() {\n        // Flush the send queue.\n        for (var i = 0; i < self._sendQueue.length; i++)\n          self.send.apply(self, self._sendQueue[i]);\n        self._sendQueue = undefined;\n      });\n    }\n    self._sendQueue.push([buffer, offset, length, port, address, callback]);\n    return;\n  }\n\n  self._handle.lookup(address, function(ex, ip) {\n    if (ex) {\n      if (callback) callback(ex);\n      self.emit('error', ex);\n    }\n    else if (self._handle) {\n      var req = { buffer: buffer, length: length };  // Keep reference alive.\n      if (callback) {\n        req.callback = callback;\n        req.oncomplete = afterSend;\n      }\n      var err = self._handle.send(req,\n                                  buffer,\n                                  offset,\n                                  length,\n                                  port,\n                                  ip,\n                                  !!callback);\n      if (err && callback) {\n        // don't emit as error, dgram_legacy.js compatibility\n        process.nextTick(function() {\n          callback(errnoException(err, 'send'));\n        });\n      }\n    }\n  });\n};\n\n\nfunction afterSend(err) {\n  this.callback(err ? errnoException(err, 'send') : null, this.length);\n}\n\n\nSocket.prototype.close = function() {\n  this._healthCheck();\n  this._stopReceiving();\n  this._handle.close();\n  this._handle = null;\n  this.emit('close');\n};\n\n\nSocket.prototype.address = function() {\n  this._healthCheck();\n\n  var out = {};\n  var err = this._handle.getsockname(out);\n  if (err) {\n    throw errnoException(err, 'getsockname');\n  }\n\n  return out;\n};\n\n\nSocket.prototype.setBroadcast = function(arg) {\n  var err = this._handle.setBroadcast(arg ? 1 : 0);\n  if (err) {\n    throw errnoException(err, 'setBroadcast');\n  }\n};\n\n\nSocket.prototype.setTTL = function(arg) {\n  if (!util.isNumber(arg)) {\n    throw new TypeError('Argument must be a number');\n  }\n\n  var err = this._handle.setTTL(arg);\n  if (err) {\n    throw errnoException(err, 'setTTL');\n  }\n\n  return arg;\n};\n\n\nSocket.prototype.setMulticastTTL = function(arg) {\n  if (!util.isNumber(arg)) {\n    throw new TypeError('Argument must be a number');\n  }\n\n  var err = this._handle.setMulticastTTL(arg);\n  if (err) {\n    throw errnoException(err, 'setMulticastTTL');\n  }\n\n  return arg;\n};\n\n\nSocket.prototype.setMulticastLoopback = function(arg) {\n  var err = this._handle.setMulticastLoopback(arg ? 1 : 0);\n  if (err) {\n    throw errnoException(err, 'setMulticastLoopback');\n  }\n\n  return arg; // 0.4 compatibility\n};\n\n\nSocket.prototype.addMembership = function(multicastAddress,\n                                          interfaceAddress) {\n  this._healthCheck();\n\n  if (!multicastAddress) {\n    throw new Error('multicast address must be specified');\n  }\n\n  var err = this._handle.addMembership(multicastAddress, interfaceAddress);\n  if (err) {\n    throw new errnoException(err, 'addMembership');\n  }\n};\n\n\nSocket.prototype.dropMembership = function(multicastAddress,\n                                           interfaceAddress) {\n  this._healthCheck();\n\n  if (!multicastAddress) {\n    throw new Error('multicast address must be specified');\n  }\n\n  var err = this._handle.dropMembership(multicastAddress, interfaceAddress);\n  if (err) {\n    throw new errnoException(err, 'dropMembership');\n  }\n};\n\n\nSocket.prototype._healthCheck = function() {\n  if (!this._handle)\n    throw new Error('Not running'); // error message from dgram_legacy.js\n};\n\n\nSocket.prototype._stopReceiving = function() {\n  if (!this._receiving)\n    return;\n\n  this._handle.recvStop();\n  this._receiving = false;\n  this.fd = null; // compatibility hack\n};\n\n\nfunction onMessage(nread, handle, buf, rinfo) {\n  var self = handle.owner;\n  if (nread < 0) {\n    return self.emit('error', errnoException(nread, 'recvmsg'));\n  }\n  rinfo.size = buf.length; // compatibility\n  self.emit('message', buf, rinfo);\n}\n\n\nSocket.prototype.ref = function() {\n  if (this._handle)\n    this._handle.ref();\n};\n\n\nSocket.prototype.unref = function() {\n  if (this._handle)\n    this._handle.unref();\n};\n",
  @"// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// 'Software'), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar net = require('net');\nvar util = require('util');\n\nvar cares = process.binding('cares_wrap');\nvar uv = process.binding('uv');\n\nvar isIp = net.isIP;\n\n\nfunction errnoException(err, syscall, hostname) {\n  // FIXME(bnoordhuis) Remove this backwards compatibility shite and pass\n  // the true error to the user. ENOTFOUND is not even a proper POSIX error!\n  if (err === uv.UV_EAI_MEMORY ||\n      err === uv.UV_EAI_NODATA ||\n      err === uv.UV_EAI_NONAME) {\n    err = 'ENOTFOUND';\n  }\n  var ex = null;\n  if (typeof err === 'string') {  // c-ares error code.\n    ex = new Error(syscall + ' ' + err);\n    ex.code = err;\n    ex.errno = err;\n    ex.syscall = syscall;\n  } else {\n    ex = util._errnoException(err, syscall);\n  }\n  if (hostname) {\n    ex.hostname = hostname;\n  }\n  return ex;\n}\n\n\n// c-ares invokes a callback either synchronously or asynchronously,\n// but the dns API should always invoke a callback asynchronously.\n//\n// This function makes sure that the callback is invoked asynchronously.\n// It returns a function that invokes the callback within nextTick().\n//\n// To avoid invoking unnecessary nextTick(), `immediately` property of\n// returned function should be set to true after c-ares returned.\n//\n// Usage:\n//\n// function someAPI(callback) {\n//   callback = makeAsync(callback);\n//   channel.someAPI(..., callback);\n//   callback.immediately = true;\n// }\nfunction makeAsync(callback) {\n  if (!util.isFunction(callback)) {\n    return callback;\n  }\n  return function asyncCallback() {\n    if (asyncCallback.immediately) {\n      // The API already returned, we can invoke the callback immediately.\n      callback.apply(null, arguments);\n    } else {\n      var args = arguments;\n      process.nextTick(function() {\n        callback.apply(null, args);\n      });\n    }\n  };\n}\n\n\nfunction onlookup(err, addresses) {\n  if (err) {\n    return this.callback(errnoException(err, 'getaddrinfo', this.hostname));\n  }\n  if (this.family) {\n    this.callback(null, addresses[0], this.family);\n  } else {\n    this.callback(null, addresses[0], addresses[0].indexOf(':') >= 0 ? 6 : 4);\n  }\n}\n\n\n// Easy DNS A/AAAA look up\n// lookup(hostname, [family,] callback)\nexports.lookup = function(hostname, family, callback) {\n  // parse arguments\n  if (arguments.length === 2) {\n    callback = family;\n    family = 0;\n  } else if (!family) {\n    family = 0;\n  } else {\n    family = +family;\n    if (family !== 4 && family !== 6) {\n      throw new Error('invalid argument: `family` must be 4 or 6');\n    }\n  }\n  callback = makeAsync(callback);\n\n  if (!hostname) {\n    callback(null, null, family === 6 ? 6 : 4);\n    return {};\n  }\n\n  var matchedFamily = net.isIP(hostname);\n  if (matchedFamily) {\n    callback(null, hostname, matchedFamily);\n    return {};\n  }\n\n  var req = {\n    callback: callback,\n    family: family,\n    hostname: hostname,\n    oncomplete: onlookup\n  };\n\n  var err = cares.getaddrinfo(req, hostname, family);\n  if (err) {\n    callback(errnoException(err, 'getaddrinfo', hostname));\n    return {};\n  }\n\n  callback.immediately = true;\n  return req;\n};\n\n\nfunction onlookupservice(err, host, service) {\n  if (err)\n    return this.callback(errnoException(err, 'getnameinfo', this.host));\n\n  this.callback(null, host, service);\n}\n\n\n// lookupService(address, port, callback)\nexports.lookupService = function(host, port, callback) {\n  if (arguments.length !== 3)\n    throw new Error('invalid arguments');\n\n  if (cares.isIP(host) === 0)\n    throw new TypeError('host needs to be a valid IP address');\n\n  callback = makeAsync(callback);\n\n  var req = {\n    callback: callback,\n    host: host,\n    port: port,\n    oncomplete: onlookupservice\n  };\n  var err = cares.getnameinfo(req, host, port);\n  if (err) throw errnoException(err, 'getnameinfo', host);\n\n  callback.immediately = true;\n  return req;\n};\n\n\nfunction onresolve(err, result) {\n  if (err)\n    this.callback(errnoException(err, this.bindingName, this.hostname));\n  else\n    this.callback(null, result);\n}\n\n\nfunction resolver(bindingName) {\n  var binding = cares[bindingName];\n\n  return function query(name, callback) {\n    if (!util.isString(name)) {\n      throw new Error('Name must be a string');\n    } else if (!util.isFunction(callback)) {\n      throw new Error('Callback must be a function');\n    }\n\n    callback = makeAsync(callback);\n    var req = {\n      bindingName: bindingName,\n      callback: callback,\n      hostname: name,\n      oncomplete: onresolve\n    };\n    var err = binding(req, name);\n    if (err) throw errnoException(err, bindingName);\n    callback.immediately = true;\n    return req;\n  }\n}\n\n\nvar resolveMap = {};\nexports.resolve4 = resolveMap.A = resolver('queryA');\nexports.resolve6 = resolveMap.AAAA = resolver('queryAaaa');\nexports.resolveCname = resolveMap.CNAME = resolver('queryCname');\nexports.resolveMx = resolveMap.MX = resolver('queryMx');\nexports.resolveNs = resolveMap.NS = resolver('queryNs');\nexports.resolveTxt = resolveMap.TXT = resolver('queryTxt');\nexports.resolveSrv = resolveMap.SRV = resolver('querySrv');\nexports.resolveNaptr = resolveMap.NAPTR = resolver('queryNaptr');\nexports.resolveSoa = resolveMap.SOA = resolver('querySoa');\nexports.reverse = resolveMap.PTR = resolver('getHostByAddr');\n\n\nexports.resolve = function(hostname, type_, callback_) {\n  var resolver, callback;\n  if (util.isString(type_)) {\n    resolver = resolveMap[type_];\n    callback = callback_;\n  } else if (util.isFunction(type_)) {\n    resolver = exports.resolve4;\n    callback = type_;\n  } else {\n    throw new Error('Type must be a string');\n  }\n\n  if (util.isFunction(resolver)) {\n    return resolver(hostname, callback);\n  } else {\n    throw new Error('Unknown type \"' + type_ + '\"');\n  }\n};\n\n\nexports.getServers = function() {\n  return cares.getServers();\n};\n\n\nexports.setServers = function(servers) {\n  // cache the original servers because in the event of an error setting the\n  // servers cares won't have any servers available for resolution\n  var orig = cares.getServers();\n\n  var newSet = [];\n\n  servers.forEach(function(serv) {\n    var ver = isIp(serv);\n\n    if (ver)\n      return newSet.push([ver, serv]);\n\n    var match = serv.match(/\\[(.*)\\](:\\d+)?/);\n\n    // we have an IPv6 in brackets\n    if (match) {\n      ver = isIp(match[1]);\n      if (ver)\n        return newSet.push([ver, match[1]]);\n    }\n\n    var s = serv.split(/:\\d+$/)[0];\n    ver = isIp(s);\n\n    if (ver)\n      return newSet.push([ver, s]);\n\n    throw new Error('IP address is not properly formatted: ' + serv);\n  });\n\n  var r = cares.setServers(newSet);\n\n  if (r) {\n    // reset the servers to the old servers, because ares probably unset them\n    cares.setServers(orig.join(','));\n\n    var err = cares.strerror(r);\n    throw new Error('c-ares failed to set servers: \"' + err +\n                    '\" [' + servers + ']');\n  }\n};\n\n\n// ERROR CODES\nexports.NODATA = 'ENODATA';\nexports.FORMERR = 'EFORMERR';\nexports.SERVFAIL = 'ESERVFAIL';\nexports.NOTFOUND = 'ENOTFOUND';\nexports.NOTIMP = 'ENOTIMP';\nexports.REFUSED = 'EREFUSED';\nexports.BADQUERY = 'EBADQUERY';\nexports.ADNAME = 'EADNAME';\nexports.BADFAMILY = 'EBADFAMILY';\nexports.BADRESP = 'EBADRESP';\nexports.CONNREFUSED = 'ECONNREFUSED';\nexports.TIMEOUT = 'ETIMEOUT';\nexports.EOF = 'EOF';\nexports.FILE = 'EFILE';\nexports.NOMEM = 'ENOMEM';\nexports.DESTRUCTION = 'EDESTRUCTION';\nexports.BADSTR = 'EBADSTR';\nexports.BADFLAGS = 'EBADFLAGS';\nexports.NONAME = 'ENONAME';\nexports.BADHINTS = 'EBADHINTS';\nexports.NOTINITIALIZED = 'ENOTINITIALIZED';\nexports.LOADIPHLPAPI = 'ELOADIPHLPAPI';\nexports.ADDRGETNETWORKPARAMS = 'EADDRGETNETWORKPARAMS';\nexports.CANCELLED = 'ECANCELLED';\n",
  @"// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar util = require('util');\nvar EventEmitter = require('events');\nvar inherits = util.inherits;\n\n// communicate with events module, but don't require that\n// module to have to load this one, since this module has\n// a few side effects.\nEventEmitter.usingDomains = true;\n\n// overwrite process.domain with a getter/setter that will allow for more\n// effective optimizations\nvar _domain = [null];\nObject.defineProperty(process, 'domain', {\n  enumerable: true,\n  get: function() {\n    return _domain[0];\n  },\n  set: function(arg) {\n    return _domain[0] = arg;\n  }\n});\n\n// objects with external array data are excellent ways to communicate state\n// between js and c++ w/o much overhead\nvar _domain_flag = {};\n\n// let the process know we're using domains\nprocess._setupDomainUse(_domain, _domain_flag);\n\nexports.Domain = Domain;\n\nexports.create = exports.createDomain = function() {\n  return new Domain();\n};\n\n// it's possible to enter one domain while already inside\n// another one.  the stack is each entered domain.\nvar stack = [];\nexports._stack = stack;\n// the active domain is always the one that we're currently in.\nexports.active = null;\n\n\ninherits(Domain, EventEmitter);\n\nfunction Domain() {\n  EventEmitter.call(this);\n\n  this.members = [];\n}\n\nDomain.prototype.members = undefined;\nDomain.prototype._disposed = undefined;\n\n\n// Called by process._fatalException in case an error was thrown.\nDomain.prototype._errorHandler = function errorHandler(er) {\n  var caught = false;\n  // ignore errors on disposed domains.\n  //\n  // XXX This is a bit stupid.  We should probably get rid of\n  // domain.dispose() altogether.  It's almost always a terrible\n  // idea.  --isaacs\n  if (this._disposed)\n    return true;\n\n  if (!util.isPrimitive(er)) {\n    er.domain = this;\n    er.domainThrown = true;\n  }\n  // wrap this in a try/catch so we don't get infinite throwing\n  try {\n    // One of three things will happen here.\n    //\n    // 1. There is a handler, caught = true\n    // 2. There is no handler, caught = false\n    // 3. It throws, caught = false\n    //\n    // If caught is false after this, then there's no need to exit()\n    // the domain, because we're going to crash the process anyway.\n    caught = this.emit('error', er);\n\n    // Exit all domains on the stack.  Uncaught exceptions end the\n    // current tick and no domains should be left on the stack\n    // between ticks.\n    stack.length = 0;\n    exports.active = process.domain = null;\n  } catch (er2) {\n    // The domain error handler threw!  oh no!\n    // See if another domain can catch THIS error,\n    // or else crash on the original one.\n    // If the user already exited it, then don't double-exit.\n    if (this === exports.active) {\n      stack.pop();\n    }\n    if (stack.length) {\n      exports.active = process.domain = stack[stack.length - 1];\n      caught = process._fatalException(er2);\n    } else {\n      caught = false;\n    }\n    return caught;\n  }\n  return caught;\n};\n\n\nDomain.prototype.enter = function() {\n  if (this._disposed) return;\n\n  // note that this might be a no-op, but we still need\n  // to push it onto the stack so that we can pop it later.\n  exports.active = process.domain = this;\n  stack.push(this);\n  _domain_flag[0] = stack.length;\n};\n\n\nDomain.prototype.exit = function() {\n  // skip disposed domains, as usual, but also don't do anything if this\n  // domain is not on the stack.\n  var index = stack.lastIndexOf(this);\n  if (this._disposed || index === -1) return;\n\n  // exit all domains until this one.\n  stack.splice(index);\n  _domain_flag[0] = stack.length;\n\n  exports.active = stack[stack.length - 1];\n  process.domain = exports.active;\n};\n\n\n// note: this works for timers as well.\nDomain.prototype.add = function(ee) {\n  // If the domain is disposed or already added, then nothing left to do.\n  if (this._disposed || ee.domain === this)\n    return;\n\n  // has a domain already - remove it first.\n  if (ee.domain)\n    ee.domain.remove(ee);\n\n  // check for circular Domain->Domain links.\n  // This causes bad insanity!\n  //\n  // For example:\n  // var d = domain.create();\n  // var e = domain.create();\n  // d.add(e);\n  // e.add(d);\n  // e.emit('error', er); // RangeError, stack overflow!\n  if (this.domain && (ee instanceof Domain)) {\n    for (var d = this.domain; d; d = d.domain) {\n      if (ee === d) return;\n    }\n  }\n\n  ee.domain = this;\n  this.members.push(ee);\n};\n\n\nDomain.prototype.remove = function(ee) {\n  ee.domain = null;\n  var index = this.members.indexOf(ee);\n  if (index !== -1)\n    this.members.splice(index, 1);\n};\n\n\nDomain.prototype.run = function(fn) {\n  if (this._disposed)\n    return;\n  this.enter();\n  var ret = fn.call(this);\n  this.exit();\n  return ret;\n};\n\n\nfunction intercepted(_this, self, cb, fnargs) {\n  if (self._disposed)\n    return;\n\n  if (fnargs[0] && fnargs[0] instanceof Error) {\n    var er = fnargs[0];\n    util._extend(er, {\n      domainBound: cb,\n      domainThrown: false,\n      domain: self\n    });\n    self.emit('error', er);\n    return;\n  }\n\n  var args = [];\n  var i, ret;\n\n  self.enter();\n  if (fnargs.length > 1) {\n    for (i = 1; i < fnargs.length; i++)\n      args.push(fnargs[i]);\n    ret = cb.apply(_this, args);\n  } else {\n    ret = cb.call(_this);\n  }\n  self.exit();\n\n  return ret;\n}\n\n\nDomain.prototype.intercept = function(cb) {\n  var self = this;\n\n  function runIntercepted() {\n    return intercepted(this, self, cb, arguments);\n  }\n\n  return runIntercepted;\n};\n\n\nfunction bound(_this, self, cb, fnargs) {\n  if (self._disposed)\n    return;\n\n  var ret;\n\n  self.enter();\n  if (fnargs.length > 0)\n    ret = cb.apply(_this, fnargs);\n  else\n    ret = cb.call(_this);\n  self.exit();\n\n  return ret;\n}\n\n\nDomain.prototype.bind = function(cb) {\n  var self = this;\n\n  function runBound() {\n    return bound(this, self, cb, arguments);\n  }\n\n  runBound.domain = this;\n\n  return runBound;\n};\n\n\nDomain.prototype.dispose = util.deprecate(function() {\n  if (this._disposed) return;\n\n  // if we're the active domain, then get out now.\n  this.exit();\n\n  // remove from parent domain, if there is one.\n  if (this.domain) this.domain.remove(this);\n\n  // kill the references so that they can be properly gc'ed.\n  this.members.length = 0;\n\n  // mark this domain as 'no longer relevant'\n  // so that it can't be entered or activated.\n  this._disposed = true;\n});\n",
  @"// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar domain;\nvar util = require('util');\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.usingDomains = false;\n\nEventEmitter.prototype.domain = undefined;\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nEventEmitter.defaultMaxListeners = 10;\n\nEventEmitter.init = function() {\n  this.domain = null;\n  if (EventEmitter.usingDomains) {\n    // if there is an active domain, then attach to it.\n    domain = domain || require('domain');\n    if (domain.active && !(this instanceof domain.Domain)) {\n      this.domain = domain.active;\n    }\n  }\n\n  if (!this._events || this._events === Object.getPrototypeOf(this)._events)\n    this._events = {};\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (!util.isNumber(n) || n < 0 || isNaN(n))\n    throw TypeError('n must be a positive number');\n  this._maxListeners = n;\n  return this;\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var er, handler, len, args, i, listeners;\n\n  if (!this._events)\n    this._events = {};\n\n  // If there is no 'error' event listener then throw.\n  if (type === 'error' && !this._events.error) {\n    er = arguments[1];\n    if (this.domain) {\n      if (!er)\n        er = new Error('Uncaught, unspecified \"error\" event.');\n      er.domainEmitter = this;\n      er.domain = this.domain;\n      er.domainThrown = false;\n      this.domain.emit('error', er);\n    } else if (er instanceof Error) {\n      throw er; // Unhandled 'error' event\n    } else {\n      throw Error('Uncaught, unspecified \"error\" event.');\n    }\n    return false;\n  }\n\n  handler = this._events[type];\n\n  if (util.isUndefined(handler))\n    return false;\n\n  if (this.domain && this !== process)\n    this.domain.enter();\n\n  if (util.isFunction(handler)) {\n    switch (arguments.length) {\n      // fast cases\n      case 1:\n        handler.call(this);\n        break;\n      case 2:\n        handler.call(this, arguments[1]);\n        break;\n      case 3:\n        handler.call(this, arguments[1], arguments[2]);\n        break;\n      // slower\n      default:\n        len = arguments.length;\n        args = new Array(len - 1);\n        for (i = 1; i < len; i++)\n          args[i - 1] = arguments[i];\n        handler.apply(this, args);\n    }\n  } else if (util.isObject(handler)) {\n    len = arguments.length;\n    args = new Array(len - 1);\n    for (i = 1; i < len; i++)\n      args[i - 1] = arguments[i];\n\n    listeners = handler.slice();\n    len = listeners.length;\n    for (i = 0; i < len; i++)\n      listeners[i].apply(this, args);\n  }\n\n  if (this.domain && this !== process)\n    this.domain.exit();\n\n  return true;\n};\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  var m;\n\n  if (!util.isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events)\n    this._events = {};\n\n  // To avoid recursion in the case that type === \"newListener\"! Before\n  // adding it to the listeners, first emit \"newListener\".\n  if (this._events.newListener)\n    this.emit('newListener', type,\n              util.isFunction(listener.listener) ?\n              listener.listener : listener);\n\n  if (!this._events[type])\n    // Optimize the case of one listener. Don't need the extra array object.\n    this._events[type] = listener;\n  else if (util.isObject(this._events[type]))\n    // If we've already got an array, just append.\n    this._events[type].push(listener);\n  else\n    // Adding the second element, need to change to array.\n    this._events[type] = [this._events[type], listener];\n\n  // Check for listener leak\n  if (util.isObject(this._events[type]) && !this._events[type].warned) {\n    var m;\n    if (!util.isUndefined(this._maxListeners)) {\n      m = this._maxListeners;\n    } else {\n      m = EventEmitter.defaultMaxListeners;\n    }\n\n    if (m && m > 0 && this._events[type].length > m) {\n      this._events[type].warned = true;\n      console.error('(node) warning: possible EventEmitter memory ' +\n                    'leak detected. %d %s listeners added. ' +\n                    'Use emitter.setMaxListeners() to increase limit.',\n                    this._events[type].length, type);\n      console.trace();\n    }\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.once = function once(type, listener) {\n  if (!util.isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  var fired = false;\n\n  function g() {\n    this.removeListener(type, g);\n\n    if (!fired) {\n      fired = true;\n      listener.apply(this, arguments);\n    }\n  }\n\n  g.listener = listener;\n  this.on(type, g);\n\n  return this;\n};\n\n// emits a 'removeListener' event iff the listener was removed\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n  var list, position, length, i;\n\n  if (!util.isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events || !this._events[type])\n    return this;\n\n  list = this._events[type];\n  length = list.length;\n  position = -1;\n\n  if (list === listener ||\n      (util.isFunction(list.listener) && list.listener === listener)) {\n    delete this._events[type];\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n\n  } else if (util.isObject(list)) {\n    for (i = length; i-- > 0;) {\n      if (list[i] === listener ||\n          (list[i].listener && list[i].listener === listener)) {\n        position = i;\n        break;\n      }\n    }\n\n    if (position < 0)\n      return this;\n\n    if (list.length === 1) {\n      list.length = 0;\n      delete this._events[type];\n    } else {\n      list.splice(position, 1);\n    }\n\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n  var key, listeners;\n\n  if (!this._events)\n    return this;\n\n  // not listening for removeListener, no need to emit\n  if (!this._events.removeListener) {\n    if (arguments.length === 0)\n      this._events = {};\n    else if (this._events[type])\n      delete this._events[type];\n    return this;\n  }\n\n  // emit removeListener for all listeners on all events\n  if (arguments.length === 0) {\n    for (key in this._events) {\n      if (key === 'removeListener') continue;\n      this.removeAllListeners(key);\n    }\n    this.removeAllListeners('removeListener');\n    this._events = {};\n    return this;\n  }\n\n  listeners = this._events[type];\n\n  if (util.isFunction(listeners)) {\n    this.removeListener(type, listeners);\n  } else if (Array.isArray(listeners)) {\n    // LIFO order\n    while (listeners.length)\n      this.removeListener(type, listeners[listeners.length - 1]);\n  }\n  delete this._events[type];\n\n  return this;\n};\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  var ret;\n  if (!this._events || !this._events[type])\n    ret = [];\n  else if (util.isFunction(this._events[type]))\n    ret = [this._events[type]];\n  else\n    ret = this._events[type].slice();\n  return ret;\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  var ret;\n  if (!emitter._events || !emitter._events[type])\n    ret = 0;\n  else if (util.isFunction(emitter._events[type]))\n    ret = 1;\n  else\n    ret = emitter._events[type].length;\n  return ret;\n};\n",
  @"// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// This is a free list to avoid creating so many of the same object.\nexports.FreeList = function(name, max, constructor) {\n  this.name = name;\n  this.constructor = constructor;\n  this.max = max;\n  this.list = [];\n};\n\n\nexports.FreeList.prototype.alloc = function() {\n  //debug(\"alloc \" + this.name + \" \" + this.list.length);\n  return this.list.length ? this.list.shift() :\n                            this.constructor.apply(this, arguments);\n};\n\n\nexports.FreeList.prototype.free = function(obj) {\n  //debug(\"free \" + this.name + \" \" + this.list.length);\n  if (this.list.length < this.max) {\n    this.list.push(obj);\n  }\n};\n",
  @"// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Maintainers, keep in mind that octal literals are not allowed\n// in strict mode. Use the decimal value and add a comment with\n// the octal value. Example:\n//\n//   var mode = 438;\n\nvar util = require('util');\nvar pathModule = require('path');\n\nvar binding = process.binding('fs');\nvar constants = process.binding('constants');\nvar fs = exports;\nvar Stream = require('stream').Stream;\nvar EventEmitter = require('events').EventEmitter;\n\nvar Readable = Stream.Readable;\nvar Writable = Stream.Writable;\n\nvar kMinPoolSpace = 128;\nvar kMaxLength = require('smalloc').kMaxLength;\n\nvar O_APPEND = constants.O_APPEND || 0;\nvar O_CREAT = constants.O_CREAT || 0;\nvar O_EXCL = constants.O_EXCL || 0;\nvar O_RDONLY = constants.O_RDONLY || 0;\nvar O_RDWR = constants.O_RDWR || 0;\nvar O_SYNC = constants.O_SYNC || 0;\nvar O_TRUNC = constants.O_TRUNC || 0;\nvar O_WRONLY = constants.O_WRONLY || 0;\n\nvar isWindows = process.platform === 'win32';\n\nvar DEBUG = process.env.NODE_DEBUG && /fs/.test(process.env.NODE_DEBUG);\nvar errnoException = util._errnoException;\n\n\nfunction rethrow() {\n  // Only enable in debug mode. A backtrace uses ~1000 bytes of heap space and\n  // is fairly slow to generate.\n  if (DEBUG) {\n    var backtrace = new Error;\n    return function(err) {\n      if (err) {\n        backtrace.stack = err.name + ': ' + err.message +\n                          backtrace.stack.substr(backtrace.name.length);\n        err = backtrace;\n        throw err;\n      }\n    };\n  }\n\n  return function(err) {\n    if (err) {\n      throw err;  // Forgot a callback but don't know where? Use NODE_DEBUG=fs\n    }\n  };\n}\n\nfunction maybeCallback(cb) {\n  return util.isFunction(cb) ? cb : rethrow();\n}\n\n// Ensure that callbacks run in the global context. Only use this function\n// for callbacks that are passed to the binding layer, callbacks that are\n// invoked from JS already run in the proper scope.\nfunction makeCallback(cb) {\n  if (!util.isFunction(cb)) {\n    return rethrow();\n  }\n\n  return function() {\n    return cb.apply(null, arguments);\n  };\n}\n\nfunction assertEncoding(encoding) {\n  if (encoding && !Buffer.isEncoding(encoding)) {\n    throw new Error('Unknown encoding: ' + encoding);\n  }\n}\n\nfunction nullCheck(path, callback) {\n  if (('' + path).indexOf('\\u0000') !== -1) {\n    var er = new Error('Path must be a string without null bytes.');\n    if (!callback)\n      throw er;\n    process.nextTick(function() {\n      callback(er);\n    });\n    return false;\n  }\n  return true;\n}\n\n// Static method to set the stats properties on a Stats object.\nfs.Stats = function(\n    dev,\n    mode,\n    nlink,\n    uid,\n    gid,\n    rdev,\n    blksize,\n    ino,\n    size,\n    blocks,\n    atim_msec,\n    mtim_msec,\n    ctim_msec,\n    birthtim_msec) {\n  this.dev = dev;\n  this.mode = mode;\n  this.nlink = nlink;\n  this.uid = uid;\n  this.gid = gid;\n  this.rdev = rdev;\n  this.blksize = blksize;\n  this.ino = ino;\n  this.size = size;\n  this.blocks = blocks;\n  this.atime = new Date(atim_msec);\n  this.mtime = new Date(mtim_msec);\n  this.ctime = new Date(ctim_msec);\n  this.birthtime = new Date(birthtim_msec);\n};\n\n// Create a C++ binding to the function which creates a Stats object.\nbinding.FSInitialize(fs.Stats);\n\nfs.Stats.prototype._checkModeProperty = function(property) {\n  return ((this.mode & constants.S_IFMT) === property);\n};\n\nfs.Stats.prototype.isDirectory = function() {\n  return this._checkModeProperty(constants.S_IFDIR);\n};\n\nfs.Stats.prototype.isFile = function() {\n  return this._checkModeProperty(constants.S_IFREG);\n};\n\nfs.Stats.prototype.isBlockDevice = function() {\n  return this._checkModeProperty(constants.S_IFBLK);\n};\n\nfs.Stats.prototype.isCharacterDevice = function() {\n  return this._checkModeProperty(constants.S_IFCHR);\n};\n\nfs.Stats.prototype.isSymbolicLink = function() {\n  return this._checkModeProperty(constants.S_IFLNK);\n};\n\nfs.Stats.prototype.isFIFO = function() {\n  return this._checkModeProperty(constants.S_IFIFO);\n};\n\nfs.Stats.prototype.isSocket = function() {\n  return this._checkModeProperty(constants.S_IFSOCK);\n};\n\nfs.exists = function(path, callback) {\n  if (!nullCheck(path, cb)) return;\n  binding.stat(pathModule._makeLong(path), cb);\n  function cb(err, stats) {\n    if (callback) callback(err ? false : true);\n  }\n};\n\nfs.existsSync = function(path) {\n  try {\n    nullCheck(path);\n    binding.stat(pathModule._makeLong(path));\n    return true;\n  } catch (e) {\n    return false;\n  }\n};\n\nfs.readFile = function(path, options, callback_) {\n  var callback = maybeCallback(arguments[arguments.length - 1]);\n\n  if (util.isFunction(options) || !options) {\n    options = { encoding: null, flag: 'r' };\n  } else if (util.isString(options)) {\n    options = { encoding: options, flag: 'r' };\n  } else if (!util.isObject(options)) {\n    throw new TypeError('Bad arguments');\n  }\n\n  var encoding = options.encoding;\n  assertEncoding(encoding);\n\n  // first, stat the file, so we know the size.\n  var size;\n  var buffer; // single buffer with file data\n  var buffers; // list for when size is unknown\n  var pos = 0;\n  var fd;\n\n  var flag = options.flag || 'r';\n  fs.open(path, flag, 438 , function(er, fd_) {\n    if (er) return callback(er);\n    fd = fd_;\n\n    fs.fstat(fd, function(er, st) {\n      if (er) {\n        return fs.close(fd, function() {\n          callback(er);\n        });\n      }\n\n      size = st.size;\n      if (size === 0) {\n        // the kernel lies about many files.\n        // Go ahead and try to read some bytes.\n        buffers = [];\n        return read();\n      }\n\n      if (size > kMaxLength)\n        throw new RangeError('File size is greater than possible Buffer: ' +\n                             '0x3FFFFFFF bytes');\n\n      buffer = new Buffer(size);\n      read();\n    });\n  });\n\n  function read() {\n    if (size === 0) {\n      buffer = new Buffer(8192);\n      fs.read(fd, buffer, 0, 8192, -1, afterRead);\n    } else {\n      fs.read(fd, buffer, pos, size - pos, -1, afterRead);\n    }\n  }\n\n  function afterRead(er, bytesRead) {\n    if (er) {\n      return fs.close(fd, function(er2) {\n        return callback(er);\n      });\n    }\n\n    if (bytesRead === 0) {\n      return close();\n    }\n\n    pos += bytesRead;\n    if (size !== 0) {\n      if (pos === size) close();\n      else read();\n    } else {\n      // unknown size, just read until we don't get bytes.\n      buffers.push(buffer.slice(0, bytesRead));\n      read();\n    }\n  }\n\n  function close() {\n    fs.close(fd, function(er) {\n      if (size === 0) {\n        // collected the data into the buffers list.\n        buffer = Buffer.concat(buffers, pos);\n      } else if (pos < size) {\n        buffer = buffer.slice(0, pos);\n      }\n\n      if (encoding) buffer = buffer.toString(encoding);\n      return callback(er, buffer);\n    });\n  }\n};\n\nfs.readFileSync = function(path, options) {\n  if (!options) {\n    options = { encoding: null, flag: 'r' };\n  } else if (util.isString(options)) {\n    options = { encoding: options, flag: 'r' };\n  } else if (!util.isObject(options)) {\n    throw new TypeError('Bad arguments');\n  }\n\n  var encoding = options.encoding;\n  assertEncoding(encoding);\n\n  var flag = options.flag || 'r';\n  var fd = fs.openSync(path, flag, 438 );\n\n  var size;\n  var threw = true;\n  try {\n    size = fs.fstatSync(fd).size;\n    threw = false;\n  } finally {\n    if (threw) fs.closeSync(fd);\n  }\n\n  var pos = 0;\n  var buffer; // single buffer with file data\n  var buffers; // list for when size is unknown\n\n  if (size === 0) {\n    buffers = [];\n  } else {\n    buffer = new Buffer(size);\n  }\n\n  var done = false;\n  while (!done) {\n    var threw = true;\n    try {\n      if (size !== 0) {\n        var bytesRead = fs.readSync(fd, buffer, pos, size - pos);\n      } else {\n        // the kernel lies about many files.\n        // Go ahead and try to read some bytes.\n        buffer = new Buffer(8192);\n        var bytesRead = fs.readSync(fd, buffer, 0, 8192);\n        if (bytesRead) {\n          buffers.push(buffer.slice(0, bytesRead));\n        }\n      }\n      threw = false;\n    } finally {\n      if (threw) fs.closeSync(fd);\n    }\n\n    pos += bytesRead;\n    done = (bytesRead === 0) || (size !== 0 && pos >= size);\n  }\n\n  fs.closeSync(fd);\n\n  if (size === 0) {\n    // data was collected into the buffers list.\n    buffer = Buffer.concat(buffers, pos);\n  } else if (pos < size) {\n    buffer = buffer.slice(0, pos);\n  }\n\n  if (encoding) buffer = buffer.toString(encoding);\n  return buffer;\n};\n\n\n// Used by binding.open and friends\nfunction stringToFlags(flag) {\n  // Only mess with strings\n  if (!util.isString(flag)) {\n    return flag;\n  }\n\n  switch (flag) {\n    case 'r' : return O_RDONLY;\n    case 'rs' : // fall through\n    case 'sr' : return O_RDONLY | O_SYNC;\n    case 'r+' : return O_RDWR;\n    case 'rs+' : // fall through\n    case 'sr+' : return O_RDWR | O_SYNC;\n\n    case 'w' : return O_TRUNC | O_CREAT | O_WRONLY;\n    case 'wx' : // fall through\n    case 'xw' : return O_TRUNC | O_CREAT | O_WRONLY | O_EXCL;\n\n    case 'w+' : return O_TRUNC | O_CREAT | O_RDWR;\n    case 'wx+': // fall through\n    case 'xw+': return O_TRUNC | O_CREAT | O_RDWR | O_EXCL;\n\n    case 'a' : return O_APPEND | O_CREAT | O_WRONLY;\n    case 'ax' : // fall through\n    case 'xa' : return O_APPEND | O_CREAT | O_WRONLY | O_EXCL;\n\n    case 'a+' : return O_APPEND | O_CREAT | O_RDWR;\n    case 'ax+': // fall through\n    case 'xa+': return O_APPEND | O_CREAT | O_RDWR | O_EXCL;\n  }\n\n  throw new Error('Unknown file open flag: ' + flag);\n}\n\n// exported but hidden, only used by test/simple/test-fs-open-flags.js\nObject.defineProperty(exports, '_stringToFlags', {\n  enumerable: false,\n  value: stringToFlags\n});\n\n\n// Yes, the follow could be easily DRYed up but I provide the explicit\n// list to make the arguments clear.\n\nfs.close = function(fd, callback) {\n  binding.close(fd, makeCallback(callback));\n};\n\nfs.closeSync = function(fd) {\n  return binding.close(fd);\n};\n\nfunction modeNum(m, def) {\n  if (util.isNumber(m))\n    return m;\n  if (util.isString(m))\n    return parseInt(m, 8);\n  if (def)\n    return modeNum(def);\n  return undefined;\n}\n\nfs.open = function(path, flags, mode, callback) {\n  callback = makeCallback(arguments[arguments.length - 1]);\n  mode = modeNum(mode, 438 );\n\n  if (!nullCheck(path, callback)) return;\n  binding.open(pathModule._makeLong(path),\n               stringToFlags(flags),\n               mode,\n               callback);\n};\n\nfs.openSync = function(path, flags, mode) {\n  mode = modeNum(mode, 438 );\n  nullCheck(path);\n  return binding.open(pathModule._makeLong(path), stringToFlags(flags), mode);\n};\n\nfs.read = function(fd, buffer, offset, length, position, callback) {\n  if (!util.isBuffer(buffer)) {\n    // legacy string interface (fd, length, position, encoding, callback)\n    var cb = arguments[4],\n        encoding = arguments[3];\n\n    assertEncoding(encoding);\n\n    position = arguments[2];\n    length = arguments[1];\n    buffer = new Buffer(length);\n    offset = 0;\n\n    callback = function(err, bytesRead) {\n      if (!cb) return;\n\n      var str = (bytesRead > 0) ? buffer.toString(encoding, 0, bytesRead) : '';\n\n      (cb)(err, str, bytesRead);\n    };\n  }\n\n  function wrapper(err, bytesRead) {\n    // Retain a reference to buffer so that it can't be GC'ed too soon.\n    callback && callback(err, bytesRead || 0, buffer);\n  }\n\n  binding.read(fd, buffer, offset, length, position, wrapper);\n};\n\nfs.readSync = function(fd, buffer, offset, length, position) {\n  var legacy = false;\n  if (!util.isBuffer(buffer)) {\n    // legacy string interface (fd, length, position, encoding, callback)\n    legacy = true;\n    var encoding = arguments[3];\n\n    assertEncoding(encoding);\n\n    position = arguments[2];\n    length = arguments[1];\n    buffer = new Buffer(length);\n\n    offset = 0;\n  }\n\n  var r = binding.read(fd, buffer, offset, length, position);\n  if (!legacy) {\n    return r;\n  }\n\n  var str = (r > 0) ? buffer.toString(encoding, 0, r) : '';\n  return [str, r];\n};\n\n// usage:\n//  fs.write(fd, buffer, offset, length[, position], callback);\n// OR\n//  fs.write(fd, string[, position[, encoding]], callback);\nfs.write = function(fd, buffer, offset, length, position, callback) {\n  if (util.isBuffer(buffer)) {\n    // if no position is passed then assume null\n    if (util.isFunction(position)) {\n      callback = position;\n      position = null;\n    }\n    callback = maybeCallback(callback);\n    var wrapper = function(err, written) {\n      // Retain a reference to buffer so that it can't be GC'ed too soon.\n      callback(err, written || 0, buffer);\n    };\n    return binding.writeBuffer(fd, buffer, offset, length, position, wrapper);\n  }\n\n  if (util.isString(buffer))\n    buffer += '';\n  if (!util.isFunction(position)) {\n    if (util.isFunction(offset)) {\n      position = offset;\n      offset = null;\n    } else {\n      position = length;\n    }\n    length = 'utf8';\n  }\n  callback = maybeCallback(position);\n  position = function(err, written) {\n    // retain reference to string in case it's external\n    callback(err, written || 0, buffer);\n  };\n  return binding.writeString(fd, buffer, offset, length, position);\n};\n\n// usage:\n//  fs.writeSync(fd, buffer, offset, length[, position]);\n// OR\n//  fs.writeSync(fd, string[, position[, encoding]]);\nfs.writeSync = function(fd, buffer, offset, length, position) {\n  if (util.isBuffer(buffer)) {\n    if (util.isUndefined(position))\n      position = null;\n    return binding.writeBuffer(fd, buffer, offset, length, position);\n  }\n  if (!util.isString(buffer))\n    buffer += '';\n  if (util.isUndefined(offset))\n    offset = null;\n  return binding.writeString(fd, buffer, offset, length, position);\n};\n\nfs.rename = function(oldPath, newPath, callback) {\n  callback = makeCallback(callback);\n  if (!nullCheck(oldPath, callback)) return;\n  if (!nullCheck(newPath, callback)) return;\n  binding.rename(pathModule._makeLong(oldPath),\n                 pathModule._makeLong(newPath),\n                 callback);\n};\n\nfs.renameSync = function(oldPath, newPath) {\n  nullCheck(oldPath);\n  nullCheck(newPath);\n  return binding.rename(pathModule._makeLong(oldPath),\n                        pathModule._makeLong(newPath));\n};\n\nfs.truncate = function(path, len, callback) {\n  if (util.isNumber(path)) {\n    // legacy\n    return fs.ftruncate(path, len, callback);\n  }\n  if (util.isFunction(len)) {\n    callback = len;\n    len = 0;\n  } else if (util.isUndefined(len)) {\n    len = 0;\n  }\n  callback = maybeCallback(callback);\n  fs.open(path, 'r+', function(er, fd) {\n    if (er) return callback(er);\n    binding.ftruncate(fd, len, function(er) {\n      fs.close(fd, function(er2) {\n        callback(er || er2);\n      });\n    });\n  });\n};\n\nfs.truncateSync = function(path, len) {\n  if (util.isNumber(path)) {\n    // legacy\n    return fs.ftruncateSync(path, len);\n  }\n  if (util.isUndefined(len)) {\n    len = 0;\n  }\n  // allow error to be thrown, but still close fd.\n  var fd = fs.openSync(path, 'r+');\n  try {\n    var ret = fs.ftruncateSync(fd, len);\n  } finally {\n    fs.closeSync(fd);\n  }\n  return ret;\n};\n\nfs.ftruncate = function(fd, len, callback) {\n  if (util.isFunction(len)) {\n    callback = len;\n    len = 0;\n  } else if (util.isUndefined(len)) {\n    len = 0;\n  }\n  binding.ftruncate(fd, len, makeCallback(callback));\n};\n\nfs.ftruncateSync = function(fd, len) {\n  if (util.isUndefined(len)) {\n    len = 0;\n  }\n  return binding.ftruncate(fd, len);\n};\n\nfs.rmdir = function(path, callback) {\n  callback = makeCallback(callback);\n  if (!nullCheck(path, callback)) return;\n  binding.rmdir(pathModule._makeLong(path), callback);\n};\n\nfs.rmdirSync = function(path) {\n  nullCheck(path);\n  return binding.rmdir(pathModule._makeLong(path));\n};\n\nfs.fdatasync = function(fd, callback) {\n  binding.fdatasync(fd, makeCallback(callback));\n};\n\nfs.fdatasyncSync = function(fd) {\n  return binding.fdatasync(fd);\n};\n\nfs.fsync = function(fd, callback) {\n  binding.fsync(fd, makeCallback(callback));\n};\n\nfs.fsyncSync = function(fd) {\n  return binding.fsync(fd);\n};\n\nfs.mkdir = function(path, mode, callback) {\n  if (util.isFunction(mode)) callback = mode;\n  callback = makeCallback(callback);\n  if (!nullCheck(path, callback)) return;\n  binding.mkdir(pathModule._makeLong(path),\n                modeNum(mode, 511 ),\n                callback);\n};\n\nfs.mkdirSync = function(path, mode) {\n  nullCheck(path);\n  return binding.mkdir(pathModule._makeLong(path),\n                       modeNum(mode, 511 ));\n};\n\nfs.readdir = function(path, callback) {\n  callback = makeCallback(callback);\n  if (!nullCheck(path, callback)) return;\n  binding.readdir(pathModule._makeLong(path), callback);\n};\n\nfs.readdirSync = function(path) {\n  nullCheck(path);\n  return binding.readdir(pathModule._makeLong(path));\n};\n\nfs.fstat = function(fd, callback) {\n  binding.fstat(fd, makeCallback(callback));\n};\n\nfs.lstat = function(path, callback) {\n  callback = makeCallback(callback);\n  if (!nullCheck(path, callback)) return;\n  binding.lstat(pathModule._makeLong(path), callback);\n};\n\nfs.stat = function(path, callback) {\n  callback = makeCallback(callback);\n  if (!nullCheck(path, callback)) return;\n  binding.stat(pathModule._makeLong(path), callback);\n};\n\nfs.fstatSync = function(fd) {\n  return binding.fstat(fd);\n};\n\nfs.lstatSync = function(path) {\n  nullCheck(path);\n  return binding.lstat(pathModule._makeLong(path));\n};\n\nfs.statSync = function(path) {\n  nullCheck(path);\n  return binding.stat(pathModule._makeLong(path));\n};\n\nfs.readlink = function(path, callback) {\n  callback = makeCallback(callback);\n  if (!nullCheck(path, callback)) return;\n  binding.readlink(pathModule._makeLong(path), callback);\n};\n\nfs.readlinkSync = function(path) {\n  nullCheck(path);\n  return binding.readlink(pathModule._makeLong(path));\n};\n\nfunction preprocessSymlinkDestination(path, type) {\n  if (!isWindows) {\n    // No preprocessing is needed on Unix.\n    return path;\n  } else if (type === 'junction') {\n    // Junctions paths need to be absolute and \\\\?\\-prefixed.\n    return pathModule._makeLong(path);\n  } else {\n    // Windows symlinks don't tolerate forward slashes.\n    return ('' + path).replace(/\\//g, '\\\\');\n  }\n}\n\nfs.symlink = function(destination, path, type_, callback) {\n  var type = (util.isString(type_) ? type_ : null);\n  var callback = makeCallback(arguments[arguments.length - 1]);\n\n  if (!nullCheck(destination, callback)) return;\n  if (!nullCheck(path, callback)) return;\n\n  binding.symlink(preprocessSymlinkDestination(destination, type),\n                  pathModule._makeLong(path),\n                  type,\n                  callback);\n};\n\nfs.symlinkSync = function(destination, path, type) {\n  type = (util.isString(type) ? type : null);\n\n  nullCheck(destination);\n  nullCheck(path);\n\n  return binding.symlink(preprocessSymlinkDestination(destination, type),\n                         pathModule._makeLong(path),\n                         type);\n};\n\nfs.link = function(srcpath, dstpath, callback) {\n  callback = makeCallback(callback);\n  if (!nullCheck(srcpath, callback)) return;\n  if (!nullCheck(dstpath, callback)) return;\n\n  binding.link(pathModule._makeLong(srcpath),\n               pathModule._makeLong(dstpath),\n               callback);\n};\n\nfs.linkSync = function(srcpath, dstpath) {\n  nullCheck(srcpath);\n  nullCheck(dstpath);\n  return binding.link(pathModule._makeLong(srcpath),\n                      pathModule._makeLong(dstpath));\n};\n\nfs.unlink = function(path, callback) {\n  callback = makeCallback(callback);\n  if (!nullCheck(path, callback)) return;\n  binding.unlink(pathModule._makeLong(path), callback);\n};\n\nfs.unlinkSync = function(path) {\n  nullCheck(path);\n  return binding.unlink(pathModule._makeLong(path));\n};\n\nfs.fchmod = function(fd, mode, callback) {\n  binding.fchmod(fd, modeNum(mode), makeCallback(callback));\n};\n\nfs.fchmodSync = function(fd, mode) {\n  return binding.fchmod(fd, modeNum(mode));\n};\n\nif (constants.hasOwnProperty('O_SYMLINK')) {\n  fs.lchmod = function(path, mode, callback) {\n    callback = maybeCallback(callback);\n    fs.open(path, constants.O_WRONLY | constants.O_SYMLINK, function(err, fd) {\n      if (err) {\n        callback(err);\n        return;\n      }\n      // prefer to return the chmod error, if one occurs,\n      // but still try to close, and report closing errors if they occur.\n      fs.fchmod(fd, mode, function(err) {\n        fs.close(fd, function(err2) {\n          callback(err || err2);\n        });\n      });\n    });\n  };\n\n  fs.lchmodSync = function(path, mode) {\n    var fd = fs.openSync(path, constants.O_WRONLY | constants.O_SYMLINK);\n\n    // prefer to return the chmod error, if one occurs,\n    // but still try to close, and report closing errors if they occur.\n    var err, err2;\n    try {\n      var ret = fs.fchmodSync(fd, mode);\n    } catch (er) {\n      err = er;\n    }\n    try {\n      fs.closeSync(fd);\n    } catch (er) {\n      err2 = er;\n    }\n    if (err || err2) throw (err || err2);\n    return ret;\n  };\n}\n\n\nfs.chmod = function(path, mode, callback) {\n  callback = makeCallback(callback);\n  if (!nullCheck(path, callback)) return;\n  binding.chmod(pathModule._makeLong(path),\n                modeNum(mode),\n                callback);\n};\n\nfs.chmodSync = function(path, mode) {\n  nullCheck(path);\n  return binding.chmod(pathModule._makeLong(path), modeNum(mode));\n};\n\nif (constants.hasOwnProperty('O_SYMLINK')) {\n  fs.lchown = function(path, uid, gid, callback) {\n    callback = maybeCallback(callback);\n    fs.open(path, constants.O_WRONLY | constants.O_SYMLINK, function(err, fd) {\n      if (err) {\n        callback(err);\n        return;\n      }\n      fs.fchown(fd, uid, gid, callback);\n    });\n  };\n\n  fs.lchownSync = function(path, uid, gid) {\n    var fd = fs.openSync(path, constants.O_WRONLY | constants.O_SYMLINK);\n    return fs.fchownSync(fd, uid, gid);\n  };\n}\n\nfs.fchown = function(fd, uid, gid, callback) {\n  binding.fchown(fd, uid, gid, makeCallback(callback));\n};\n\nfs.fchownSync = function(fd, uid, gid) {\n  return binding.fchown(fd, uid, gid);\n};\n\nfs.chown = function(path, uid, gid, callback) {\n  callback = makeCallback(callback);\n  if (!nullCheck(path, callback)) return;\n  binding.chown(pathModule._makeLong(path), uid, gid, callback);\n};\n\nfs.chownSync = function(path, uid, gid) {\n  nullCheck(path);\n  return binding.chown(pathModule._makeLong(path), uid, gid);\n};\n\n// converts Date or number to a fractional UNIX timestamp\nfunction toUnixTimestamp(time) {\n  if (util.isNumber(time)) {\n    return time;\n  }\n  if (util.isDate(time)) {\n    // convert to 123.456 UNIX timestamp\n    return time.getTime() / 1000;\n  }\n  throw new Error('Cannot parse time: ' + time);\n}\n\n// exported for unit tests, not for public consumption\nfs._toUnixTimestamp = toUnixTimestamp;\n\nfs.utimes = function(path, atime, mtime, callback) {\n  callback = makeCallback(callback);\n  if (!nullCheck(path, callback)) return;\n  binding.utimes(pathModule._makeLong(path),\n                 toUnixTimestamp(atime),\n                 toUnixTimestamp(mtime),\n                 callback);\n};\n\nfs.utimesSync = function(path, atime, mtime) {\n  nullCheck(path);\n  atime = toUnixTimestamp(atime);\n  mtime = toUnixTimestamp(mtime);\n  binding.utimes(pathModule._makeLong(path), atime, mtime);\n};\n\nfs.futimes = function(fd, atime, mtime, callback) {\n  atime = toUnixTimestamp(atime);\n  mtime = toUnixTimestamp(mtime);\n  binding.futimes(fd, atime, mtime, makeCallback(callback));\n};\n\nfs.futimesSync = function(fd, atime, mtime) {\n  atime = toUnixTimestamp(atime);\n  mtime = toUnixTimestamp(mtime);\n  binding.futimes(fd, atime, mtime);\n};\n\nfunction writeAll(fd, buffer, offset, length, position, callback) {\n  callback = maybeCallback(arguments[arguments.length - 1]);\n\n  // write(fd, buffer, offset, length, position, callback)\n  fs.write(fd, buffer, offset, length, position, function(writeErr, written) {\n    if (writeErr) {\n      fs.close(fd, function() {\n        if (callback) callback(writeErr);\n      });\n    } else {\n      if (written === length) {\n        fs.close(fd, callback);\n      } else {\n        offset += written;\n        length -= written;\n        position += written;\n        writeAll(fd, buffer, offset, length, position, callback);\n      }\n    }\n  });\n}\n\nfs.writeFile = function(path, data, options, callback) {\n  var callback = maybeCallback(arguments[arguments.length - 1]);\n\n  if (util.isFunction(options) || !options) {\n    options = { encoding: 'utf8', mode: 438 , flag: 'w' };\n  } else if (util.isString(options)) {\n    options = { encoding: options, mode: 438, flag: 'w' };\n  } else if (!util.isObject(options)) {\n    throw new TypeError('Bad arguments');\n  }\n\n  assertEncoding(options.encoding);\n\n  var flag = options.flag || 'w';\n  fs.open(path, flag, options.mode, function(openErr, fd) {\n    if (openErr) {\n      if (callback) callback(openErr);\n    } else {\n      var buffer = util.isBuffer(data) ? data : new Buffer('' + data,\n          options.encoding || 'utf8');\n      var position = /a/.test(flag) ? null : 0;\n      writeAll(fd, buffer, 0, buffer.length, position, callback);\n    }\n  });\n};\n\nfs.writeFileSync = function(path, data, options) {\n  if (!options) {\n    options = { encoding: 'utf8', mode: 438 , flag: 'w' };\n  } else if (util.isString(options)) {\n    options = { encoding: options, mode: 438, flag: 'w' };\n  } else if (!util.isObject(options)) {\n    throw new TypeError('Bad arguments');\n  }\n\n  assertEncoding(options.encoding);\n\n  var flag = options.flag || 'w';\n  var fd = fs.openSync(path, flag, options.mode);\n  if (!util.isBuffer(data)) {\n    data = new Buffer('' + data, options.encoding || 'utf8');\n  }\n  var written = 0;\n  var length = data.length;\n  var position = /a/.test(flag) ? null : 0;\n  try {\n    while (written < length) {\n      written += fs.writeSync(fd, data, written, length - written, position);\n      position += written;\n    }\n  } finally {\n    fs.closeSync(fd);\n  }\n};\n\nfs.appendFile = function(path, data, options, callback_) {\n  var callback = maybeCallback(arguments[arguments.length - 1]);\n\n  if (util.isFunction(options) || !options) {\n    options = { encoding: 'utf8', mode: 438 , flag: 'a' };\n  } else if (util.isString(options)) {\n    options = { encoding: options, mode: 438, flag: 'a' };\n  } else if (!util.isObject(options)) {\n    throw new TypeError('Bad arguments');\n  }\n\n  if (!options.flag)\n    options = util._extend({ flag: 'a' }, options);\n  fs.writeFile(path, data, options, callback);\n};\n\nfs.appendFileSync = function(path, data, options) {\n  if (!options) {\n    options = { encoding: 'utf8', mode: 438 , flag: 'a' };\n  } else if (util.isString(options)) {\n    options = { encoding: options, mode: 438, flag: 'a' };\n  } else if (!util.isObject(options)) {\n    throw new TypeError('Bad arguments');\n  }\n  if (!options.flag)\n    options = util._extend({ flag: 'a' }, options);\n\n  fs.writeFileSync(path, data, options);\n};\n\nfunction FSWatcher() {\n  EventEmitter.call(this);\n\n  var self = this;\n  var FSEvent = process.binding('fs_event_wrap').FSEvent;\n  this._handle = new FSEvent();\n  this._handle.owner = this;\n\n  this._handle.onchange = function(status, event, filename) {\n    if (status < 0) {\n      self._handle.close();\n      self.emit('error', errnoException(status, 'watch'));\n    } else {\n      self.emit('change', event, filename);\n    }\n  };\n}\nutil.inherits(FSWatcher, EventEmitter);\n\nFSWatcher.prototype.start = function(filename, persistent, recursive) {\n  nullCheck(filename);\n  var err = this._handle.start(pathModule._makeLong(filename),\n                               persistent,\n                               recursive);\n  if (err) {\n    this._handle.close();\n    throw errnoException(err, 'watch');\n  }\n};\n\nFSWatcher.prototype.close = function() {\n  this._handle.close();\n};\n\nfs.watch = function(filename) {\n  nullCheck(filename);\n  var watcher;\n  var options;\n  var listener;\n\n  if (util.isObject(arguments[1])) {\n    options = arguments[1];\n    listener = arguments[2];\n  } else {\n    options = {};\n    listener = arguments[1];\n  }\n\n  if (util.isUndefined(options.persistent)) options.persistent = true;\n  if (util.isUndefined(options.recursive)) options.recursive = false;\n\n  watcher = new FSWatcher();\n  watcher.start(filename, options.persistent, options.recursive);\n\n  if (listener) {\n    watcher.addListener('change', listener);\n  }\n\n  return watcher;\n};\n\n\n// Stat Change Watchers\n\nfunction StatWatcher() {\n  EventEmitter.call(this);\n\n  var self = this;\n  this._handle = new binding.StatWatcher();\n\n  // uv_fs_poll is a little more powerful than ev_stat but we curb it for\n  // the sake of backwards compatibility\n  var oldStatus = -1;\n\n  this._handle.onchange = function(current, previous, newStatus) {\n    if (oldStatus === -1 &&\n        newStatus === -1 &&\n        current.nlink === previous.nlink) return;\n\n    oldStatus = newStatus;\n    self.emit('change', current, previous);\n  };\n\n  this._handle.onstop = function() {\n    self.emit('stop');\n  };\n}\nutil.inherits(StatWatcher, EventEmitter);\n\n\nStatWatcher.prototype.start = function(filename, persistent, interval) {\n  nullCheck(filename);\n  this._handle.start(pathModule._makeLong(filename), persistent, interval);\n};\n\n\nStatWatcher.prototype.stop = function() {\n  this._handle.stop();\n};\n\n\nvar statWatchers = {};\nfunction inStatWatchers(filename) {\n  return Object.prototype.hasOwnProperty.call(statWatchers, filename) &&\n      statWatchers[filename];\n}\n\n\nfs.watchFile = function(filename) {\n  nullCheck(filename);\n  filename = pathModule.resolve(filename);\n  var stat;\n  var listener;\n\n  var options = {\n    // Poll interval in milliseconds. 5007 is what libev used to use. It's\n    // a little on the slow side but let's stick with it for now to keep\n    // behavioral changes to a minimum.\n    interval: 5007,\n    persistent: true\n  };\n\n  if (util.isObject(arguments[1])) {\n    options = util._extend(options, arguments[1]);\n    listener = arguments[2];\n  } else {\n    listener = arguments[1];\n  }\n\n  if (!listener) {\n    throw new Error('watchFile requires a listener function');\n  }\n\n  if (inStatWatchers(filename)) {\n    stat = statWatchers[filename];\n  } else {\n    stat = statWatchers[filename] = new StatWatcher();\n    stat.start(filename, options.persistent, options.interval);\n  }\n  stat.addListener('change', listener);\n  return stat;\n};\n\nfs.unwatchFile = function(filename, listener) {\n  nullCheck(filename);\n  filename = pathModule.resolve(filename);\n  if (!inStatWatchers(filename)) return;\n\n  var stat = statWatchers[filename];\n\n  if (util.isFunction(listener)) {\n    stat.removeListener('change', listener);\n  } else {\n    stat.removeAllListeners('change');\n  }\n\n  if (EventEmitter.listenerCount(stat, 'change') === 0) {\n    stat.stop();\n    statWatchers[filename] = undefined;\n  }\n};\n\n// Regexp that finds the next partion of a (partial) path\n// result is [base_with_slash, base], e.g. ['somedir/', 'somedir']\nif (isWindows) {\n  var nextPartRe = /(.*?)(?:[\\/\\\\]+|$)/g;\n} else {\n  var nextPartRe = /(.*?)(?:[\\/]+|$)/g;\n}\n\n// Regex to find the device root, including trailing slash. E.g. 'c:\\\\'.\nif (isWindows) {\n  var splitRootRe = /^(?:[a-zA-Z]:|[\\\\\\/]{2}[^\\\\\\/]+[\\\\\\/][^\\\\\\/]+)?[\\\\\\/]*/;\n} else {\n  var splitRootRe = /^[\\/]*/;\n}\n\nfs.realpathSync = function realpathSync(p, cache) {\n  // make p is absolute\n  p = pathModule.resolve(p);\n\n  if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {\n    return cache[p];\n  }\n\n  var original = p,\n      seenLinks = {},\n      knownHard = {};\n\n  // current character position in p\n  var pos;\n  // the partial path so far, including a trailing slash if any\n  var current;\n  // the partial path without a trailing slash (except when pointing at a root)\n  var base;\n  // the partial path scanned in the previous round, with slash\n  var previous;\n\n  start();\n\n  function start() {\n    // Skip over roots\n    var m = splitRootRe.exec(p);\n    pos = m[0].length;\n    current = m[0];\n    base = m[0];\n    previous = '';\n\n    // On windows, check that the root exists. On unix there is no need.\n    if (isWindows && !knownHard[base]) {\n      fs.lstatSync(base);\n      knownHard[base] = true;\n    }\n  }\n\n  // walk down the path, swapping out linked pathparts for their real\n  // values\n  // NB: p.length changes.\n  while (pos < p.length) {\n    // find the next part\n    nextPartRe.lastIndex = pos;\n    var result = nextPartRe.exec(p);\n    previous = current;\n    current += result[0];\n    base = previous + result[1];\n    pos = nextPartRe.lastIndex;\n\n    // continue if not a symlink\n    if (knownHard[base] || (cache && cache[base] === base)) {\n      continue;\n    }\n\n    var resolvedLink;\n    if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {\n      // some known symbolic link.  no need to stat again.\n      resolvedLink = cache[base];\n    } else {\n      var stat = fs.lstatSync(base);\n      if (!stat.isSymbolicLink()) {\n        knownHard[base] = true;\n        if (cache) cache[base] = base;\n        continue;\n      }\n\n      // read the link if it wasn't read before\n      // dev/ino always return 0 on windows, so skip the check.\n      var linkTarget = null;\n      if (!isWindows) {\n        var id = stat.dev.toString(32) + ':' + stat.ino.toString(32);\n        if (seenLinks.hasOwnProperty(id)) {\n          linkTarget = seenLinks[id];\n        }\n      }\n      if (util.isNull(linkTarget)) {\n        fs.statSync(base);\n        linkTarget = fs.readlinkSync(base);\n      }\n      resolvedLink = pathModule.resolve(previous, linkTarget);\n      // track this, if given a cache.\n      if (cache) cache[base] = resolvedLink;\n      if (!isWindows) seenLinks[id] = linkTarget;\n    }\n\n    // resolve the link, then start over\n    p = pathModule.resolve(resolvedLink, p.slice(pos));\n    start();\n  }\n\n  if (cache) cache[original] = p;\n\n  return p;\n};\n\n\nfs.realpath = function realpath(p, cache, cb) {\n  if (!util.isFunction(cb)) {\n    cb = maybeCallback(cache);\n    cache = null;\n  }\n\n  // make p is absolute\n  p = pathModule.resolve(p);\n\n  if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {\n    return process.nextTick(cb.bind(null, null, cache[p]));\n  }\n\n  var original = p,\n      seenLinks = {},\n      knownHard = {};\n\n  // current character position in p\n  var pos;\n  // the partial path so far, including a trailing slash if any\n  var current;\n  // the partial path without a trailing slash (except when pointing at a root)\n  var base;\n  // the partial path scanned in the previous round, with slash\n  var previous;\n\n  start();\n\n  function start() {\n    // Skip over roots\n    var m = splitRootRe.exec(p);\n    pos = m[0].length;\n    current = m[0];\n    base = m[0];\n    previous = '';\n\n    // On windows, check that the root exists. On unix there is no need.\n    if (isWindows && !knownHard[base]) {\n      fs.lstat(base, function(err) {\n        if (err) return cb(err);\n        knownHard[base] = true;\n        LOOP();\n      });\n    } else {\n      process.nextTick(LOOP);\n    }\n  }\n\n  // walk down the path, swapping out linked pathparts for their real\n  // values\n  function LOOP() {\n    // stop if scanned past end of path\n    if (pos >= p.length) {\n      if (cache) cache[original] = p;\n      return cb(null, p);\n    }\n\n    // find the next part\n    nextPartRe.lastIndex = pos;\n    var result = nextPartRe.exec(p);\n    previous = current;\n    current += result[0];\n    base = previous + result[1];\n    pos = nextPartRe.lastIndex;\n\n    // continue if not a symlink\n    if (knownHard[base] || (cache && cache[base] === base)) {\n      return process.nextTick(LOOP);\n    }\n\n    if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {\n      // known symbolic link.  no need to stat again.\n      return gotResolvedLink(cache[base]);\n    }\n\n    return fs.lstat(base, gotStat);\n  }\n\n  function gotStat(err, stat) {\n    if (err) return cb(err);\n\n    // if not a symlink, skip to the next path part\n    if (!stat.isSymbolicLink()) {\n      knownHard[base] = true;\n      if (cache) cache[base] = base;\n      return process.nextTick(LOOP);\n    }\n\n    // stat & read the link if not read before\n    // call gotTarget as soon as the link target is known\n    // dev/ino always return 0 on windows, so skip the check.\n    if (!isWindows) {\n      var id = stat.dev.toString(32) + ':' + stat.ino.toString(32);\n      if (seenLinks.hasOwnProperty(id)) {\n        return gotTarget(null, seenLinks[id], base);\n      }\n    }\n    fs.stat(base, function(err) {\n      if (err) return cb(err);\n\n      fs.readlink(base, function(err, target) {\n        if (!isWindows) seenLinks[id] = target;\n        gotTarget(err, target);\n      });\n    });\n  }\n\n  function gotTarget(err, target, base) {\n    if (err) return cb(err);\n\n    var resolvedLink = pathModule.resolve(previous, target);\n    if (cache) cache[base] = resolvedLink;\n    gotResolvedLink(resolvedLink);\n  }\n\n  function gotResolvedLink(resolvedLink) {\n    // resolve the link, then start over\n    p = pathModule.resolve(resolvedLink, p.slice(pos));\n    start();\n  }\n};\n\n\n\nvar pool;\n\nfunction allocNewPool(poolSize) {\n  pool = new Buffer(poolSize);\n  pool.used = 0;\n}\n\n\n\nfs.createReadStream = function(path, options) {\n  return new ReadStream(path, options);\n};\n\nutil.inherits(ReadStream, Readable);\nfs.ReadStream = ReadStream;\n\nfunction ReadStream(path, options) {\n  if (!(this instanceof ReadStream))\n    return new ReadStream(path, options);\n\n  // a little bit bigger buffer and water marks by default\n  options = util._extend({\n    highWaterMark: 64 * 1024\n  }, options || {});\n\n  Readable.call(this, options);\n\n  this.path = path;\n  this.fd = options.hasOwnProperty('fd') ? options.fd : null;\n  this.flags = options.hasOwnProperty('flags') ? options.flags : 'r';\n  this.mode = options.hasOwnProperty('mode') ? options.mode : 438;\n\n  this.start = options.hasOwnProperty('start') ? options.start : undefined;\n  this.end = options.hasOwnProperty('end') ? options.end : undefined;\n  this.autoClose = options.hasOwnProperty('autoClose') ?\n      options.autoClose : true;\n  this.pos = undefined;\n\n  if (!util.isUndefined(this.start)) {\n    if (!util.isNumber(this.start)) {\n      throw TypeError('start must be a Number');\n    }\n    if (util.isUndefined(this.end)) {\n      this.end = Infinity;\n    } else if (!util.isNumber(this.end)) {\n      throw TypeError('end must be a Number');\n    }\n\n    if (this.start > this.end) {\n      throw new Error('start must be <= end');\n    }\n\n    this.pos = this.start;\n  }\n\n  if (!util.isNumber(this.fd))\n    this.open();\n\n  this.on('end', function() {\n    if (this.autoClose) {\n      this.destroy();\n    }\n  });\n}\n\nfs.FileReadStream = fs.ReadStream; // support the legacy name\n\nReadStream.prototype.open = function() {\n  var self = this;\n  fs.open(this.path, this.flags, this.mode, function(er, fd) {\n    if (er) {\n      if (self.autoClose) {\n        self.destroy();\n      }\n      self.emit('error', er);\n      return;\n    }\n\n    self.fd = fd;\n    self.emit('open', fd);\n    // start the flow of data.\n    self.read();\n  });\n};\n\nReadStream.prototype._read = function(n) {\n  if (!util.isNumber(this.fd))\n    return this.once('open', function() {\n      this._read(n);\n    });\n\n  if (this.destroyed)\n    return;\n\n  if (!pool || pool.length - pool.used < kMinPoolSpace) {\n    // discard the old pool.\n    pool = null;\n    allocNewPool(this._readableState.highWaterMark);\n  }\n\n  // Grab another reference to the pool in the case that while we're\n  // in the thread pool another read() finishes up the pool, and\n  // allocates a new one.\n  var thisPool = pool;\n  var toRead = Math.min(pool.length - pool.used, n);\n  var start = pool.used;\n\n  if (!util.isUndefined(this.pos))\n    toRead = Math.min(this.end - this.pos + 1, toRead);\n\n  // already read everything we were supposed to read!\n  // treat as EOF.\n  if (toRead <= 0)\n    return this.push(null);\n\n  // the actual read.\n  var self = this;\n  fs.read(this.fd, pool, pool.used, toRead, this.pos, onread);\n\n  // move the pool positions, and internal position for reading.\n  if (!util.isUndefined(this.pos))\n    this.pos += toRead;\n  pool.used += toRead;\n\n  function onread(er, bytesRead) {\n    if (er) {\n      if (self.autoClose) {\n        self.destroy();\n      }\n      self.emit('error', er);\n    } else {\n      var b = null;\n      if (bytesRead > 0)\n        b = thisPool.slice(start, start + bytesRead);\n\n      self.push(b);\n    }\n  }\n};\n\n\nReadStream.prototype.destroy = function() {\n  if (this.destroyed)\n    return;\n  this.destroyed = true;\n\n  if (util.isNumber(this.fd))\n    this.close();\n};\n\n\nReadStream.prototype.close = function(cb) {\n  var self = this;\n  if (cb)\n    this.once('close', cb);\n  if (this.closed || !util.isNumber(this.fd)) {\n    if (!util.isNumber(this.fd)) {\n      this.once('open', close);\n      return;\n    }\n    return process.nextTick(this.emit.bind(this, 'close'));\n  }\n  this.closed = true;\n  close();\n\n  function close(fd) {\n    fs.close(fd || self.fd, function(er) {\n      if (er)\n        self.emit('error', er);\n      else\n        self.emit('close');\n    });\n    self.fd = null;\n  }\n};\n\n\n\n\nfs.createWriteStream = function(path, options) {\n  return new WriteStream(path, options);\n};\n\nutil.inherits(WriteStream, Writable);\nfs.WriteStream = WriteStream;\nfunction WriteStream(path, options) {\n  if (!(this instanceof WriteStream))\n    return new WriteStream(path, options);\n\n  options = options || {};\n\n  Writable.call(this, options);\n\n  this.path = path;\n  this.fd = null;\n\n  this.fd = options.hasOwnProperty('fd') ? options.fd : null;\n  this.flags = options.hasOwnProperty('flags') ? options.flags : 'w';\n  this.mode = options.hasOwnProperty('mode') ? options.mode : 438;\n\n  this.start = options.hasOwnProperty('start') ? options.start : undefined;\n  this.pos = undefined;\n  this.bytesWritten = 0;\n\n  if (!util.isUndefined(this.start)) {\n    if (!util.isNumber(this.start)) {\n      throw TypeError('start must be a Number');\n    }\n    if (this.start < 0) {\n      throw new Error('start must be >= zero');\n    }\n\n    this.pos = this.start;\n  }\n\n  if (!util.isNumber(this.fd))\n    this.open();\n\n  // dispose on finish.\n  this.once('finish', this.close);\n}\n\nfs.FileWriteStream = fs.WriteStream; // support the legacy name\n\n\nWriteStream.prototype.open = function() {\n  fs.open(this.path, this.flags, this.mode, function(er, fd) {\n    if (er) {\n      this.destroy();\n      this.emit('error', er);\n      return;\n    }\n\n    this.fd = fd;\n    this.emit('open', fd);\n  }.bind(this));\n};\n\n\nWriteStream.prototype._write = function(data, encoding, cb) {\n  if (!util.isBuffer(data))\n    return this.emit('error', new Error('Invalid data'));\n\n  if (!util.isNumber(this.fd))\n    return this.once('open', function() {\n      this._write(data, encoding, cb);\n    });\n\n  var self = this;\n  fs.write(this.fd, data, 0, data.length, this.pos, function(er, bytes) {\n    if (er) {\n      self.destroy();\n      return cb(er);\n    }\n    self.bytesWritten += bytes;\n    cb();\n  });\n\n  if (!util.isUndefined(this.pos))\n    this.pos += data.length;\n};\n\n\nWriteStream.prototype.destroy = ReadStream.prototype.destroy;\nWriteStream.prototype.close = ReadStream.prototype.close;\n\n// There is no shutdown() for files.\nWriteStream.prototype.destroySoon = WriteStream.prototype.end;\n\n\n// SyncWriteStream is internal. DO NOT USE.\n// Temporary hack for process.stdout and process.stderr when piped to files.\nfunction SyncWriteStream(fd, options) {\n  Stream.call(this);\n\n  options = options || {};\n\n  this.fd = fd;\n  this.writable = true;\n  this.readable = false;\n  this.autoClose = options.hasOwnProperty('autoClose') ?\n      options.autoClose : true;\n}\n\nutil.inherits(SyncWriteStream, Stream);\n\n\n// Export\nfs.SyncWriteStream = SyncWriteStream;\n\n\nSyncWriteStream.prototype.write = function(data, arg1, arg2) {\n  var encoding, cb;\n\n  // parse arguments\n  if (arg1) {\n    if (util.isString(arg1)) {\n      encoding = arg1;\n      cb = arg2;\n    } else if (util.isFunction(arg1)) {\n      cb = arg1;\n    } else {\n      throw new Error('bad arg');\n    }\n  }\n  assertEncoding(encoding);\n\n  // Change strings to buffers. SLOW\n  if (util.isString(data)) {\n    data = new Buffer(data, encoding);\n  }\n\n  fs.writeSync(this.fd, data, 0, data.length);\n\n  if (cb) {\n    process.nextTick(cb);\n  }\n\n  return true;\n};\n\n\nSyncWriteStream.prototype.end = function(data, arg1, arg2) {\n  if (data) {\n    this.write(data, arg1, arg2);\n  }\n  this.destroy();\n};\n\n\nSyncWriteStream.prototype.destroy = function() {\n  if (this.autoClose)\n    fs.closeSync(this.fd);\n  this.fd = null;\n  this.emit('close');\n  return true;\n};\n\nSyncWriteStream.prototype.destroySoon = SyncWriteStream.prototype.destroy;\n",
  @"// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar util = require('util');\nvar EventEmitter = require('events').EventEmitter;\n\n\nexports.IncomingMessage = require('_http_incoming').IncomingMessage;\n\n\nvar common = require('_http_common');\nexports.METHODS = util._extend([], common.methods).sort();\nexports.parsers = common.parsers;\n\n\nexports.OutgoingMessage = require('_http_outgoing').OutgoingMessage;\n\n\nvar server = require('_http_server');\nexports.ServerResponse = server.ServerResponse;\nexports.STATUS_CODES = server.STATUS_CODES;\n\n\nvar agent = require('_http_agent');\nvar Agent = exports.Agent = agent.Agent;\nexports.globalAgent = agent.globalAgent;\n\nvar client = require('_http_client');\nvar ClientRequest = exports.ClientRequest = client.ClientRequest;\n\nexports.request = function(options, cb) {\n  return new ClientRequest(options, cb);\n};\n\nexports.get = function(options, cb) {\n  var req = exports.request(options, cb);\n  req.end();\n  return req;\n};\n\nexports._connectionListener = server._connectionListener;\nvar Server = exports.Server = server.Server;\n\nexports.createServer = function(requestListener) {\n  return new Server(requestListener);\n};\n\n\n// Legacy Interface\n\nfunction Client(port, host) {\n  if (!(this instanceof Client)) return new Client(port, host);\n  EventEmitter.call(this);\n\n  host = host || 'localhost';\n  port = port || 80;\n  this.host = host;\n  this.port = port;\n  this.agent = new Agent({ host: host, port: port, maxSockets: 1 });\n}\nutil.inherits(Client, EventEmitter);\nClient.prototype.request = function(method, path, headers) {\n  var self = this;\n  var options = {};\n  options.host = self.host;\n  options.port = self.port;\n  if (method[0] === '/') {\n    headers = path;\n    path = method;\n    method = 'GET';\n  }\n  options.method = method;\n  options.path = path;\n  options.headers = headers;\n  options.agent = self.agent;\n  var c = new ClientRequest(options);\n  c.on('error', function(e) {\n    self.emit('error', e);\n  });\n  // The old Client interface emitted 'end' on socket end.\n  // This doesn't map to how we want things to operate in the future\n  // but it will get removed when we remove this legacy interface.\n  c.on('socket', function(s) {\n    s.on('end', function() {\n      if (self._decoder) {\n        var ret = self._decoder.end();\n        if (ret)\n          self.emit('data', ret);\n      }\n      self.emit('end');\n    });\n  });\n  return c;\n};\n\nexports.Client = util.deprecate(Client,\n    'http.Client will be removed soon. Do not use it.');\n\nexports.createClient = util.deprecate(function(port, host) {\n  return new Client(port, host);\n}, 'http.createClient is deprecated. Use `http.request` instead.');\n",
  @"// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar tls = require('tls');\nvar url = require('url');\nvar http = require('http');\nvar util = require('util');\nvar inherits = require('util').inherits;\nvar debug = util.debuglog('https');\n\nfunction Server(opts, requestListener) {\n  if (!(this instanceof Server)) return new Server(opts, requestListener);\n\n  if (process.features.tls_npn && !opts.NPNProtocols) {\n    opts.NPNProtocols = ['http/1.1', 'http/1.0'];\n  }\n\n  tls.Server.call(this, opts, http._connectionListener);\n\n  this.httpAllowHalfOpen = false;\n\n  if (requestListener) {\n    this.addListener('request', requestListener);\n  }\n\n  this.addListener('clientError', function(err, conn) {\n    conn.destroy();\n  });\n\n  this.timeout = 2 * 60 * 1000;\n}\ninherits(Server, tls.Server);\nexports.Server = Server;\n\nServer.prototype.setTimeout = http.Server.prototype.setTimeout;\n\nexports.createServer = function(opts, requestListener) {\n  return new Server(opts, requestListener);\n};\n\n\n// HTTPS agents.\n\nfunction createConnection(port, host, options) {\n  if (util.isObject(port)) {\n    options = port;\n  } else if (util.isObject(host)) {\n    options = host;\n  } else if (util.isObject(options)) {\n    options = options;\n  } else {\n    options = {};\n  }\n\n  if (util.isNumber(port)) {\n    options.port = port;\n  }\n\n  if (util.isString(host)) {\n    options.host = host;\n  }\n\n  debug('createConnection', options);\n  return tls.connect(options);\n}\n\n\nfunction Agent(options) {\n  http.Agent.call(this, options);\n  this.defaultPort = 443;\n  this.protocol = 'https:';\n}\ninherits(Agent, http.Agent);\nAgent.prototype.createConnection = createConnection;\n\nAgent.prototype.getName = function(options) {\n  var name = http.Agent.prototype.getName.call(this, options);\n\n  name += ':';\n  if (options.ca)\n    name += options.ca;\n\n  name += ':';\n  if (options.cert)\n    name += options.cert;\n\n  name += ':';\n  if (options.ciphers)\n    name += options.ciphers;\n\n  name += ':';\n  if (options.key)\n    name += options.key;\n\n  name += ':';\n  if (options.pfx)\n    name += options.pfx;\n\n  name += ':';\n  if (!util.isUndefined(options.rejectUnauthorized))\n    name += options.rejectUnauthorized;\n\n  return name;\n};\n\nvar globalAgent = new Agent();\n\nexports.globalAgent = globalAgent;\nexports.Agent = Agent;\n\nexports.request = function(options, cb) {\n  if (util.isString(options)) {\n    options = url.parse(options);\n  } else {\n    options = util._extend({}, options);\n  }\n  options._defaultAgent = globalAgent;\n  return http.request(options, cb);\n};\n\nexports.get = function(options, cb) {\n  var req = exports.request(options, cb);\n  req.end();\n  return req;\n};\n",
  @"// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar NativeModule = require('native_module');\nvar util = NativeModule.require('util');\nvar runInThisContext = require('vm').runInThisContext;\nvar runInNewContext = require('vm').runInNewContext;\nvar assert = require('assert').ok;\nvar fs = NativeModule.require('fs');\n\n\n// If obj.hasOwnProperty has been overridden, then calling\n// obj.hasOwnProperty(prop) will break.\n// See: https://github.com/joyent/node/issues/1707\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\n\nfunction Module(id, parent) {\n  this.id = id;\n  this.exports = {};\n  this.parent = parent;\n  if (parent && parent.children) {\n    parent.children.push(this);\n  }\n\n  this.filename = null;\n  this.loaded = false;\n  this.children = [];\n}\nmodule.exports = Module;\n\n// Set the environ variable NODE_MODULE_CONTEXTS=1 to make node load all\n// modules in their own context.\nModule._contextLoad = (+process.env['NODE_MODULE_CONTEXTS'] > 0);\nModule._cache = {};\nModule._pathCache = {};\nModule._extensions = {};\nvar modulePaths = [];\nModule.globalPaths = [];\n\nModule.wrapper = NativeModule.wrapper;\nModule.wrap = NativeModule.wrap;\n\nvar path = NativeModule.require('path');\n\nModule._debug = util.debuglog('module');\n\n\n// We use this alias for the preprocessor that filters it out\nvar debug = Module._debug;\n\n\n// given a module name, and a list of paths to test, returns the first\n// matching file in the following precedence.\n//\n// require(\"a.<ext>\")\n//   -> a.<ext>\n//\n// require(\"a\")\n//   -> a\n//   -> a.<ext>\n//   -> a/index.<ext>\n\nfunction statPath(path) {\n  try {\n    return fs.statSync(path);\n  } catch (ex) {}\n  return false;\n}\n\n// check if the directory is a package.json dir\nvar packageMainCache = {};\n\nfunction readPackage(requestPath) {\n  if (hasOwnProperty(packageMainCache, requestPath)) {\n    return packageMainCache[requestPath];\n  }\n\n  try {\n    var jsonPath = path.resolve(requestPath, 'package.json');\n    var json = fs.readFileSync(jsonPath, 'utf8');\n  } catch (e) {\n    return false;\n  }\n\n  try {\n    var pkg = packageMainCache[requestPath] = JSON.parse(json).main;\n  } catch (e) {\n    e.path = jsonPath;\n    e.message = 'Error parsing ' + jsonPath + ': ' + e.message;\n    throw e;\n  }\n  return pkg;\n}\n\nfunction tryPackage(requestPath, exts) {\n  var pkg = readPackage(requestPath);\n\n  if (!pkg) return false;\n\n  var filename = path.resolve(requestPath, pkg);\n  return tryFile(filename) || tryExtensions(filename, exts) ||\n         tryExtensions(path.resolve(filename, 'index'), exts);\n}\n\n// In order to minimize unnecessary lstat() calls,\n// this cache is a list of known-real paths.\n// Set to an empty object to reset.\nModule._realpathCache = {};\n\n// check if the file exists and is not a directory\nfunction tryFile(requestPath) {\n  var stats = statPath(requestPath);\n  if (stats && !stats.isDirectory()) {\n    return fs.realpathSync(requestPath, Module._realpathCache);\n  }\n  return false;\n}\n\n// given a path check a the file exists with any of the set extensions\nfunction tryExtensions(p, exts) {\n  for (var i = 0, EL = exts.length; i < EL; i++) {\n    var filename = tryFile(p + exts[i]);\n\n    if (filename) {\n      return filename;\n    }\n  }\n  return false;\n}\n\n\nModule._findPath = function(request, paths) {\n  var exts = Object.keys(Module._extensions);\n\n  if (request.charAt(0) === '/') {\n    paths = [''];\n  }\n\n  var trailingSlash = (request.slice(-1) === '/');\n\n  var cacheKey = JSON.stringify({request: request, paths: paths});\n  if (Module._pathCache[cacheKey]) {\n    return Module._pathCache[cacheKey];\n  }\n\n  // For each path\n  for (var i = 0, PL = paths.length; i < PL; i++) {\n    var basePath = path.resolve(paths[i], request);\n    var filename;\n\n    if (!trailingSlash) {\n      // try to join the request to the path\n      filename = tryFile(basePath);\n\n      if (!filename && !trailingSlash) {\n        // try it with each of the extensions\n        filename = tryExtensions(basePath, exts);\n      }\n    }\n\n    if (!filename) {\n      filename = tryPackage(basePath, exts);\n    }\n\n    if (!filename) {\n      // try it with each of the extensions at \"index\"\n      filename = tryExtensions(path.resolve(basePath, 'index'), exts);\n    }\n\n    if (filename) {\n      Module._pathCache[cacheKey] = filename;\n      return filename;\n    }\n  }\n  return false;\n};\n\n// 'from' is the __dirname of the module.\nModule._nodeModulePaths = function(from) {\n  // guarantee that 'from' is absolute.\n  from = path.resolve(from);\n\n  // note: this approach *only* works when the path is guaranteed\n  // to be absolute.  Doing a fully-edge-case-correct path.split\n  // that works on both Windows and Posix is non-trivial.\n  var splitRe = process.platform === 'win32' ? /[\\/\\\\]/ : /\\//;\n  var paths = [];\n  var parts = from.split(splitRe);\n\n  for (var tip = parts.length - 1; tip >= 0; tip--) {\n    // don't search in .../node_modules/node_modules\n    if (parts[tip] === 'node_modules') continue;\n    var dir = parts.slice(0, tip + 1).concat('node_modules').join(path.sep);\n    paths.push(dir);\n  }\n\n  return paths;\n};\n\n\nModule._resolveLookupPaths = function(request, parent) {\n  if (NativeModule.exists(request)) {\n    return [request, []];\n  }\n\n  var start = request.substring(0, 2);\n  if (start !== './' && start !== '..') {\n    var paths = modulePaths;\n    if (parent) {\n      if (!parent.paths) parent.paths = [];\n      paths = parent.paths.concat(paths);\n    }\n    return [request, paths];\n  }\n\n  // with --eval, parent.id is not set and parent.filename is null\n  if (!parent || !parent.id || !parent.filename) {\n    // make require('./path/to/foo') work - normally the path is taken\n    // from realpath(__filename) but with eval there is no filename\n    var mainPaths = ['.'].concat(modulePaths);\n    mainPaths = Module._nodeModulePaths('.').concat(mainPaths);\n    return [request, mainPaths];\n  }\n\n  // Is the parent an index module?\n  // We can assume the parent has a valid extension,\n  // as it already has been accepted as a module.\n  var isIndex = /^index\\.\\w+?$/.test(path.basename(parent.filename));\n  var parentIdPath = isIndex ? parent.id : path.dirname(parent.id);\n  var id = path.resolve(parentIdPath, request);\n\n  // make sure require('./path') and require('path') get distinct ids, even\n  // when called from the toplevel js file\n  if (parentIdPath === '.' && id.indexOf('/') === -1) {\n    id = './' + id;\n  }\n\n  debug('RELATIVE: requested:' + request +\n        ' set ID to: ' + id + ' from ' + parent.id);\n\n  return [id, [path.dirname(parent.filename)]];\n};\n\n\n// Check the cache for the requested file.\n// 1. If a module already exists in the cache: return its exports object.\n// 2. If the module is native: call `NativeModule.require()` with the\n//    filename and return the result.\n// 3. Otherwise, create a new module for the file and save it to the cache.\n//    Then have it load  the file contents before returning its exports\n//    object.\nModule._load = function(request, parent, isMain) {\n  if (parent) {\n    debug('Module._load REQUEST  ' + (request) + ' parent: ' + parent.id);\n  }\n\n  var filename = Module._resolveFilename(request, parent);\n\n  var cachedModule = Module._cache[filename];\n  if (cachedModule) {\n    return cachedModule.exports;\n  }\n\n  if (NativeModule.exists(filename)) {\n    // REPL is a special case, because it needs the real require.\n    if (filename == 'repl') {\n      var replModule = new Module('repl');\n      replModule._compile(NativeModule.getSource('repl'), 'repl.js');\n      NativeModule._cache.repl = replModule;\n      return replModule.exports;\n    }\n\n    debug('load native module ' + request);\n    return NativeModule.require(filename);\n  }\n\n  var module = new Module(filename, parent);\n\n  if (isMain) {\n    process.mainModule = module;\n    module.id = '.';\n  }\n\n  Module._cache[filename] = module;\n\n  var hadException = true;\n\n  try {\n    module.load(filename);\n    hadException = false;\n  } finally {\n    if (hadException) {\n      delete Module._cache[filename];\n    }\n  }\n\n  return module.exports;\n};\n\nModule._resolveFilename = function(request, parent) {\n  if (NativeModule.exists(request)) {\n    return request;\n  }\n\n  var resolvedModule = Module._resolveLookupPaths(request, parent);\n  var id = resolvedModule[0];\n  var paths = resolvedModule[1];\n\n  // look up the filename first, since that's the cache key.\n  debug('looking for ' + JSON.stringify(id) +\n        ' in ' + JSON.stringify(paths));\n\n  var filename = Module._findPath(request, paths);\n  if (!filename) {\n    var err = new Error(\"Cannot find module '\" + request + \"'\");\n    err.code = 'MODULE_NOT_FOUND';\n    throw err;\n  }\n  return filename;\n};\n\n\n// Given a file name, pass it to the proper extension handler.\nModule.prototype.load = function(filename) {\n  debug('load ' + JSON.stringify(filename) +\n        ' for module ' + JSON.stringify(this.id));\n\n  assert(!this.loaded);\n  this.filename = filename;\n  this.paths = Module._nodeModulePaths(path.dirname(filename));\n\n  var extension = path.extname(filename) || '.js';\n  if (!Module._extensions[extension]) extension = '.js';\n  Module._extensions[extension](this, filename);\n  this.loaded = true;\n};\n\n\n// Loads a module at the given file path. Returns that module's\n// `exports` property.\nModule.prototype.require = function(path) {\n  assert(util.isString(path), 'path must be a string');\n  assert(path, 'missing path');\n  return Module._load(path, this);\n};\n\n\n// Resolved path to process.argv[1] will be lazily placed here\n// (needed for setting breakpoint when called with --debug-brk)\nvar resolvedArgv;\n\n\n// Run the file contents in the correct scope or sandbox. Expose\n// the correct helper variables (require, module, exports) to\n// the file.\n// Returns exception, if any.\nModule.prototype._compile = function(content, filename) {\n  var self = this;\n  // remove shebang\n  content = content.replace(/^\\#\\!.*/, '');\n\n  function require(path) {\n    return self.require(path);\n  }\n\n  require.resolve = function(request) {\n    return Module._resolveFilename(request, self);\n  };\n\n  Object.defineProperty(require, 'paths', { get: function() {\n    throw new Error('require.paths is removed. Use ' +\n                    'node_modules folders, or the NODE_PATH ' +\n                    'environment variable instead.');\n  }});\n\n  require.main = process.mainModule;\n\n  // Enable support to add extra extension types\n  require.extensions = Module._extensions;\n  require.registerExtension = function() {\n    throw new Error('require.registerExtension() removed. Use ' +\n                    'require.extensions instead.');\n  };\n\n  require.cache = Module._cache;\n\n  var dirname = path.dirname(filename);\n\n  if (Module._contextLoad) {\n    if (self.id !== '.') {\n      debug('load submodule');\n      // not root module\n      var sandbox = {};\n      for (var k in global) {\n        sandbox[k] = global[k];\n      }\n      sandbox.require = require;\n      sandbox.exports = self.exports;\n      sandbox.__filename = filename;\n      sandbox.__dirname = dirname;\n      sandbox.module = self;\n      sandbox.global = sandbox;\n      sandbox.root = root;\n\n      return runInNewContext(content, sandbox, { filename: filename });\n    }\n\n    debug('load root module');\n    // root module\n    global.require = require;\n    global.exports = self.exports;\n    global.__filename = filename;\n    global.__dirname = dirname;\n    global.module = self;\n\n    return runInThisContext(content, { filename: filename });\n  }\n\n  // create wrapper function\n  var wrapper = Module.wrap(content);\n\n  var compiledWrapper = runInThisContext(wrapper, { filename: filename });\n  if (global.v8debug) {\n    if (!resolvedArgv) {\n      // we enter the repl if we're not given a filename argument.\n      if (process.argv[1]) {\n        resolvedArgv = Module._resolveFilename(process.argv[1], null);\n      } else {\n        resolvedArgv = 'repl';\n      }\n    }\n\n    // Set breakpoint on module start\n    if (filename === resolvedArgv) {\n      global.v8debug.Debug.setBreakPoint(compiledWrapper, 0, 0);\n    }\n  }\n  var args = [self.exports, require, self, filename, dirname];\n  return compiledWrapper.apply(self.exports, args);\n};\n\n\nfunction stripBOM(content) {\n  // Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)\n  // because the buffer-to-string conversion in `fs.readFileSync()`\n  // translates it to FEFF, the UTF-16 BOM.\n  if (content.charCodeAt(0) === 0xFEFF) {\n    content = content.slice(1);\n  }\n  return content;\n}\n\n\n// Native extension for .js\nModule._extensions['.js'] = function(module, filename) {\n  var content = fs.readFileSync(filename, 'utf8');\n  module._compile(stripBOM(content), filename);\n};\n\n\n// Native extension for .json\nModule._extensions['.json'] = function(module, filename) {\n  var content = fs.readFileSync(filename, 'utf8');\n  try {\n    module.exports = JSON.parse(stripBOM(content));\n  } catch (err) {\n    err.message = filename + ': ' + err.message;\n    throw err;\n  }\n};\n\n\n//Native extension for .node\nModule._extensions['.node'] = process.dlopen;\n\n\n// bootstrap main module.\nModule.runMain = function() {\n  // Load the main module--the command line argument.\n  Module._load(process.argv[1], null, true);\n  // Handle any nextTicks added in the first tick of the program\n  process._tickCallback();\n};\n\nModule._initPaths = function() {\n  var isWindows = process.platform === 'win32';\n\n  if (isWindows) {\n    var homeDir = process.env.USERPROFILE;\n  } else {\n    var homeDir = process.env.HOME;\n  }\n\n  var paths = [path.resolve(process.execPath, '..', '..', 'lib', 'node')];\n\n  if (homeDir) {\n    paths.unshift(path.resolve(homeDir, '.node_libraries'));\n    paths.unshift(path.resolve(homeDir, '.node_modules'));\n  }\n\n  if (process.env['NODE_PATH']) {\n    paths = process.env['NODE_PATH'].split(path.delimiter).concat(paths);\n  }\n\n  modulePaths = paths;\n\n  // clone as a read-only copy, for introspection.\n  Module.globalPaths = modulePaths.slice(0);\n};\n\n// bootstrap repl\nModule.requireRepl = function() {\n  return Module._load('repl', '.');\n};\n\nModule._initPaths();\n\n// backwards compatibility\nModule.Module = Module;\n",
  @"// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar events = require('events');\nvar stream = require('stream');\nvar timers = require('timers');\nvar util = require('util');\nvar assert = require('assert');\nvar cares = process.binding('cares_wrap');\nvar uv = process.binding('uv');\nvar Pipe = process.binding('pipe_wrap').Pipe;\n\n\nvar cluster;\nvar errnoException = util._errnoException;\n\nfunction noop() {}\n\n// constructor for lazy loading\nfunction createPipe() {\n  return new Pipe();\n}\n\n// constructor for lazy loading\nfunction createTCP() {\n  var TCP = process.binding('tcp_wrap').TCP;\n  return new TCP();\n}\n\n\nfunction createHandle(fd) {\n  var tty = process.binding('tty_wrap');\n  var type = tty.guessHandleType(fd);\n  if (type === 'PIPE') return createPipe();\n  if (type === 'TCP') return createTCP();\n  throw new TypeError('Unsupported fd type: ' + type);\n}\n\n\nvar debug = util.debuglog('net');\n\nfunction isPipeName(s) {\n  return util.isString(s) && toNumber(s) === false;\n}\n\n\nexports.createServer = function() {\n  return new Server(arguments[0], arguments[1]);\n};\n\n\n// Target API:\n//\n// var s = net.connect({port: 80, host: 'google.com'}, function() {\n//   ...\n// });\n//\n// There are various forms:\n//\n// connect(options, [cb])\n// connect(port, [host], [cb])\n// connect(path, [cb]);\n//\nexports.connect = exports.createConnection = function() {\n  var args = normalizeConnectArgs(arguments);\n  debug('createConnection', args);\n  var s = new Socket(args[0]);\n  return Socket.prototype.connect.apply(s, args);\n};\n\n// Returns an array [options] or [options, cb]\n// It is the same as the argument of Socket.prototype.connect().\nfunction normalizeConnectArgs(args) {\n  var options = {};\n\n  if (util.isObject(args[0])) {\n    // connect(options, [cb])\n    options = args[0];\n  } else if (isPipeName(args[0])) {\n    // connect(path, [cb]);\n    options.path = args[0];\n  } else {\n    // connect(port, [host], [cb])\n    options.port = args[0];\n    if (util.isString(args[1])) {\n      options.host = args[1];\n    }\n  }\n\n  var cb = args[args.length - 1];\n  return util.isFunction(cb) ? [options, cb] : [options];\n}\nexports._normalizeConnectArgs = normalizeConnectArgs;\n\n\n// called when creating new Socket, or when re-using a closed Socket\nfunction initSocketHandle(self) {\n  self.destroyed = false;\n  self.bytesRead = 0;\n  self._bytesDispatched = 0;\n\n  // Handle creation may be deferred to bind() or connect() time.\n  if (self._handle) {\n    self._handle.owner = self;\n    self._handle.onread = onread;\n\n    // If handle doesn't support writev - neither do we\n    if (!self._handle.writev)\n      self._writev = null;\n  }\n}\n\nfunction Socket(options) {\n  if (!(this instanceof Socket)) return new Socket(options);\n\n  this._connecting = false;\n  this._hadError = false;\n  this._handle = null;\n  this._host = null;\n\n  if (util.isNumber(options))\n    options = { fd: options }; // Legacy interface.\n  else if (util.isUndefined(options))\n    options = {};\n\n  stream.Duplex.call(this, options);\n\n  if (options.handle) {\n    this._handle = options.handle; // private\n  } else if (!util.isUndefined(options.fd)) {\n    this._handle = createHandle(options.fd);\n    this._handle.open(options.fd);\n    if ((options.fd == 1 || options.fd == 2) &&\n        (this._handle instanceof Pipe) &&\n        process.platform === 'win32') {\n      // Make stdout and stderr blocking on Windows\n      var err = this._handle.setBlocking(true);\n      if (err)\n        throw errnoException(err, 'setBlocking');\n    }\n    this.readable = options.readable !== false;\n    this.writable = options.writable !== false;\n  } else {\n    // these will be set once there is a connection\n    this.readable = this.writable = false;\n  }\n\n  // shut down the socket when we're finished with it.\n  this.on('finish', onSocketFinish);\n  this.on('_socketEnd', onSocketEnd);\n\n  initSocketHandle(this);\n\n  this._pendingData = null;\n  this._pendingEncoding = '';\n\n  // handle strings directly\n  this._writableState.decodeStrings = false;\n\n  // default to *not* allowing half open sockets\n  this.allowHalfOpen = options && options.allowHalfOpen || false;\n\n  // if we have a handle, then start the flow of data into the\n  // buffer.  if not, then this will happen when we connect\n  if (this._handle && options.readable !== false)\n    this.read(0);\n}\nutil.inherits(Socket, stream.Duplex);\n\n// the user has called .end(), and all the bytes have been\n// sent out to the other side.\n// If allowHalfOpen is false, or if the readable side has\n// ended already, then destroy.\n// If allowHalfOpen is true, then we need to do a shutdown,\n// so that only the writable side will be cleaned up.\nfunction onSocketFinish() {\n  // If still connecting - defer handling 'finish' until 'connect' will happen\n  if (this._connecting) {\n    debug('osF: not yet connected');\n    return this.once('connect', onSocketFinish);\n  }\n\n  debug('onSocketFinish');\n  if (!this.readable || this._readableState.ended) {\n    debug('oSF: ended, destroy', this._readableState);\n    return this.destroy();\n  }\n\n  debug('oSF: not ended, call shutdown()');\n\n  // otherwise, just shutdown, or destroy() if not possible\n  if (!this._handle || !this._handle.shutdown)\n    return this.destroy();\n\n  var req = { oncomplete: afterShutdown };\n  var err = this._handle.shutdown(req);\n\n  if (err)\n    return this._destroy(errnoException(err, 'shutdown'));\n}\n\n\nfunction afterShutdown(status, handle, req) {\n  var self = handle.owner;\n\n  debug('afterShutdown destroyed=%j', self.destroyed,\n        self._readableState);\n\n  // callback may come after call to destroy.\n  if (self.destroyed)\n    return;\n\n  if (self._readableState.ended) {\n    debug('readableState ended, destroying');\n    self.destroy();\n  } else {\n    self.once('_socketEnd', self.destroy);\n  }\n}\n\n// the EOF has been received, and no more bytes are coming.\n// if the writable side has ended already, then clean everything\n// up.\nfunction onSocketEnd() {\n  // XXX Should not have to do as much crap in this function.\n  // ended should already be true, since this is called *after*\n  // the EOF errno and onread has eof'ed\n  debug('onSocketEnd', this._readableState);\n  this._readableState.ended = true;\n  if (this._readableState.endEmitted) {\n    this.readable = false;\n    maybeDestroy(this);\n  } else {\n    this.once('end', function() {\n      this.readable = false;\n      maybeDestroy(this);\n    });\n    this.read(0);\n  }\n\n  if (!this.allowHalfOpen) {\n    this.write = writeAfterFIN;\n    this.destroySoon();\n  }\n}\n\n// Provide a better error message when we call end() as a result\n// of the other side sending a FIN.  The standard 'write after end'\n// is overly vague, and makes it seem like the user's code is to blame.\nfunction writeAfterFIN(chunk, encoding, cb) {\n  if (util.isFunction(encoding)) {\n    cb = encoding;\n    encoding = null;\n  }\n\n  var er = new Error('This socket has been ended by the other party');\n  er.code = 'EPIPE';\n  var self = this;\n  // TODO: defer error events consistently everywhere, not just the cb\n  self.emit('error', er);\n  if (util.isFunction(cb)) {\n    process.nextTick(function() {\n      cb(er);\n    });\n  }\n}\n\nexports.Socket = Socket;\nexports.Stream = Socket; // Legacy naming.\n\nSocket.prototype.read = function(n) {\n  if (n === 0)\n    return stream.Readable.prototype.read.call(this, n);\n\n  this.read = stream.Readable.prototype.read;\n  this._consuming = true;\n  return this.read(n);\n};\n\n\nSocket.prototype.listen = function() {\n  debug('socket.listen');\n  var self = this;\n  self.on('connection', arguments[0]);\n  listen(self, null, null, null);\n};\n\n\nSocket.prototype.setTimeout = function(msecs, callback) {\n  if (msecs > 0 && !isNaN(msecs) && isFinite(msecs)) {\n    timers.enroll(this, msecs);\n    timers._unrefActive(this);\n    if (callback) {\n      this.once('timeout', callback);\n    }\n  } else if (msecs === 0) {\n    timers.unenroll(this);\n    if (callback) {\n      this.removeListener('timeout', callback);\n    }\n  }\n};\n\n\nSocket.prototype._onTimeout = function() {\n  debug('_onTimeout');\n  this.emit('timeout');\n};\n\n\nSocket.prototype.setNoDelay = function(enable) {\n  // backwards compatibility: assume true when `enable` is omitted\n  if (this._handle && this._handle.setNoDelay)\n    this._handle.setNoDelay(util.isUndefined(enable) ? true : !!enable);\n};\n\n\nSocket.prototype.setKeepAlive = function(setting, msecs) {\n  if (this._handle && this._handle.setKeepAlive)\n    this._handle.setKeepAlive(setting, ~~(msecs / 1000));\n};\n\n\nSocket.prototype.address = function() {\n  return this._getsockname();\n};\n\n\nObject.defineProperty(Socket.prototype, 'readyState', {\n  get: function() {\n    if (this._connecting) {\n      return 'opening';\n    } else if (this.readable && this.writable) {\n      return 'open';\n    } else if (this.readable && !this.writable) {\n      return 'readOnly';\n    } else if (!this.readable && this.writable) {\n      return 'writeOnly';\n    } else {\n      return 'closed';\n    }\n  }\n});\n\n\nObject.defineProperty(Socket.prototype, 'bufferSize', {\n  get: function() {\n    if (this._handle) {\n      return this._handle.writeQueueSize + this._writableState.length;\n    }\n  }\n});\n\n\n// Just call handle.readStart until we have enough in the buffer\nSocket.prototype._read = function(n) {\n  debug('_read');\n\n  if (this._connecting || !this._handle) {\n    debug('_read wait for connection');\n    this.once('connect', this._read.bind(this, n));\n  } else if (!this._handle.reading) {\n    // not already reading, start the flow\n    debug('Socket._read readStart');\n    this._handle.reading = true;\n    var err = this._handle.readStart();\n    if (err)\n      this._destroy(errnoException(err, 'read'));\n  }\n};\n\n\nSocket.prototype.end = function(data, encoding) {\n  stream.Duplex.prototype.end.call(this, data, encoding);\n  this.writable = false;\n  DTRACE_NET_STREAM_END(this);\n\n  // just in case we're waiting for an EOF.\n  if (this.readable && !this._readableState.endEmitted)\n    this.read(0);\n  else\n    maybeDestroy(this);\n};\n\n\n// Call whenever we set writable=false or readable=false\nfunction maybeDestroy(socket) {\n  if (!socket.readable &&\n      !socket.writable &&\n      !socket.destroyed &&\n      !socket._connecting &&\n      !socket._writableState.length) {\n    socket.destroy();\n  }\n}\n\n\nSocket.prototype.destroySoon = function() {\n  if (this.writable)\n    this.end();\n\n  if (this._writableState.finished)\n    this.destroy();\n  else\n    this.once('finish', this.destroy);\n};\n\n\nSocket.prototype._destroy = function(exception, cb) {\n  debug('destroy');\n\n  var self = this;\n\n  function fireErrorCallbacks() {\n    if (cb) cb(exception);\n    if (exception && !self._writableState.errorEmitted) {\n      process.nextTick(function() {\n        self.emit('error', exception);\n      });\n      self._writableState.errorEmitted = true;\n    }\n  };\n\n  if (this.destroyed) {\n    debug('already destroyed, fire error callbacks');\n    fireErrorCallbacks();\n    return;\n  }\n\n  self._connecting = false;\n\n  this.readable = this.writable = false;\n\n  timers.unenroll(this);\n\n  debug('close');\n  if (this._handle) {\n    if (this !== process.stderr)\n      debug('close handle');\n    var isException = exception ? true : false;\n    this._handle.close(function() {\n      debug('emit close');\n      self.emit('close', isException);\n    });\n    this._handle.onread = noop;\n    this._handle = null;\n  }\n\n  // we set destroyed to true before firing error callbacks in order\n  // to make it re-entrance safe in case Socket.prototype.destroy()\n  // is called within callbacks\n  this.destroyed = true;\n  fireErrorCallbacks();\n\n  if (this.server) {\n    COUNTER_NET_SERVER_CONNECTION_CLOSE(this);\n    debug('has server');\n    this.server._connections--;\n    if (this.server._emitCloseIfDrained) {\n      this.server._emitCloseIfDrained();\n    }\n  }\n};\n\n\nSocket.prototype.destroy = function(exception) {\n  debug('destroy', exception);\n  this._destroy(exception);\n};\n\n\n// This function is called whenever the handle gets a\n// buffer, or when there's an error reading.\nfunction onread(nread, buffer) {\n  var handle = this;\n  var self = handle.owner;\n  assert(handle === self._handle, 'handle != self._handle');\n\n  timers._unrefActive(self);\n\n  debug('onread', nread);\n\n  if (nread > 0) {\n    debug('got data');\n\n    // read success.\n    // In theory (and in practice) calling readStop right now\n    // will prevent this from being called again until _read() gets\n    // called again.\n\n    // if it's not enough data, we'll just call handle.readStart()\n    // again right away.\n    self.bytesRead += nread;\n\n    // Optimization: emit the original buffer with end points\n    var ret = self.push(buffer);\n\n    if (handle.reading && !ret) {\n      handle.reading = false;\n      debug('readStop');\n      var err = handle.readStop();\n      if (err)\n        self._destroy(errnoException(err, 'read'));\n    }\n    return;\n  }\n\n  // if we didn't get any bytes, that doesn't necessarily mean EOF.\n  // wait for the next one.\n  if (nread === 0) {\n    debug('not any data, keep waiting');\n    return;\n  }\n\n  // Error, possibly EOF.\n  if (nread !== uv.UV_EOF) {\n    return self._destroy(errnoException(nread, 'read'));\n  }\n\n  debug('EOF');\n\n  if (self._readableState.length === 0) {\n    self.readable = false;\n    maybeDestroy(self);\n  }\n\n  // push a null to signal the end of data.\n  self.push(null);\n\n  // internal end event so that we know that the actual socket\n  // is no longer readable, and we can start the shutdown\n  // procedure. No need to wait for all the data to be consumed.\n  self.emit('_socketEnd');\n}\n\n\nSocket.prototype._getpeername = function() {\n  if (!this._handle || !this._handle.getpeername) {\n    return {};\n  }\n  if (!this._peername) {\n    var out = {};\n    var err = this._handle.getpeername(out);\n    if (err) return {};  // FIXME(bnoordhuis) Throw?\n    this._peername = out;\n  }\n  return this._peername;\n};\n\n\nSocket.prototype.__defineGetter__('remoteAddress', function() {\n  return this._getpeername().address;\n});\n\n\nSocket.prototype.__defineGetter__('remotePort', function() {\n  return this._getpeername().port;\n});\n\n\nSocket.prototype._getsockname = function() {\n  if (!this._handle || !this._handle.getsockname) {\n    return {};\n  }\n  if (!this._sockname) {\n    var out = {};\n    var err = this._handle.getsockname(out);\n    if (err) return {};  // FIXME(bnoordhuis) Throw?\n    this._sockname = out;\n  }\n  return this._sockname;\n};\n\n\nSocket.prototype.__defineGetter__('localAddress', function() {\n  return this._getsockname().address;\n});\n\n\nSocket.prototype.__defineGetter__('localPort', function() {\n  return this._getsockname().port;\n});\n\n\nSocket.prototype.write = function(chunk, encoding, cb) {\n  if (!util.isString(chunk) && !util.isBuffer(chunk))\n    throw new TypeError('invalid data');\n  return stream.Duplex.prototype.write.apply(this, arguments);\n};\n\n\nSocket.prototype._writeGeneric = function(writev, data, encoding, cb) {\n  // If we are still connecting, then buffer this for later.\n  // The Writable logic will buffer up any more writes while\n  // waiting for this one to be done.\n  if (this._connecting) {\n    this._pendingData = data;\n    this._pendingEncoding = encoding;\n    this.once('connect', function() {\n      this._writeGeneric(writev, data, encoding, cb);\n    });\n    return;\n  }\n  this._pendingData = null;\n  this._pendingEncoding = '';\n\n  timers._unrefActive(this);\n\n  if (!this._handle) {\n    this._destroy(new Error('This socket is closed.'), cb);\n    return false;\n  }\n\n  var req = { oncomplete: afterWrite, async: false };\n  var err;\n\n  if (writev) {\n    var chunks = new Array(data.length << 1);\n    for (var i = 0; i < data.length; i++) {\n      var entry = data[i];\n      var chunk = entry.chunk;\n      var enc = entry.encoding;\n      chunks[i * 2] = chunk;\n      chunks[i * 2 + 1] = enc;\n    }\n    err = this._handle.writev(req, chunks);\n\n    // Retain chunks\n    if (err === 0) req._chunks = chunks;\n  } else {\n    var enc;\n    if (util.isBuffer(data)) {\n      req.buffer = data;  // Keep reference alive.\n      enc = 'buffer';\n    } else {\n      enc = encoding;\n    }\n    err = createWriteReq(req, this._handle, data, enc);\n  }\n\n  if (err)\n    return this._destroy(errnoException(err, 'write', req.error), cb);\n\n  this._bytesDispatched += req.bytes;\n\n  // If it was entirely flushed, we can write some more right now.\n  // However, if more is left in the queue, then wait until that clears.\n  if (req.async && this._handle.writeQueueSize != 0)\n    req.cb = cb;\n  else\n    cb();\n};\n\n\nSocket.prototype._writev = function(chunks, cb) {\n  this._writeGeneric(true, chunks, '', cb);\n};\n\n\nSocket.prototype._write = function(data, encoding, cb) {\n  this._writeGeneric(false, data, encoding, cb);\n};\n\nfunction createWriteReq(req, handle, data, encoding) {\n  switch (encoding) {\n    case 'buffer':\n      return handle.writeBuffer(req, data);\n\n    case 'utf8':\n    case 'utf-8':\n      return handle.writeUtf8String(req, data);\n\n    case 'ascii':\n      return handle.writeAsciiString(req, data);\n\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return handle.writeUcs2String(req, data);\n\n    default:\n      return handle.writeBuffer(req, new Buffer(data, encoding));\n  }\n}\n\n\nSocket.prototype.__defineGetter__('bytesWritten', function() {\n  var bytes = this._bytesDispatched,\n      state = this._writableState,\n      data = this._pendingData,\n      encoding = this._pendingEncoding;\n\n  state.buffer.forEach(function(el) {\n    if (util.isBuffer(el.chunk))\n      bytes += el.chunk.length;\n    else\n      bytes += Buffer.byteLength(el.chunk, el.encoding);\n  });\n\n  if (data) {\n    if (util.isBuffer(data))\n      bytes += data.length;\n    else\n      bytes += Buffer.byteLength(data, encoding);\n  }\n\n  return bytes;\n});\n\n\nfunction afterWrite(status, handle, req, err) {\n  var self = handle.owner;\n  if (self !== process.stderr && self !== process.stdout)\n    debug('afterWrite', status);\n\n  // callback may come after call to destroy.\n  if (self.destroyed) {\n    debug('afterWrite destroyed');\n    return;\n  }\n\n  if (status < 0) {\n    var ex = errnoException(status, 'write', err);\n    debug('write failure', ex);\n    self._destroy(ex, req.cb);\n    return;\n  }\n\n  timers._unrefActive(self);\n\n  if (self !== process.stderr && self !== process.stdout)\n    debug('afterWrite call cb');\n\n  if (req.cb)\n    req.cb.call(self);\n}\n\n\nfunction connect(self, address, port, addressType, localAddress, localPort) {\n  // TODO return promise from Socket.prototype.connect which\n  // wraps _connectReq.\n\n  assert.ok(self._connecting);\n\n  var err;\n  if (localAddress || localPort) {\n    if (localAddress && !exports.isIP(localAddress))\n      err = new TypeError(\n          'localAddress should be a valid IP: ' + localAddress);\n\n    if (localPort && !util.isNumber(localPort))\n      err = new TypeError('localPort should be a number: ' + localPort);\n\n    var bind;\n\n    switch (addressType) {\n      case 4:\n        if (!localAddress)\n          localAddress = '0.0.0.0';\n        bind = self._handle.bind;\n        break;\n      case 6:\n        if (!localAddress)\n          localAddress = '::';\n        bind = self._handle.bind6;\n        break;\n      default:\n        err = new TypeError('Invalid addressType: ' + addressType);\n        break;\n    }\n\n    if (err) {\n      self._destroy(err);\n      return;\n    }\n\n    debug('binding to localAddress: %s and localPort: %d',\n          localAddress,\n          localPort);\n\n    bind = bind.bind(self._handle);\n    err = bind(localAddress, localPort);\n\n    if (err) {\n      self._destroy(errnoException(err, 'bind'));\n      return;\n    }\n  }\n\n  var req = { oncomplete: afterConnect };\n  if (addressType === 6 || addressType === 4) {\n    port = port | 0;\n    if (port <= 0 || port > 65535)\n      throw new RangeError('Port should be > 0 and < 65536');\n\n    if (addressType === 6) {\n      err = self._handle.connect6(req, address, port);\n    } else if (addressType === 4) {\n      err = self._handle.connect(req, address, port);\n    }\n  } else {\n    err = self._handle.connect(req, address, afterConnect);\n  }\n\n  if (err) {\n    self._destroy(errnoException(err, 'connect'));\n  }\n}\n\n\nSocket.prototype.connect = function(options, cb) {\n  if (this.write !== Socket.prototype.write)\n    this.write = Socket.prototype.write;\n\n  if (!util.isObject(options)) {\n    // Old API:\n    // connect(port, [host], [cb])\n    // connect(path, [cb]);\n    var args = normalizeConnectArgs(arguments);\n    return Socket.prototype.connect.apply(this, args);\n  }\n\n  if (this.destroyed) {\n    this._readableState.reading = false;\n    this._readableState.ended = false;\n    this._readableState.endEmitted = false;\n    this._writableState.ended = false;\n    this._writableState.ending = false;\n    this._writableState.finished = false;\n    this._writableState.errorEmitted = false;\n    this.destroyed = false;\n    this._handle = null;\n  }\n\n  var self = this;\n  var pipe = !!options.path;\n  debug('pipe', pipe, options.path);\n\n  if (!this._handle) {\n    this._handle = pipe ? createPipe() : createTCP();\n    initSocketHandle(this);\n  }\n\n  if (util.isFunction(cb)) {\n    self.once('connect', cb);\n  }\n\n  timers._unrefActive(this);\n\n  self._connecting = true;\n  self.writable = true;\n\n  if (pipe) {\n    connect(self, options.path);\n\n  } else if (!options.host) {\n    debug('connect: missing host');\n    self._host = '127.0.0.1';\n    connect(self, self._host, options.port, 4);\n\n  } else {\n    var host = options.host;\n    var family = options.family || 4;\n    debug('connect: find host ' + host);\n    self._host = host;\n    require('dns').lookup(host, family, function(err, ip, addressType) {\n      self.emit('lookup', err, ip, addressType);\n\n      // It's possible we were destroyed while looking this up.\n      // XXX it would be great if we could cancel the promise returned by\n      // the look up.\n      if (!self._connecting) return;\n\n      if (err) {\n        // net.createConnection() creates a net.Socket object and\n        // immediately calls net.Socket.connect() on it (that's us).\n        // There are no event listeners registered yet so defer the\n        // error event to the next tick.\n        process.nextTick(function() {\n          self.emit('error', err);\n          self._destroy();\n        });\n      } else {\n        timers._unrefActive(self);\n\n        addressType = addressType || 4;\n\n        // node_net.cc handles null host names graciously but user land\n        // expects remoteAddress to have a meaningful value\n        ip = ip || (addressType === 4 ? '127.0.0.1' : '0:0:0:0:0:0:0:1');\n\n        connect(self,\n                ip,\n                options.port,\n                addressType,\n                options.localAddress,\n                options.localPort);\n      }\n    });\n  }\n  return self;\n};\n\n\nSocket.prototype.ref = function() {\n  if (this._handle)\n    this._handle.ref();\n};\n\n\nSocket.prototype.unref = function() {\n  if (this._handle)\n    this._handle.unref();\n};\n\n\n\nfunction afterConnect(status, handle, req, readable, writable) {\n  var self = handle.owner;\n\n  // callback may come after call to destroy\n  if (self.destroyed) {\n    return;\n  }\n\n  assert(handle === self._handle, 'handle != self._handle');\n\n  debug('afterConnect');\n\n  assert.ok(self._connecting);\n  self._connecting = false;\n\n  if (status == 0) {\n    self.readable = readable;\n    self.writable = writable;\n    timers._unrefActive(self);\n\n    self.emit('connect');\n\n    // start the first read, or get an immediate EOF.\n    // this doesn't actually consume any bytes, because len=0.\n    if (readable)\n      self.read(0);\n\n  } else {\n    self._connecting = false;\n    self._destroy(errnoException(status, 'connect'));\n  }\n}\n\n\nfunction Server() {\n  if (!(this instanceof Server)) return new Server(arguments[0], arguments[1]);\n  events.EventEmitter.call(this);\n\n  var self = this;\n\n  var options;\n\n  if (util.isFunction(arguments[0])) {\n    options = {};\n    self.on('connection', arguments[0]);\n  } else {\n    options = arguments[0] || {};\n\n    if (util.isFunction(arguments[1])) {\n      self.on('connection', arguments[1]);\n    }\n  }\n\n  this._connections = 0;\n\n  Object.defineProperty(this, 'connections', {\n    get: util.deprecate(function() {\n\n      if (self._usingSlaves) {\n        return null;\n      }\n      return self._connections;\n    }, 'connections property is deprecated. Use getConnections() method'),\n    set: util.deprecate(function(val) {\n      return (self._connections = val);\n    }, 'connections property is deprecated. Use getConnections() method'),\n    configurable: true, enumerable: true\n  });\n\n  this._handle = null;\n  this._usingSlaves = false;\n  this._slaves = [];\n\n  this.allowHalfOpen = options.allowHalfOpen || false;\n}\nutil.inherits(Server, events.EventEmitter);\nexports.Server = Server;\n\n\nfunction toNumber(x) { return (x = Number(x)) >= 0 ? x : false; }\n\nfunction _listen(handle, backlog) {\n  // Use a backlog of 512 entries. We pass 511 to the listen() call because\n  // the kernel does: backlogsize = roundup_pow_of_two(backlogsize + 1);\n  // which will thus give us a backlog of 512 entries.\n  return handle.listen(backlog || 511);\n}\n\nvar createServerHandle = exports._createServerHandle =\n    function(address, port, addressType, fd) {\n  var err = 0;\n  // assign handle in listen, and clean up if bind or listen fails\n  var handle;\n\n  var isTCP = false;\n  if (util.isNumber(fd) && fd >= 0) {\n    try {\n      handle = createHandle(fd);\n    }\n    catch (e) {\n      // Not a fd we can listen on.  This will trigger an error.\n      debug('listen invalid fd=' + fd + ': ' + e.message);\n      return uv.UV_EINVAL;\n    }\n    handle.open(fd);\n    handle.readable = true;\n    handle.writable = true;\n    assert(!address && !port);\n  } else if (port === -1 && addressType === -1) {\n    handle = createPipe();\n    if (process.platform === 'win32') {\n      var instances = parseInt(process.env.NODE_PENDING_PIPE_INSTANCES);\n      if (!isNaN(instances)) {\n        handle.setPendingInstances(instances);\n      }\n    }\n  } else {\n    handle = createTCP();\n    isTCP = true;\n  }\n\n  if (address || port || isTCP) {\n    debug('bind to ' + (address || 'anycast'));\n    if (!address) {\n      // Try binding to ipv6 first\n      err = handle.bind6('::', port);\n      if (err) {\n        handle.close();\n        // Fallback to ipv4\n        return createServerHandle('0.0.0.0', port);\n      }\n    } else if (addressType === 6) {\n      err = handle.bind6(address, port);\n    } else {\n      err = handle.bind(address, port);\n    }\n  }\n\n  if (err) {\n    handle.close();\n    return err;\n  }\n\n  if (process.platform === 'win32') {\n    // On Windows, we always listen to the socket before sending it to\n    // the worker (see uv_tcp_duplicate_socket). So we better do it here\n    // so that we can handle any bind-time or listen-time errors early.\n    err = _listen(handle);\n    if (err) {\n      handle.close();\n      return err;\n    }\n  }\n\n  return handle;\n};\n\n\nServer.prototype._listen2 = function(address, port, addressType, backlog, fd) {\n  debug('listen2', address, port, addressType, backlog);\n  var self = this;\n\n  var alreadyListening = false;\n\n  // If there is not yet a handle, we need to create one and bind.\n  // In the case of a server sent via IPC, we don't need to do this.\n  if (!self._handle) {\n    debug('_listen2: create a handle');\n    var rval = createServerHandle(address, port, addressType, fd);\n    if (util.isNumber(rval)) {\n      var error = errnoException(rval, 'listen');\n      process.nextTick(function() {\n        self.emit('error', error);\n      });\n      return;\n    }\n    alreadyListening = (process.platform === 'win32');\n    self._handle = rval;\n  } else {\n    debug('_listen2: have a handle already');\n  }\n\n  self._handle.onconnection = onconnection;\n  self._handle.owner = self;\n\n  var err = 0;\n  if (!alreadyListening)\n    err = _listen(self._handle, backlog);\n\n  if (err) {\n    var ex = errnoException(err, 'listen');\n    self._handle.close();\n    self._handle = null;\n    process.nextTick(function() {\n      self.emit('error', ex);\n    });\n    return;\n  }\n\n  // generate connection key, this should be unique to the connection\n  this._connectionKey = addressType + ':' + address + ':' + port;\n\n  process.nextTick(function() {\n    // ensure handle hasn't closed\n    if (self._handle)\n      self.emit('listening');\n  });\n};\n\n\nfunction listen(self, address, port, addressType, backlog, fd) {\n  if (!cluster) cluster = require('cluster');\n\n  if (cluster.isMaster) {\n    self._listen2(address, port, addressType, backlog, fd);\n    return;\n  }\n\n  cluster._getServer(self, address, port, addressType, fd, cb);\n\n  function cb(err, handle) {\n    // EADDRINUSE may not be reported until we call listen(). To complicate\n    // matters, a failed bind() followed by listen() will implicitly bind to\n    // a random port. Ergo, check that the socket is bound to the expected\n    // port before calling listen().\n    //\n    // FIXME(bnoordhuis) Doesn't work for pipe handles, they don't have a\n    // getsockname() method. Non-issue for now, the cluster module doesn't\n    // really support pipes anyway.\n    if (err === 0 && port > 0 && handle.getsockname) {\n      var out = {};\n      err = handle.getsockname(out);\n      if (err === 0 && port !== out.port)\n        err = uv.UV_EADDRINUSE;\n    }\n\n    if (err)\n      return self.emit('error', errnoException(err, 'bind'));\n\n    self._handle = handle;\n    self._listen2(address, port, addressType, backlog, fd);\n  }\n}\n\n\nServer.prototype.listen = function() {\n  var self = this;\n\n  var lastArg = arguments[arguments.length - 1];\n  if (util.isFunction(lastArg)) {\n    self.once('listening', lastArg);\n  }\n\n  var port = toNumber(arguments[0]);\n\n  // The third optional argument is the backlog size.\n  // When the ip is omitted it can be the second argument.\n  var backlog = toNumber(arguments[1]) || toNumber(arguments[2]);\n\n  var TCP = process.binding('tcp_wrap').TCP;\n\n  if (arguments.length == 0 || util.isFunction(arguments[0])) {\n    // Bind to a random port.\n    listen(self, null, 0, null, backlog);\n\n  } else if (arguments[0] && util.isObject(arguments[0])) {\n    var h = arguments[0];\n    if (h._handle) {\n      h = h._handle;\n    } else if (h.handle) {\n      h = h.handle;\n    }\n    if (h instanceof TCP) {\n      self._handle = h;\n      listen(self, null, -1, -1, backlog);\n    } else if (util.isNumber(h.fd) && h.fd >= 0) {\n      listen(self, null, null, null, backlog, h.fd);\n    } else {\n      throw new Error('Invalid listen argument: ' + h);\n    }\n  } else if (isPipeName(arguments[0])) {\n    // UNIX socket or Windows pipe.\n    var pipeName = self._pipeName = arguments[0];\n    listen(self, pipeName, -1, -1, backlog);\n\n  } else if (util.isUndefined(arguments[1]) ||\n             util.isFunction(arguments[1]) ||\n             util.isNumber(arguments[1])) {\n    // The first argument is the port, no IP given.\n    listen(self, null, port, 4, backlog);\n\n  } else {\n    // The first argument is the port, the second an IP.\n    require('dns').lookup(arguments[1], function(err, ip, addressType) {\n      if (err) {\n        self.emit('error', err);\n      } else {\n        listen(self, ip, port, ip ? addressType : 4, backlog);\n      }\n    });\n  }\n  return self;\n};\n\nServer.prototype.address = function() {\n  if (this._handle && this._handle.getsockname) {\n    var out = {};\n    var err = this._handle.getsockname(out);\n    // TODO(bnoordhuis) Check err and throw?\n    return out;\n  } else if (this._pipeName) {\n    return this._pipeName;\n  } else {\n    return null;\n  }\n};\n\nfunction onconnection(err, clientHandle) {\n  var handle = this;\n  var self = handle.owner;\n\n  debug('onconnection');\n\n  if (err) {\n    self.emit('error', errnoException(err, 'accept'));\n    return;\n  }\n\n  if (self.maxConnections && self._connections >= self.maxConnections) {\n    clientHandle.close();\n    return;\n  }\n\n  var socket = new Socket({\n    handle: clientHandle,\n    allowHalfOpen: self.allowHalfOpen\n  });\n  socket.readable = socket.writable = true;\n\n\n  self._connections++;\n  socket.server = self;\n\n  DTRACE_NET_SERVER_CONNECTION(socket);\n  COUNTER_NET_SERVER_CONNECTION(socket);\n  self.emit('connection', socket);\n}\n\n\nServer.prototype.getConnections = function(cb) {\n  function end(err, connections) {\n    process.nextTick(function() {\n      cb(err, connections);\n    });\n  }\n\n  if (!this._usingSlaves) {\n    return end(null, this._connections);\n  }\n\n  // Poll slaves\n  var left = this._slaves.length,\n      total = this._connections;\n\n  function oncount(err, count) {\n    if (err) {\n      left = -1;\n      return end(err);\n    }\n\n    total += count;\n    if (--left === 0) return end(null, total);\n  }\n\n  this._slaves.forEach(function(slave) {\n    slave.getConnections(oncount);\n  });\n};\n\n\nServer.prototype.close = function(cb) {\n  function onSlaveClose() {\n    if (--left !== 0) return;\n\n    self._connections = 0;\n    self._emitCloseIfDrained();\n  }\n\n  if (cb) {\n    if (!this._handle) {\n      this.once('close', function() {\n        cb(new Error('Not running'));\n      });\n    } else {\n      this.once('close', cb);\n    }\n  }\n\n  if (this._handle) {\n    this._handle.close();\n    this._handle = null;\n  }\n\n  if (this._usingSlaves) {\n    var self = this,\n        left = this._slaves.length;\n\n    // Increment connections to be sure that, even if all sockets will be closed\n    // during polling of slaves, `close` event will be emitted only once.\n    this._connections++;\n\n    // Poll slaves\n    this._slaves.forEach(function(slave) {\n      slave.close(onSlaveClose);\n    });\n  } else {\n    this._emitCloseIfDrained();\n  }\n\n  return this;\n};\n\nServer.prototype._emitCloseIfDrained = function() {\n  debug('SERVER _emitCloseIfDrained');\n  var self = this;\n\n  if (self._handle || self._connections) {\n    debug('SERVER handle? %j   connections? %d',\n          !!self._handle, self._connections);\n    return;\n  }\n\n  process.nextTick(function() {\n    debug('SERVER: emit close');\n    self.emit('close');\n  });\n};\n\n\nServer.prototype.listenFD = util.deprecate(function(fd, type) {\n  return this.listen({ fd: fd });\n}, 'listenFD is deprecated. Use listen({fd: <number>}).');\n\nServer.prototype._setupSlave = function(socketList) {\n  this._usingSlaves = true;\n  this._slaves.push(socketList);\n};\n\nServer.prototype.ref = function() {\n  if (this._handle)\n    this._handle.ref();\n};\n\nServer.prototype.unref = function() {\n  if (this._handle)\n    this._handle.unref();\n};\n\n\n// TODO: isIP should be moved to the DNS code. Putting it here now because\n// this is what the legacy system did.\nexports.isIP = cares.isIP;\n\n\nexports.isIPv4 = function(input) {\n  return exports.isIP(input) === 4;\n};\n\n\nexports.isIPv6 = function(input) {\n  return exports.isIP(input) === 6;\n};\n\n\nif (process.platform === 'win32') {\n  var simultaneousAccepts;\n\n  exports._setSimultaneousAccepts = function(handle) {\n    if (util.isUndefined(handle)) {\n      return;\n    }\n\n    if (util.isUndefined(simultaneousAccepts)) {\n      simultaneousAccepts = (process.env.NODE_MANY_ACCEPTS &&\n                             process.env.NODE_MANY_ACCEPTS !== '0');\n    }\n\n    if (handle._simultaneousAccepts !== simultaneousAccepts) {\n      handle.setSimultaneousAccepts(simultaneousAccepts);\n      handle._simultaneousAccepts = simultaneousAccepts;\n    }\n  };\n} else {\n  exports._setSimultaneousAccepts = function(handle) {};\n}\n",
  @"// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar binding = process.binding('os');\nvar util = require('util');\nvar isWindows = process.platform === 'win32';\n\nexports.endianness = binding.getEndianness;\nexports.hostname = binding.getHostname;\nexports.loadavg = binding.getLoadAvg;\nexports.uptime = binding.getUptime;\nexports.freemem = binding.getFreeMem;\nexports.totalmem = binding.getTotalMem;\nexports.cpus = binding.getCPUs;\nexports.type = binding.getOSType;\nexports.release = binding.getOSRelease;\nexports.networkInterfaces = binding.getInterfaceAddresses;\n\nexports.arch = function() {\n  return process.arch;\n};\n\nexports.platform = function() {\n  return process.platform;\n};\n\nexports.tmpdir = function() {\n  if (isWindows) {\n    return process.env.TEMP ||\n           process.env.TMP ||\n           (process.env.SystemRoot || process.env.windir) + '\\\\temp';\n  } else {\n    return process.env.TMPDIR ||\n           process.env.TMP ||\n           process.env.TEMP ||\n           '/tmp';\n  }\n};\n\nexports.tmpDir = exports.tmpdir;\n\nexports.getNetworkInterfaces = util.deprecate(function() {\n  return exports.networkInterfaces();\n}, 'getNetworkInterfaces is now called `os.networkInterfaces`.');\n\nexports.EOL = isWindows ? '\\r\\n' : '\\n';\n",
  @"// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\nvar isWindows = process.platform === 'win32';\nvar util = require('util');\n\n\n// resolves . and .. elements in a path array with directory names there\n// must be no slashes, empty elements, or device names (c:\\) in the array\n// (so also no leading and trailing slashes - it does not distinguish\n// relative and absolute paths)\nfunction normalizeArray(parts, allowAboveRoot) {\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = parts.length - 1; i >= 0; i--) {\n    var last = parts[i];\n    if (last === '.') {\n      parts.splice(i, 1);\n    } else if (last === '..') {\n      parts.splice(i, 1);\n      up++;\n    } else if (up) {\n      parts.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (allowAboveRoot) {\n    for (; up--; up) {\n      parts.unshift('..');\n    }\n  }\n\n  return parts;\n}\n\n\nif (isWindows) {\n  // Regex to split a windows path into three parts: [*, device, slash,\n  // tail] windows-only\n  var splitDeviceRe =\n      /^([a-zA-Z]:|[\\\\\\/]{2}[^\\\\\\/]+[\\\\\\/]+[^\\\\\\/]+)?([\\\\\\/])?([\\s\\S]*?)$/;\n\n  // Regex to split the tail part of the above into [*, dir, basename, ext]\n  var splitTailRe =\n      /^([\\s\\S]*?)((?:\\.{1,2}|[^\\\\\\/]+?|)(\\.[^.\\/\\\\]*|))(?:[\\\\\\/]*)$/;\n\n  // Function to split a filename into [root, dir, basename, ext]\n  // windows version\n  var splitPath = function(filename) {\n    // Separate device+slash from tail\n    var result = splitDeviceRe.exec(filename),\n        device = (result[1] || '') + (result[2] || ''),\n        tail = result[3] || '';\n    // Split the tail into dir, basename and extension\n    var result2 = splitTailRe.exec(tail),\n        dir = result2[1],\n        basename = result2[2],\n        ext = result2[3];\n    return [device, dir, basename, ext];\n  };\n\n  var normalizeUNCRoot = function(device) {\n    return '\\\\\\\\' + device.replace(/^[\\\\\\/]+/, '').replace(/[\\\\\\/]+/g, '\\\\');\n  };\n\n  // path.resolve([from ...], to)\n  // windows version\n  exports.resolve = function() {\n    var resolvedDevice = '',\n        resolvedTail = '',\n        resolvedAbsolute = false;\n\n    for (var i = arguments.length - 1; i >= -1; i--) {\n      var path;\n      if (i >= 0) {\n        path = arguments[i];\n      } else if (!resolvedDevice) {\n        path = process.cwd();\n      } else {\n        // Windows has the concept of drive-specific current working\n        // directories. If we've resolved a drive letter but not yet an\n        // absolute path, get cwd for that drive. We're sure the device is not\n        // an unc path at this points, because unc paths are always absolute.\n        path = process.env['=' + resolvedDevice];\n        // Verify that a drive-local cwd was found and that it actually points\n        // to our drive. If not, default to the drive's root.\n        if (!path || path.substr(0, 3).toLowerCase() !==\n            resolvedDevice.toLowerCase() + '\\\\') {\n          path = resolvedDevice + '\\\\';\n        }\n      }\n\n      // Skip empty and invalid entries\n      if (!util.isString(path)) {\n        throw new TypeError('Arguments to path.resolve must be strings');\n      } else if (!path) {\n        continue;\n      }\n\n      var result = splitDeviceRe.exec(path),\n          device = result[1] || '',\n          isUnc = device && device.charAt(1) !== ':',\n          isAbsolute = exports.isAbsolute(path),\n          tail = result[3];\n\n      if (device &&\n          resolvedDevice &&\n          device.toLowerCase() !== resolvedDevice.toLowerCase()) {\n        // This path points to another device so it is not applicable\n        continue;\n      }\n\n      if (!resolvedDevice) {\n        resolvedDevice = device;\n      }\n      if (!resolvedAbsolute) {\n        resolvedTail = tail + '\\\\' + resolvedTail;\n        resolvedAbsolute = isAbsolute;\n      }\n\n      if (resolvedDevice && resolvedAbsolute) {\n        break;\n      }\n    }\n\n    // Convert slashes to backslashes when `resolvedDevice` points to an UNC\n    // root. Also squash multiple slashes into a single one where appropriate.\n    if (isUnc) {\n      resolvedDevice = normalizeUNCRoot(resolvedDevice);\n    }\n\n    // At this point the path should be resolved to a full absolute path,\n    // but handle relative paths to be safe (might happen when process.cwd()\n    // fails)\n\n    // Normalize the tail path\n\n    function f(p) {\n      return !!p;\n    }\n\n    resolvedTail = normalizeArray(resolvedTail.split(/[\\\\\\/]+/).filter(f),\n                                  !resolvedAbsolute).join('\\\\');\n\n    return (resolvedDevice + (resolvedAbsolute ? '\\\\' : '') + resolvedTail) ||\n           '.';\n  };\n\n  // windows version\n  exports.normalize = function(path) {\n    var result = splitDeviceRe.exec(path),\n        device = result[1] || '',\n        isUnc = device && device.charAt(1) !== ':',\n        isAbsolute = exports.isAbsolute(path),\n        tail = result[3],\n        trailingSlash = /[\\\\\\/]$/.test(tail);\n\n    // If device is a drive letter, we'll normalize to lower case.\n    if (device && device.charAt(1) === ':') {\n      device = device[0].toLowerCase() + device.substr(1);\n    }\n\n    // Normalize the tail path\n    tail = normalizeArray(tail.split(/[\\\\\\/]+/).filter(function(p) {\n      return !!p;\n    }), !isAbsolute).join('\\\\');\n\n    if (!tail && !isAbsolute) {\n      tail = '.';\n    }\n    if (tail && trailingSlash) {\n      tail += '\\\\';\n    }\n\n    // Convert slashes to backslashes when `device` points to an UNC root.\n    // Also squash multiple slashes into a single one where appropriate.\n    if (isUnc) {\n      device = normalizeUNCRoot(device);\n    }\n\n    return device + (isAbsolute ? '\\\\' : '') + tail;\n  };\n\n  // windows version\n  exports.isAbsolute = function(path) {\n    var result = splitDeviceRe.exec(path),\n        device = result[1] || '',\n        isUnc = device && device.charAt(1) !== ':';\n    // UNC paths are always absolute\n    return !!result[2] || isUnc;\n  };\n\n  // windows version\n  exports.join = function() {\n    function f(p) {\n      if (!util.isString(p)) {\n        throw new TypeError('Arguments to path.join must be strings');\n      }\n      return p;\n    }\n\n    var paths = Array.prototype.filter.call(arguments, f);\n    var joined = paths.join('\\\\');\n\n    // Make sure that the joined path doesn't start with two slashes, because\n    // normalize() will mistake it for an UNC path then.\n    //\n    // This step is skipped when it is very clear that the user actually\n    // intended to point at an UNC path. This is assumed when the first\n    // non-empty string arguments starts with exactly two slashes followed by\n    // at least one more non-slash character.\n    //\n    // Note that for normalize() to treat a path as an UNC path it needs to\n    // have at least 2 components, so we don't filter for that here.\n    // This means that the user can use join to construct UNC paths from\n    // a server name and a share name; for example:\n    //   path.join('//server', 'share') -> '\\\\\\\\server\\\\share\\')\n    if (!/^[\\\\\\/]{2}[^\\\\\\/]/.test(paths[0])) {\n      joined = joined.replace(/^[\\\\\\/]{2,}/, '\\\\');\n    }\n\n    return exports.normalize(joined);\n  };\n\n  // path.relative(from, to)\n  // it will solve the relative path from 'from' to 'to', for instance:\n  // from = 'C:\\\\orandea\\\\test\\\\aaa'\n  // to = 'C:\\\\orandea\\\\impl\\\\bbb'\n  // The output of the function should be: '..\\\\..\\\\impl\\\\bbb'\n  // windows version\n  exports.relative = function(from, to) {\n    from = exports.resolve(from);\n    to = exports.resolve(to);\n\n    // windows is not case sensitive\n    var lowerFrom = from.toLowerCase();\n    var lowerTo = to.toLowerCase();\n\n    function trim(arr) {\n      var start = 0;\n      for (; start < arr.length; start++) {\n        if (arr[start] !== '') break;\n      }\n\n      var end = arr.length - 1;\n      for (; end >= 0; end--) {\n        if (arr[end] !== '') break;\n      }\n\n      if (start > end) return [];\n      return arr.slice(start, end - start + 1);\n    }\n\n    var toParts = trim(to.split('\\\\'));\n\n    var lowerFromParts = trim(lowerFrom.split('\\\\'));\n    var lowerToParts = trim(lowerTo.split('\\\\'));\n\n    var length = Math.min(lowerFromParts.length, lowerToParts.length);\n    var samePartsLength = length;\n    for (var i = 0; i < length; i++) {\n      if (lowerFromParts[i] !== lowerToParts[i]) {\n        samePartsLength = i;\n        break;\n      }\n    }\n\n    if (samePartsLength == 0) {\n      return to;\n    }\n\n    var outputParts = [];\n    for (var i = samePartsLength; i < lowerFromParts.length; i++) {\n      outputParts.push('..');\n    }\n\n    outputParts = outputParts.concat(toParts.slice(samePartsLength));\n\n    return outputParts.join('\\\\');\n  };\n\n  exports.sep = '\\\\';\n  exports.delimiter = ';';\n\n} else  {\n\n  // Split a filename into [root, dir, basename, ext], unix version\n  // 'root' is just a slash, or nothing.\n  var splitPathRe =\n      /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\n  var splitPath = function(filename) {\n    return splitPathRe.exec(filename).slice(1);\n  };\n\n  // path.resolve([from ...], to)\n  // posix version\n  exports.resolve = function() {\n    var resolvedPath = '',\n        resolvedAbsolute = false;\n\n    for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n      var path = (i >= 0) ? arguments[i] : process.cwd();\n\n      // Skip empty and invalid entries\n      if (!util.isString(path)) {\n        throw new TypeError('Arguments to path.resolve must be strings');\n      } else if (!path) {\n        continue;\n      }\n\n      resolvedPath = path + '/' + resolvedPath;\n      resolvedAbsolute = path.charAt(0) === '/';\n    }\n\n    // At this point the path should be resolved to a full absolute path, but\n    // handle relative paths to be safe (might happen when process.cwd() fails)\n\n    // Normalize the path\n    resolvedPath = normalizeArray(resolvedPath.split('/').filter(function(p) {\n      return !!p;\n    }), !resolvedAbsolute).join('/');\n\n    return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\n  };\n\n  // path.normalize(path)\n  // posix version\n  exports.normalize = function(path) {\n    var isAbsolute = exports.isAbsolute(path),\n        trailingSlash = path[path.length - 1] === '/',\n        segments = path.split('/'),\n        nonEmptySegments = [];\n\n    // Normalize the path\n    for (var i = 0; i < segments.length; i++) {\n      if (segments[i]) {\n        nonEmptySegments.push(segments[i]);\n      }\n    }\n    path = normalizeArray(nonEmptySegments, !isAbsolute).join('/');\n\n    if (!path && !isAbsolute) {\n      path = '.';\n    }\n    if (path && trailingSlash) {\n      path += '/';\n    }\n\n    return (isAbsolute ? '/' : '') + path;\n  };\n\n  // posix version\n  exports.isAbsolute = function(path) {\n    return path.charAt(0) === '/';\n  };\n\n  // posix version\n  exports.join = function() {\n    var path = '';\n    for (var i = 0; i < arguments.length; i++) {\n      var segment = arguments[i];\n      if (!util.isString(segment)) {\n        throw new TypeError('Arguments to path.join must be strings');\n      }\n      if (segment) {\n        if (!path) {\n          path += segment;\n        } else {\n          path += '/' + segment;\n        }\n      }\n    }\n    return exports.normalize(path);\n  };\n\n\n  // path.relative(from, to)\n  // posix version\n  exports.relative = function(from, to) {\n    from = exports.resolve(from).substr(1);\n    to = exports.resolve(to).substr(1);\n\n    function trim(arr) {\n      var start = 0;\n      for (; start < arr.length; start++) {\n        if (arr[start] !== '') break;\n      }\n\n      var end = arr.length - 1;\n      for (; end >= 0; end--) {\n        if (arr[end] !== '') break;\n      }\n\n      if (start > end) return [];\n      return arr.slice(start, end - start + 1);\n    }\n\n    var fromParts = trim(from.split('/'));\n    var toParts = trim(to.split('/'));\n\n    var length = Math.min(fromParts.length, toParts.length);\n    var samePartsLength = length;\n    for (var i = 0; i < length; i++) {\n      if (fromParts[i] !== toParts[i]) {\n        samePartsLength = i;\n        break;\n      }\n    }\n\n    var outputParts = [];\n    for (var i = samePartsLength; i < fromParts.length; i++) {\n      outputParts.push('..');\n    }\n\n    outputParts = outputParts.concat(toParts.slice(samePartsLength));\n\n    return outputParts.join('/');\n  };\n\n  exports.sep = '/';\n  exports.delimiter = ':';\n}\n\nexports.dirname = function(path) {\n  var result = splitPath(path),\n      root = result[0],\n      dir = result[1];\n\n  if (!root && !dir) {\n    // No dirname whatsoever\n    return '.';\n  }\n\n  if (dir) {\n    // It has a dirname, strip trailing slash\n    dir = dir.substr(0, dir.length - 1);\n  }\n\n  return root + dir;\n};\n\n\nexports.basename = function(path, ext) {\n  var f = splitPath(path)[2];\n  // TODO: make this comparison case-insensitive on windows?\n  if (ext && f.substr(-1 * ext.length) === ext) {\n    f = f.substr(0, f.length - ext.length);\n  }\n  return f;\n};\n\n\nexports.extname = function(path) {\n  return splitPath(path)[3];\n};\n\n\nexports.exists = util.deprecate(function(path, callback) {\n  require('fs').exists(path, callback);\n}, 'path.exists is now called `fs.exists`.');\n\n\nexports.existsSync = util.deprecate(function(path) {\n  return require('fs').existsSync(path);\n}, 'path.existsSync is now called `fs.existsSync`.');\n\n\nif (isWindows) {\n  exports._makeLong = function(path) {\n    // Note: this will *probably* throw somewhere.\n    if (!util.isString(path))\n      return path;\n\n    if (!path) {\n      return '';\n    }\n\n    var resolvedPath = exports.resolve(path);\n\n    if (/^[a-zA-Z]\\:\\\\/.test(resolvedPath)) {\n      // path is local filesystem path, which needs to be converted\n      // to long UNC path.\n      return '\\\\\\\\?\\\\' + resolvedPath;\n    } else if (/^\\\\\\\\[^?.]/.test(resolvedPath)) {\n      // path is network UNC path, which needs to be converted\n      // to long UNC path.\n      return '\\\\\\\\?\\\\UNC\\\\' + resolvedPath.substring(2);\n    }\n\n    return path;\n  };\n} else {\n  exports._makeLong = function(path) {\n    return path;\n  };\n}\n",
  @"\n;(function(root) {\n\n\n	var freeExports = typeof exports == 'object' && exports;\n	var freeModule = typeof module == 'object' && module &&\n		module.exports == freeExports && module;\n	var freeGlobal = typeof global == 'object' && global;\n	if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {\n		root = freeGlobal;\n	}\n\n\n\n\n\n\n	var punycode,\n\n\n	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1\n\n\n	base = 36,\n	tMin = 1,\n	tMax = 26,\n	skew = 38,\n	damp = 700,\n	initialBias = 72,\n	initialN = 128, // 0x80\n	delimiter = '-', // '\\x2D'\n\n\n	regexPunycode = /^xn--/,\n	regexNonASCII = /[^ -~]/, // unprintable ASCII chars + non-ASCII chars\n	regexSeparators = /\\x2E|\\u3002|\\uFF0E|\\uFF61/g, // RFC 3490 separators\n\n\n	errors = {\n		'overflow': 'Overflow: input needs wider integers to process',\n		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',\n		'invalid-input': 'Invalid input'\n	},\n\n\n	baseMinusTMin = base - tMin,\n	floor = Math.floor,\n	stringFromCharCode = String.fromCharCode,\n\n\n	key;\n\n\n\n\n\n\n\n\n\n	function error(type) {\n		throw RangeError(errors[type]);\n	}\n\n\n\n\n\n\n\n\n\n	function map(array, fn) {\n		var length = array.length;\n		while (length--) {\n			array[length] = fn(array[length]);\n		}\n		return array;\n	}\n\n\n\n\n\n\n\n\n\n\n	function mapDomain(string, fn) {\n		return map(string.split(regexSeparators), fn).join('.');\n	}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n	function ucs2decode(string) {\n		var output = [],\n		    counter = 0,\n		    length = string.length,\n		    value,\n		    extra;\n		while (counter < length) {\n			value = string.charCodeAt(counter++);\n			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n				// high surrogate, and there is a next character\n				extra = string.charCodeAt(counter++);\n				if ((extra & 0xFC00) == 0xDC00) { // low surrogate\n					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n				} else {\n					// unmatched surrogate; only append this code unit, in case the next\n					// code unit is the high surrogate of a surrogate pair\n					output.push(value);\n					counter--;\n				}\n			} else {\n				output.push(value);\n			}\n		}\n		return output;\n	}\n\n\n\n\n\n\n\n\n\n	function ucs2encode(array) {\n		return map(array, function(value) {\n			var output = '';\n			if (value > 0xFFFF) {\n				value -= 0x10000;\n				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);\n				value = 0xDC00 | value & 0x3FF;\n			}\n			output += stringFromCharCode(value);\n			return output;\n		}).join('');\n	}\n\n\n\n\n\n\n\n\n\n\n	function basicToDigit(codePoint) {\n		if (codePoint - 48 < 10) {\n			return codePoint - 22;\n		}\n		if (codePoint - 65 < 26) {\n			return codePoint - 65;\n		}\n		if (codePoint - 97 < 26) {\n			return codePoint - 97;\n		}\n		return base;\n	}\n\n\n\n\n\n\n\n\n\n\n\n\n	function digitToBasic(digit, flag) {\n		//  0..25 map to ASCII a..z or A..Z\n		// 26..35 map to ASCII 0..9\n		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\n	}\n\n\n\n\n\n\n	function adapt(delta, numPoints, firstTime) {\n		var k = 0;\n		delta = firstTime ? floor(delta / damp) : delta >> 1;\n		delta += floor(delta / numPoints);\n		for (; delta > baseMinusTMin * tMax >> 1; k += base) {\n			delta = floor(delta / baseMinusTMin);\n		}\n		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\n	}\n\n\n\n\n\n\n\n\n	function decode(input) {\n		// Don't use UCS-2\n		var output = [],\n		    inputLength = input.length,\n		    out,\n		    i = 0,\n		    n = initialN,\n		    bias = initialBias,\n		    basic,\n		    j,\n		    index,\n		    oldi,\n		    w,\n		    k,\n		    digit,\n		    t,\n\n		    baseMinusT;\n\n		// Handle the basic code points: let `basic` be the number of input code\n		// points before the last delimiter, or `0` if there is none, then copy\n		// the first basic code points to the output.\n\n		basic = input.lastIndexOf(delimiter);\n		if (basic < 0) {\n			basic = 0;\n		}\n\n		for (j = 0; j < basic; ++j) {\n			// if it's not a basic code point\n			if (input.charCodeAt(j) >= 0x80) {\n				error('not-basic');\n			}\n			output.push(input.charCodeAt(j));\n		}\n\n		// Main decoding loop: start just after the last delimiter if any basic code\n		// points were copied; start at the beginning otherwise.\n\n		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; ) {\n\n			// `index` is the index of the next character to be consumed.\n			// Decode a generalized variable-length integer into `delta`,\n			// which gets added to `i`. The overflow checking is easier\n			// if we increase `i` as we go, then subtract off its starting\n			// value at the end to obtain `delta`.\n			for (oldi = i, w = 1, k = base; ; k += base) {\n\n				if (index >= inputLength) {\n					error('invalid-input');\n				}\n\n				digit = basicToDigit(input.charCodeAt(index++));\n\n				if (digit >= base || digit > floor((maxInt - i) / w)) {\n					error('overflow');\n				}\n\n				i += digit * w;\n				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\n				if (digit < t) {\n					break;\n				}\n\n				baseMinusT = base - t;\n				if (w > floor(maxInt / baseMinusT)) {\n					error('overflow');\n				}\n\n				w *= baseMinusT;\n\n			}\n\n			out = output.length + 1;\n			bias = adapt(i - oldi, out, oldi == 0);\n\n			// `i` was supposed to wrap around from `out` to `0`,\n			// incrementing `n` each time, so we'll fix that now:\n			if (floor(i / out) > maxInt - n) {\n				error('overflow');\n			}\n\n			n += floor(i / out);\n			i %= out;\n\n			// Insert `n` at position `i` of the output\n			output.splice(i++, 0, n);\n\n		}\n\n		return ucs2encode(output);\n	}\n\n\n\n\n\n\n\n\n	function encode(input) {\n		var n,\n		    delta,\n		    handledCPCount,\n		    basicLength,\n		    bias,\n		    j,\n		    m,\n		    q,\n		    k,\n		    t,\n		    currentValue,\n		    output = [],\n\n		    inputLength,\n\n		    handledCPCountPlusOne,\n		    baseMinusT,\n		    qMinusT;\n\n		// Convert the input in UCS-2 to Unicode\n		input = ucs2decode(input);\n\n		// Cache the length\n		inputLength = input.length;\n\n		// Initialize the state\n		n = initialN;\n		delta = 0;\n		bias = initialBias;\n\n		// Handle the basic code points\n		for (j = 0; j < inputLength; ++j) {\n			currentValue = input[j];\n			if (currentValue < 0x80) {\n				output.push(stringFromCharCode(currentValue));\n			}\n		}\n\n		handledCPCount = basicLength = output.length;\n\n		// `handledCPCount` is the number of code points that have been handled;\n		// `basicLength` is the number of basic code points.\n\n		// Finish the basic string - if it is not empty - with a delimiter\n		if (basicLength) {\n			output.push(delimiter);\n		}\n\n		// Main encoding loop:\n		while (handledCPCount < inputLength) {\n\n			// All non-basic code points < n have been handled already. Find the next\n			// larger one:\n			for (m = maxInt, j = 0; j < inputLength; ++j) {\n				currentValue = input[j];\n				if (currentValue >= n && currentValue < m) {\n					m = currentValue;\n				}\n			}\n\n			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,\n			// but guard against overflow\n			handledCPCountPlusOne = handledCPCount + 1;\n			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\n				error('overflow');\n			}\n\n			delta += (m - n) * handledCPCountPlusOne;\n			n = m;\n\n			for (j = 0; j < inputLength; ++j) {\n				currentValue = input[j];\n\n				if (currentValue < n && ++delta > maxInt) {\n					error('overflow');\n				}\n\n				if (currentValue == n) {\n					// Represent delta as a generalized variable-length integer\n					for (q = delta, k = base; ; k += base) {\n						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n						if (q < t) {\n							break;\n						}\n						qMinusT = q - t;\n						baseMinusT = base - t;\n						output.push(\n							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))\n						);\n						q = floor(qMinusT / baseMinusT);\n					}\n\n					output.push(stringFromCharCode(digitToBasic(q, 0)));\n					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\n					delta = 0;\n					++handledCPCount;\n				}\n			}\n\n			++delta;\n			++n;\n\n		}\n		return output.join('');\n	}\n\n\n\n\n\n\n\n\n\n\n\n	function toUnicode(domain) {\n		return mapDomain(domain, function(string) {\n			return regexPunycode.test(string)\n				? decode(string.slice(4).toLowerCase())\n				: string;\n		});\n	}\n\n\n\n\n\n\n\n\n\n	function toASCII(domain) {\n		return mapDomain(domain, function(string) {\n			return regexNonASCII.test(string)\n				? 'xn--' + encode(string)\n				: string;\n		});\n	}\n\n\n\n\n	punycode = {\n\n\n\n\n\n		'version': '1.2.3',\n\n\n\n\n\n\n\n		'ucs2': {\n			'decode': ucs2decode,\n			'encode': ucs2encode\n		},\n		'decode': decode,\n		'encode': encode,\n		'toASCII': toASCII,\n		'toUnicode': toUnicode\n	};\n\n\n	// Some AMD build optimizers, like r.js, check for specific condition patterns\n	// like the following:\n	if (\n		typeof define == 'function' &&\n		typeof define.amd == 'object' &&\n		define.amd\n	) {\n		define(function() {\n			return punycode;\n		});\n	}	else if (freeExports && !freeExports.nodeType) {\n		if (freeModule) { // in Node.js or RingoJS v0.8.0+\n			freeModule.exports = punycode;\n		} else { // in Narwhal or RingoJS v0.7.0-\n			for (key in punycode) {\n				punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);\n			}\n		}\n	} else { // in Rhino or a web browser\n		root.punycode = punycode;\n	}\n\n}(this));\n",
  @"// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Query String Utilities\n\nvar QueryString = exports;\nvar util = require('util');\n\n\n// If obj.hasOwnProperty has been overridden, then calling\n// obj.hasOwnProperty(prop) will break.\n// See: https://github.com/joyent/node/issues/1707\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\n\nfunction charCode(c) {\n  return c.charCodeAt(0);\n}\n\n\n// a safe fast alternative to decodeURIComponent\nQueryString.unescapeBuffer = function(s, decodeSpaces) {\n  var out = new Buffer(s.length);\n  var state = 'CHAR'; // states: CHAR, HEX0, HEX1\n  var n, m, hexchar;\n\n  for (var inIndex = 0, outIndex = 0; inIndex <= s.length; inIndex++) {\n    var c = s.charCodeAt(inIndex);\n    switch (state) {\n      case 'CHAR':\n        switch (c) {\n          case charCode('%'):\n            n = 0;\n            m = 0;\n            state = 'HEX0';\n            break;\n          case charCode('+'):\n            if (decodeSpaces) c = charCode(' ');\n            // pass thru\n          default:\n            out[outIndex++] = c;\n            break;\n        }\n        break;\n\n      case 'HEX0':\n        state = 'HEX1';\n        hexchar = c;\n        if (charCode('0') <= c && c <= charCode('9')) {\n          n = c - charCode('0');\n        } else if (charCode('a') <= c && c <= charCode('f')) {\n          n = c - charCode('a') + 10;\n        } else if (charCode('A') <= c && c <= charCode('F')) {\n          n = c - charCode('A') + 10;\n        } else {\n          out[outIndex++] = charCode('%');\n          out[outIndex++] = c;\n          state = 'CHAR';\n          break;\n        }\n        break;\n\n      case 'HEX1':\n        state = 'CHAR';\n        if (charCode('0') <= c && c <= charCode('9')) {\n          m = c - charCode('0');\n        } else if (charCode('a') <= c && c <= charCode('f')) {\n          m = c - charCode('a') + 10;\n        } else if (charCode('A') <= c && c <= charCode('F')) {\n          m = c - charCode('A') + 10;\n        } else {\n          out[outIndex++] = charCode('%');\n          out[outIndex++] = hexchar;\n          out[outIndex++] = c;\n          break;\n        }\n        out[outIndex++] = 16 * n + m;\n        break;\n    }\n  }\n\n  // TODO support returning arbitrary buffers.\n\n  return out.slice(0, outIndex - 1);\n};\n\n\nQueryString.unescape = function(s, decodeSpaces) {\n  return QueryString.unescapeBuffer(s, decodeSpaces).toString();\n};\n\n\nQueryString.escape = function(str) {\n  return encodeURIComponent(str);\n};\n\nvar stringifyPrimitive = function(v) {\n  if (util.isString(v))\n    return v;\n  if (util.isBoolean(v))\n    return v ? 'true' : 'false';\n  if (util.isNumber(v))\n    return isFinite(v) ? v : '';\n  return '';\n};\n\n\nQueryString.stringify = QueryString.encode = function(obj, sep, eq, options) {\n  sep = sep || '&';\n  eq = eq || '=';\n  if (util.isNull(obj)) {\n    obj = undefined;\n  }\n\n  var encode = QueryString.escape;\n  if (options && typeof options.encodeURIComponent === 'function') {\n    encode = options.encodeURIComponent;\n  }\n\n  if (util.isObject(obj)) {\n    return Object.keys(obj).map(function(k) {\n      var ks = encode(stringifyPrimitive(k)) + eq;\n      if (util.isArray(obj[k])) {\n        return obj[k].map(function(v) {\n          return ks + encode(stringifyPrimitive(v));\n        }).join(sep);\n      } else {\n        return ks + encode(stringifyPrimitive(obj[k]));\n      }\n    }).join(sep);\n  }\n  return '';\n};\n\n// Parse a key=val string.\nQueryString.parse = QueryString.decode = function(qs, sep, eq, options) {\n  sep = sep || '&';\n  eq = eq || '=';\n  var obj = {};\n\n  if (!util.isString(qs) || qs.length === 0) {\n    return obj;\n  }\n\n  var regexp = /\\+/g;\n  qs = qs.split(sep);\n\n  var maxKeys = 1000;\n  if (options && util.isNumber(options.maxKeys)) {\n    maxKeys = options.maxKeys;\n  }\n\n  var len = qs.length;\n  // maxKeys <= 0 means that we should not limit keys count\n  if (maxKeys > 0 && len > maxKeys) {\n    len = maxKeys;\n  }\n\n  var decode = decodeURIComponent;\n  if (options && typeof options.decodeURIComponent === 'function') {\n    decode = options.decodeURIComponent;\n  }\n\n  for (var i = 0; i < len; ++i) {\n    var x = qs[i].replace(regexp, '%20'),\n        idx = x.indexOf(eq),\n        kstr, vstr, k, v;\n\n    if (idx >= 0) {\n      kstr = x.substr(0, idx);\n      vstr = x.substr(idx + 1);\n    } else {\n      kstr = x;\n      vstr = '';\n    }\n\n    try {\n      k = decode(kstr);\n      v = decode(vstr);\n    } catch (e) {\n      k = QueryString.unescape(kstr, true);\n      v = QueryString.unescape(vstr, true);\n    }\n\n    if (!hasOwnProperty(obj, k)) {\n      obj[k] = v;\n    } else if (util.isArray(obj[k])) {\n      obj[k].push(v);\n    } else {\n      obj[k] = [obj[k], v];\n    }\n  }\n\n  return obj;\n};\n",
  @"// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Inspiration for this code comes from Salvatore Sanfilippo's linenoise.\n// https://github.com/antirez/linenoise\n// Reference:\n// * http://invisible-island.net/xterm/ctlseqs/ctlseqs.html\n// * http://www.3waylabs.com/nw/WWW/products/wizcon/vt220.html\n\nvar kHistorySize = 30;\n\nvar util = require('util');\nvar inherits = require('util').inherits;\nvar EventEmitter = require('events').EventEmitter;\n\n\nexports.createInterface = function(input, output, completer, terminal) {\n  var rl;\n  if (arguments.length === 1) {\n    rl = new Interface(input);\n  } else {\n    rl = new Interface(input, output, completer, terminal);\n  }\n  return rl;\n};\n\n\nfunction Interface(input, output, completer, terminal) {\n  if (!(this instanceof Interface)) {\n    return new Interface(input, output, completer, terminal);\n  }\n\n  this._sawReturn = false;\n\n  EventEmitter.call(this);\n\n  if (arguments.length === 1) {\n    // an options object was given\n    output = input.output;\n    completer = input.completer;\n    terminal = input.terminal;\n    input = input.input;\n  }\n\n  completer = completer || function() { return []; };\n\n  if (!util.isFunction(completer)) {\n    throw new TypeError('Argument \\'completer\\' must be a function');\n  }\n\n  // backwards compat; check the isTTY prop of the output stream\n  //  when `terminal` was not specified\n  if (util.isUndefined(terminal)) {\n    terminal = !!output.isTTY;\n  }\n\n  var self = this;\n\n  this.output = output;\n  this.input = input;\n\n  // Check arity, 2 - for async, 1 for sync\n  this.completer = completer.length === 2 ? completer : function(v, callback) {\n    callback(null, completer(v));\n  };\n\n  this.setPrompt('> ');\n\n  this.terminal = !!terminal;\n\n  function ondata(data) {\n    self._normalWrite(data);\n  }\n\n  function onend() {\n    if (util.isString(self._line_buffer) && self._line_buffer.length > 0) {\n      self.emit('line', self._line_buffer);\n    }\n    self.close();\n  }\n\n  function ontermend() {\n    if (util.isString(self.line) && self.line.length > 0) {\n      self.emit('line', self.line);\n    }\n    self.close();\n  }\n\n  function onkeypress(s, key) {\n    self._ttyWrite(s, key);\n  }\n\n  function onresize() {\n    self._refreshLine();\n  }\n\n  if (!this.terminal) {\n    input.on('data', ondata);\n    input.on('end', onend);\n    self.once('close', function() {\n      input.removeListener('data', ondata);\n      input.removeListener('end', onend);\n    });\n    var StringDecoder = require('string_decoder').StringDecoder; // lazy load\n    this._decoder = new StringDecoder('utf8');\n\n  } else {\n\n    exports.emitKeypressEvents(input);\n\n    // input usually refers to stdin\n    input.on('keypress', onkeypress);\n    input.on('end', ontermend);\n\n    // Current line\n    this.line = '';\n\n    this._setRawMode(true);\n    this.terminal = true;\n\n    // Cursor position on the line.\n    this.cursor = 0;\n\n    this.history = [];\n    this.historyIndex = -1;\n\n    output.on('resize', onresize);\n    self.once('close', function() {\n      input.removeListener('keypress', onkeypress);\n      input.removeListener('end', ontermend);\n      output.removeListener('resize', onresize);\n    });\n  }\n\n  input.resume();\n}\n\ninherits(Interface, EventEmitter);\n\nInterface.prototype.__defineGetter__('columns', function() {\n  return this.output.columns || Infinity;\n});\n\nInterface.prototype.setPrompt = function(prompt) {\n  this._prompt = prompt;\n};\n\n\nInterface.prototype._setRawMode = function(mode) {\n  if (util.isFunction(this.input.setRawMode)) {\n    return this.input.setRawMode(mode);\n  }\n};\n\n\nInterface.prototype.prompt = function(preserveCursor) {\n  if (this.paused) this.resume();\n  if (this.terminal) {\n    if (!preserveCursor) this.cursor = 0;\n    this._refreshLine();\n  } else {\n    this.output.write(this._prompt);\n  }\n};\n\n\nInterface.prototype.question = function(query, cb) {\n  if (util.isFunction(cb)) {\n    if (this._questionCallback) {\n      this.prompt();\n    } else {\n      this._oldPrompt = this._prompt;\n      this.setPrompt(query);\n      this._questionCallback = cb;\n      this.prompt();\n    }\n  }\n};\n\n\nInterface.prototype._onLine = function(line) {\n  if (this._questionCallback) {\n    var cb = this._questionCallback;\n    this._questionCallback = null;\n    this.setPrompt(this._oldPrompt);\n    cb(line);\n  } else {\n    this.emit('line', line);\n  }\n};\n\n\nInterface.prototype._addHistory = function() {\n  if (this.line.length === 0) return '';\n\n  if (this.history.length === 0 || this.history[0] !== this.line) {\n    this.history.unshift(this.line);\n\n    // Only store so many\n    if (this.history.length > kHistorySize) this.history.pop();\n  }\n\n  this.historyIndex = -1;\n  return this.history[0];\n};\n\n\nInterface.prototype._refreshLine = function() {\n  // line length\n  var line = this._prompt + this.line;\n  var dispPos = this._getDisplayPos(line);\n  var lineCols = dispPos.cols;\n  var lineRows = dispPos.rows;\n\n  // cursor position\n  var cursorPos = this._getCursorPos();\n\n  // first move to the bottom of the current line, based on cursor pos\n  var prevRows = this.prevRows || 0;\n  if (prevRows > 0) {\n    exports.moveCursor(this.output, 0, -prevRows);\n  }\n\n  // Cursor to left edge.\n  exports.cursorTo(this.output, 0);\n  // erase data\n  exports.clearScreenDown(this.output);\n\n  // Write the prompt and the current buffer content.\n  this.output.write(line);\n\n  // Force terminal to allocate a new line\n  if (lineCols === 0) {\n    this.output.write(' ');\n  }\n\n  // Move cursor to original position.\n  exports.cursorTo(this.output, cursorPos.cols);\n\n  var diff = lineRows - cursorPos.rows;\n  if (diff > 0) {\n    exports.moveCursor(this.output, 0, -diff);\n  }\n\n  this.prevRows = cursorPos.rows;\n};\n\n\nInterface.prototype.close = function() {\n  if (this.closed) return;\n  this.pause();\n  if (this.terminal) {\n    this._setRawMode(false);\n  }\n  this.closed = true;\n  this.emit('close');\n};\n\n\nInterface.prototype.pause = function() {\n  if (this.paused) return;\n  this.input.pause();\n  this.paused = true;\n  this.emit('pause');\n  return this;\n};\n\n\nInterface.prototype.resume = function() {\n  if (!this.paused) return;\n  this.input.resume();\n  this.paused = false;\n  this.emit('resume');\n  return this;\n};\n\n\nInterface.prototype.write = function(d, key) {\n  if (this.paused) this.resume();\n  this.terminal ? this._ttyWrite(d, key) : this._normalWrite(d);\n};\n\n// \\r\\n, \\n, or \\r followed by something other than \\n\nvar lineEnding = /\\r?\\n|\\r(?!\\n)/;\nInterface.prototype._normalWrite = function(b) {\n  if (util.isUndefined(b)) {\n    return;\n  }\n  var string = this._decoder.write(b);\n  if (this._sawReturn) {\n    string = string.replace(/^\\n/, '');\n    this._sawReturn = false;\n  }\n\n  if (this._line_buffer) {\n    string = this._line_buffer + string;\n    this._line_buffer = null;\n  }\n  if (lineEnding.test(string)) {\n    this._sawReturn = /\\r$/.test(string);\n\n    // got one or more newlines; process into \"line\" events\n    var lines = string.split(lineEnding);\n    // either '' or (concievably) the unfinished portion of the next line\n    string = lines.pop();\n    this._line_buffer = string;\n    lines.forEach(function(line) {\n      this._onLine(line);\n    }, this);\n  } else if (string) {\n    // no newlines this time, save what we have for next time\n    this._line_buffer = string;\n  }\n};\n\nInterface.prototype._insertString = function(c) {\n  //BUG: Problem when adding tabs with following content.\n  //     Perhaps the bug is in _refreshLine(). Not sure.\n  //     A hack would be to insert spaces instead of literal '\\t'.\n  if (this.cursor < this.line.length) {\n    var beg = this.line.slice(0, this.cursor);\n    var end = this.line.slice(this.cursor, this.line.length);\n    this.line = beg + c + end;\n    this.cursor += c.length;\n    this._refreshLine();\n  } else {\n    this.line += c;\n    this.cursor += c.length;\n\n    if (this._getCursorPos().cols === 0) {\n      this._refreshLine();\n    } else {\n      this.output.write(c);\n    }\n\n    // a hack to get the line refreshed if it's needed\n    this._moveCursor(0);\n  }\n};\n\nInterface.prototype._tabComplete = function() {\n  var self = this;\n\n  self.pause();\n  self.completer(self.line.slice(0, self.cursor), function(err, rv) {\n    self.resume();\n\n    if (err) {\n      // XXX Log it somewhere?\n      return;\n    }\n\n    var completions = rv[0],\n        completeOn = rv[1];  // the text that was completed\n    if (completions && completions.length) {\n      // Apply/show completions.\n      if (completions.length === 1) {\n        self._insertString(completions[0].slice(completeOn.length));\n      } else {\n        self.output.write('\\r\\n');\n        var width = completions.reduce(function(a, b) {\n          return a.length > b.length ? a : b;\n        }).length + 2;  // 2 space padding\n        var maxColumns = Math.floor(self.columns / width) || 1;\n        var group = [], c;\n        for (var i = 0, compLen = completions.length; i < compLen; i++) {\n          c = completions[i];\n          if (c === '') {\n            handleGroup(self, group, width, maxColumns);\n            group = [];\n          } else {\n            group.push(c);\n          }\n        }\n        handleGroup(self, group, width, maxColumns);\n\n        // If there is a common prefix to all matches, then apply that\n        // portion.\n        var f = completions.filter(function(e) { if (e) return e; });\n        var prefix = commonPrefix(f);\n        if (prefix.length > completeOn.length) {\n          self._insertString(prefix.slice(completeOn.length));\n        }\n\n      }\n      self._refreshLine();\n    }\n  });\n};\n\n// this = Interface instance\nfunction handleGroup(self, group, width, maxColumns) {\n  if (group.length == 0) {\n    return;\n  }\n  var minRows = Math.ceil(group.length / maxColumns);\n  for (var row = 0; row < minRows; row++) {\n    for (var col = 0; col < maxColumns; col++) {\n      var idx = row * maxColumns + col;\n      if (idx >= group.length) {\n        break;\n      }\n      var item = group[idx];\n      self.output.write(item);\n      if (col < maxColumns - 1) {\n        for (var s = 0, itemLen = item.length; s < width - itemLen;\n             s++) {\n          self.output.write(' ');\n        }\n      }\n    }\n    self.output.write('\\r\\n');\n  }\n  self.output.write('\\r\\n');\n}\n\nfunction commonPrefix(strings) {\n  if (!strings || strings.length == 0) {\n    return '';\n  }\n  var sorted = strings.slice().sort();\n  var min = sorted[0];\n  var max = sorted[sorted.length - 1];\n  for (var i = 0, len = min.length; i < len; i++) {\n    if (min[i] != max[i]) {\n      return min.slice(0, i);\n    }\n  }\n  return min;\n}\n\n\nInterface.prototype._wordLeft = function() {\n  if (this.cursor > 0) {\n    var leading = this.line.slice(0, this.cursor);\n    var match = leading.match(/([^\\w\\s]+|\\w+|)\\s*$/);\n    this._moveCursor(-match[0].length);\n  }\n};\n\n\nInterface.prototype._wordRight = function() {\n  if (this.cursor < this.line.length) {\n    var trailing = this.line.slice(this.cursor);\n    var match = trailing.match(/^(\\s+|\\W+|\\w+)\\s*/);\n    this._moveCursor(match[0].length);\n  }\n};\n\n\nInterface.prototype._deleteLeft = function() {\n  if (this.cursor > 0 && this.line.length > 0) {\n    this.line = this.line.slice(0, this.cursor - 1) +\n                this.line.slice(this.cursor, this.line.length);\n\n    this.cursor--;\n    this._refreshLine();\n  }\n};\n\n\nInterface.prototype._deleteRight = function() {\n  this.line = this.line.slice(0, this.cursor) +\n              this.line.slice(this.cursor + 1, this.line.length);\n  this._refreshLine();\n};\n\n\nInterface.prototype._deleteWordLeft = function() {\n  if (this.cursor > 0) {\n    var leading = this.line.slice(0, this.cursor);\n    var match = leading.match(/([^\\w\\s]+|\\w+|)\\s*$/);\n    leading = leading.slice(0, leading.length - match[0].length);\n    this.line = leading + this.line.slice(this.cursor, this.line.length);\n    this.cursor = leading.length;\n    this._refreshLine();\n  }\n};\n\n\nInterface.prototype._deleteWordRight = function() {\n  if (this.cursor < this.line.length) {\n    var trailing = this.line.slice(this.cursor);\n    var match = trailing.match(/^(\\s+|\\W+|\\w+)\\s*/);\n    this.line = this.line.slice(0, this.cursor) +\n                trailing.slice(match[0].length);\n    this._refreshLine();\n  }\n};\n\n\nInterface.prototype._deleteLineLeft = function() {\n  this.line = this.line.slice(this.cursor);\n  this.cursor = 0;\n  this._refreshLine();\n};\n\n\nInterface.prototype._deleteLineRight = function() {\n  this.line = this.line.slice(0, this.cursor);\n  this._refreshLine();\n};\n\n\nInterface.prototype.clearLine = function() {\n  this._moveCursor(+Infinity);\n  this.output.write('\\r\\n');\n  this.line = '';\n  this.cursor = 0;\n  this.prevRows = 0;\n};\n\n\nInterface.prototype._line = function() {\n  var line = this._addHistory();\n  this.clearLine();\n  this._onLine(line);\n};\n\n\nInterface.prototype._historyNext = function() {\n  if (this.historyIndex > 0) {\n    this.historyIndex--;\n    this.line = this.history[this.historyIndex];\n    this.cursor = this.line.length; // set cursor to end of line.\n    this._refreshLine();\n\n  } else if (this.historyIndex === 0) {\n    this.historyIndex = -1;\n    this.cursor = 0;\n    this.line = '';\n    this._refreshLine();\n  }\n};\n\n\nInterface.prototype._historyPrev = function() {\n  if (this.historyIndex + 1 < this.history.length) {\n    this.historyIndex++;\n    this.line = this.history[this.historyIndex];\n    this.cursor = this.line.length; // set cursor to end of line.\n\n    this._refreshLine();\n  }\n};\n\n\n// Returns the last character's display position of the given string\nInterface.prototype._getDisplayPos = function(str) {\n  var offset = 0;\n  var col = this.columns;\n  var row = 0;\n  var code;\n  str = stripVTControlCharacters(str);\n  for (var i = 0, len = str.length; i < len; i++) {\n    code = codePointAt(str, i);\n    if (code >= 0x10000) { // surrogates\n      i++;\n    }\n    if (code === 0x0a) { // new line \\n\n      offset = 0;\n      row += 1;\n      continue;\n    }\n    if (isFullWidthCodePoint(code)) {\n      if ((offset + 1) % col === 0) {\n        offset++;\n      }\n      offset += 2;\n    } else {\n      offset++;\n    }\n  }\n  var cols = offset % col;\n  var rows = row + (offset - cols) / col;\n  return {cols: cols, rows: rows};\n};\n\n\n// Returns current cursor's position and line\nInterface.prototype._getCursorPos = function() {\n  var columns = this.columns;\n  var strBeforeCursor = this._prompt + this.line.substring(0, this.cursor);\n  var dispPos = this._getDisplayPos(stripVTControlCharacters(strBeforeCursor));\n  var cols = dispPos.cols;\n  var rows = dispPos.rows;\n  // If the cursor is on a full-width character which steps over the line,\n  // move the cursor to the beginning of the next line.\n  if (cols + 1 === columns &&\n      this.cursor < this.line.length &&\n      isFullWidthCodePoint(codePointAt(this.line, this.cursor))) {\n    rows++;\n    cols = 0;\n  }\n  return {cols: cols, rows: rows};\n};\n\n\n// This function moves cursor dx places to the right\n// (-dx for left) and refreshes the line if it is needed\nInterface.prototype._moveCursor = function(dx) {\n  var oldcursor = this.cursor;\n  var oldPos = this._getCursorPos();\n  this.cursor += dx;\n\n  // bounds check\n  if (this.cursor < 0) this.cursor = 0;\n  else if (this.cursor > this.line.length) this.cursor = this.line.length;\n\n  var newPos = this._getCursorPos();\n\n  // check if cursors are in the same line\n  if (oldPos.rows === newPos.rows) {\n    var diffCursor = this.cursor - oldcursor;\n    var diffWidth;\n    if (diffCursor < 0) {\n      diffWidth = -getStringWidth(\n          this.line.substring(this.cursor, oldcursor)\n          );\n    } else if (diffCursor > 0) {\n      diffWidth = getStringWidth(\n          this.line.substring(this.cursor, oldcursor)\n          );\n    }\n    exports.moveCursor(this.output, diffWidth, 0);\n    this.prevRows = newPos.rows;\n  } else {\n    this._refreshLine();\n  }\n};\n\n\n// handle a write from the tty\nInterface.prototype._ttyWrite = function(s, key) {\n  key = key || {};\n\n  // Ignore escape key - Fixes #2876\n  if (key.name == 'escape') return;\n\n  if (key.ctrl && key.shift) {\n\n    switch (key.name) {\n      case 'backspace':\n        this._deleteLineLeft();\n        break;\n\n      case 'delete':\n        this._deleteLineRight();\n        break;\n    }\n\n  } else if (key.ctrl) {\n\n\n    switch (key.name) {\n      case 'c':\n        if (EventEmitter.listenerCount(this, 'SIGINT') > 0) {\n          this.emit('SIGINT');\n        } else {\n          // This readline instance is finished\n          this.close();\n        }\n        break;\n\n      case 'h': // delete left\n        this._deleteLeft();\n        break;\n\n      case 'd': // delete right or EOF\n        if (this.cursor === 0 && this.line.length === 0) {\n          // This readline instance is finished\n          this.close();\n        } else if (this.cursor < this.line.length) {\n          this._deleteRight();\n        }\n        break;\n\n      case 'u': // delete the whole line\n        this.cursor = 0;\n        this.line = '';\n        this._refreshLine();\n        break;\n\n      case 'k': // delete from current to end of line\n        this._deleteLineRight();\n        break;\n\n      case 'a': // go to the start of the line\n        this._moveCursor(-Infinity);\n        break;\n\n      case 'e': // go to the end of the line\n        this._moveCursor(+Infinity);\n        break;\n\n      case 'b': // back one character\n        this._moveCursor(-1);\n        break;\n\n      case 'f': // forward one character\n        this._moveCursor(+1);\n        break;\n\n      case 'l': // clear the whole screen\n        exports.cursorTo(this.output, 0, 0);\n        exports.clearScreenDown(this.output);\n        this._refreshLine();\n        break;\n\n      case 'n': // next history item\n        this._historyNext();\n        break;\n\n      case 'p': // previous history item\n        this._historyPrev();\n        break;\n\n      case 'z':\n        if (process.platform == 'win32') break;\n        if (EventEmitter.listenerCount(this, 'SIGTSTP') > 0) {\n          this.emit('SIGTSTP');\n        } else {\n          process.once('SIGCONT', (function(self) {\n            return function() {\n              // Don't raise events if stream has already been abandoned.\n              if (!self.paused) {\n                // Stream must be paused and resumed after SIGCONT to catch\n                // SIGINT, SIGTSTP, and EOF.\n                self.pause();\n                self.emit('SIGCONT');\n              }\n              // explicitly re-enable \"raw mode\" and move the cursor to\n              // the correct position.\n              // See https://github.com/joyent/node/issues/3295.\n              self._setRawMode(true);\n              self._refreshLine();\n            };\n          })(this));\n          this._setRawMode(false);\n          process.kill(process.pid, 'SIGTSTP');\n        }\n        break;\n\n      case 'w': // delete backwards to a word boundary\n      case 'backspace':\n        this._deleteWordLeft();\n        break;\n\n      case 'delete': // delete forward to a word boundary\n        this._deleteWordRight();\n        break;\n\n      case 'left':\n        this._wordLeft();\n        break;\n\n      case 'right':\n        this._wordRight();\n        break;\n    }\n\n  } else if (key.meta) {\n\n\n    switch (key.name) {\n      case 'b': // backward word\n        this._wordLeft();\n        break;\n\n      case 'f': // forward word\n        this._wordRight();\n        break;\n\n      case 'd': // delete forward word\n      case 'delete':\n        this._deleteWordRight();\n        break;\n\n      case 'backspace': // delete backwards to a word boundary\n        this._deleteWordLeft();\n        break;\n    }\n\n  } else {\n\n\n    // \\r bookkeeping is only relevant if a \\n comes right after.\n    if (this._sawReturn && key.name !== 'enter')\n      this._sawReturn = false;\n\n    switch (key.name) {\n      case 'return':  // carriage return, i.e. \\r\n        this._sawReturn = true;\n        this._line();\n        break;\n\n      case 'enter':\n        if (this._sawReturn)\n          this._sawReturn = false;\n        else\n          this._line();\n        break;\n\n      case 'backspace':\n        this._deleteLeft();\n        break;\n\n      case 'delete':\n        this._deleteRight();\n        break;\n\n      case 'tab': // tab completion\n        this._tabComplete();\n        break;\n\n      case 'left':\n        this._moveCursor(-1);\n        break;\n\n      case 'right':\n        this._moveCursor(+1);\n        break;\n\n      case 'home':\n        this._moveCursor(-Infinity);\n        break;\n\n      case 'end':\n        this._moveCursor(+Infinity);\n        break;\n\n      case 'up':\n        this._historyPrev();\n        break;\n\n      case 'down':\n        this._historyNext();\n        break;\n\n      default:\n        if (util.isBuffer(s))\n          s = s.toString('utf-8');\n\n        if (s) {\n          var lines = s.split(/\\r\\n|\\n|\\r/);\n          for (var i = 0, len = lines.length; i < len; i++) {\n            if (i > 0) {\n              this._line();\n            }\n            this._insertString(lines[i]);\n          }\n        }\n    }\n  }\n};\n\n\nexports.Interface = Interface;\n\n\n\n\n\n\n\nfunction emitKeypressEvents(stream) {\n  if (stream._keypressDecoder) return;\n  var StringDecoder = require('string_decoder').StringDecoder; // lazy load\n  stream._keypressDecoder = new StringDecoder('utf8');\n\n  function onData(b) {\n    if (EventEmitter.listenerCount(stream, 'keypress') > 0) {\n      var r = stream._keypressDecoder.write(b);\n      if (r) emitKeys(stream, r);\n    } else {\n      // Nobody's watching anyway\n      stream.removeListener('data', onData);\n      stream.on('newListener', onNewListener);\n    }\n  }\n\n  function onNewListener(event) {\n    if (event == 'keypress') {\n      stream.on('data', onData);\n      stream.removeListener('newListener', onNewListener);\n    }\n  }\n\n  if (EventEmitter.listenerCount(stream, 'keypress') > 0) {\n    stream.on('data', onData);\n  } else {\n    stream.on('newListener', onNewListener);\n  }\n}\nexports.emitKeypressEvents = emitKeypressEvents;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// Regexes used for ansi escape code splitting\nvar metaKeyCodeReAnywhere = /(?:\\x1b)([a-zA-Z0-9])/;\nvar metaKeyCodeRe = new RegExp('^' + metaKeyCodeReAnywhere.source + '$');\nvar functionKeyCodeReAnywhere = new RegExp('(?:\\x1b+)(O|N|\\\\[|\\\\[\\\\[)(?:' + [\n  '(\\\\d+)(?:;(\\\\d+))?([~^$])',\n  '(?:M([@ #!a`])(.)(.))', // mouse\n  '(?:1;)?(\\\\d+)?([a-zA-Z])'\n].join('|') + ')');\nvar functionKeyCodeRe = new RegExp('^' + functionKeyCodeReAnywhere.source);\nvar escapeCodeReAnywhere = new RegExp([\n  functionKeyCodeReAnywhere.source, metaKeyCodeReAnywhere.source, /\\x1b./.source\n].join('|'));\n\nfunction emitKeys(stream, s) {\n  if (util.isBuffer(s)) {\n    if (s[0] > 127 && util.isUndefined(s[1])) {\n      s[0] -= 128;\n      s = '\\x1b' + s.toString(stream.encoding || 'utf-8');\n    } else {\n      s = s.toString(stream.encoding || 'utf-8');\n    }\n  }\n\n  var buffer = [];\n  var match;\n  while (match = escapeCodeReAnywhere.exec(s)) {\n    buffer = buffer.concat(s.slice(0, match.index).split(''));\n    buffer.push(match[0]);\n    s = s.slice(match.index + match[0].length);\n  }\n  buffer = buffer.concat(s.split(''));\n\n  buffer.forEach(function(s) {\n    var ch,\n        key = {\n          sequence: s,\n          name: undefined,\n          ctrl: false,\n          meta: false,\n          shift: false\n        },\n        parts;\n\n    if (s === '\\r') {\n      // carriage return\n      key.name = 'return';\n\n    } else if (s === '\\n') {\n      // enter, should have been called linefeed\n      key.name = 'enter';\n\n    } else if (s === '\\t') {\n      // tab\n      key.name = 'tab';\n\n    } else if (s === '\\b' || s === '\\x7f' ||\n               s === '\\x1b\\x7f' || s === '\\x1b\\b') {\n      // backspace or ctrl+h\n      key.name = 'backspace';\n      key.meta = (s.charAt(0) === '\\x1b');\n\n    } else if (s === '\\x1b' || s === '\\x1b\\x1b') {\n      // escape key\n      key.name = 'escape';\n      key.meta = (s.length === 2);\n\n    } else if (s === ' ' || s === '\\x1b ') {\n      key.name = 'space';\n      key.meta = (s.length === 2);\n\n    } else if (s.length === 1 && s <= '\\x1a') {\n      // ctrl+letter\n      key.name = String.fromCharCode(s.charCodeAt(0) + 'a'.charCodeAt(0) - 1);\n      key.ctrl = true;\n\n    } else if (s.length === 1 && s >= 'a' && s <= 'z') {\n      // lowercase letter\n      key.name = s;\n\n    } else if (s.length === 1 && s >= 'A' && s <= 'Z') {\n      // shift+letter\n      key.name = s.toLowerCase();\n      key.shift = true;\n\n    } else if (parts = metaKeyCodeRe.exec(s)) {\n      // meta+character key\n      key.name = parts[1].toLowerCase();\n      key.meta = true;\n      key.shift = /^[A-Z]$/.test(parts[1]);\n\n    } else if (parts = functionKeyCodeRe.exec(s)) {\n      // ansi escape sequence\n\n      // reassemble the key code leaving out leading \\x1b's,\n      // the modifier key bitflag and any meaningless \"1;\" sequence\n      var code = (parts[1] || '') + (parts[2] || '') +\n                 (parts[4] || '') + (parts[9] || ''),\n          modifier = (parts[3] || parts[8] || 1) - 1;\n\n      // Parse the key modifier\n      key.ctrl = !!(modifier & 4);\n      key.meta = !!(modifier & 10);\n      key.shift = !!(modifier & 1);\n      key.code = code;\n\n      // Parse the key itself\n      switch (code) {\n\n        case 'OP': key.name = 'f1'; break;\n        case 'OQ': key.name = 'f2'; break;\n        case 'OR': key.name = 'f3'; break;\n        case 'OS': key.name = 'f4'; break;\n\n\n        case '[11~': key.name = 'f1'; break;\n        case '[12~': key.name = 'f2'; break;\n        case '[13~': key.name = 'f3'; break;\n        case '[14~': key.name = 'f4'; break;\n\n\n        case '[[A': key.name = 'f1'; break;\n        case '[[B': key.name = 'f2'; break;\n        case '[[C': key.name = 'f3'; break;\n        case '[[D': key.name = 'f4'; break;\n        case '[[E': key.name = 'f5'; break;\n\n\n        case '[15~': key.name = 'f5'; break;\n        case '[17~': key.name = 'f6'; break;\n        case '[18~': key.name = 'f7'; break;\n        case '[19~': key.name = 'f8'; break;\n        case '[20~': key.name = 'f9'; break;\n        case '[21~': key.name = 'f10'; break;\n        case '[23~': key.name = 'f11'; break;\n        case '[24~': key.name = 'f12'; break;\n\n\n        case '[A': key.name = 'up'; break;\n        case '[B': key.name = 'down'; break;\n        case '[C': key.name = 'right'; break;\n        case '[D': key.name = 'left'; break;\n        case '[E': key.name = 'clear'; break;\n        case '[F': key.name = 'end'; break;\n        case '[H': key.name = 'home'; break;\n\n\n        case 'OA': key.name = 'up'; break;\n        case 'OB': key.name = 'down'; break;\n        case 'OC': key.name = 'right'; break;\n        case 'OD': key.name = 'left'; break;\n        case 'OE': key.name = 'clear'; break;\n        case 'OF': key.name = 'end'; break;\n        case 'OH': key.name = 'home'; break;\n\n\n        case '[1~': key.name = 'home'; break;\n        case '[2~': key.name = 'insert'; break;\n        case '[3~': key.name = 'delete'; break;\n        case '[4~': key.name = 'end'; break;\n        case '[5~': key.name = 'pageup'; break;\n        case '[6~': key.name = 'pagedown'; break;\n\n\n        case '[[5~': key.name = 'pageup'; break;\n        case '[[6~': key.name = 'pagedown'; break;\n\n\n        case '[7~': key.name = 'home'; break;\n        case '[8~': key.name = 'end'; break;\n\n\n        case '[a': key.name = 'up'; key.shift = true; break;\n        case '[b': key.name = 'down'; key.shift = true; break;\n        case '[c': key.name = 'right'; key.shift = true; break;\n        case '[d': key.name = 'left'; key.shift = true; break;\n        case '[e': key.name = 'clear'; key.shift = true; break;\n\n        case '[2$': key.name = 'insert'; key.shift = true; break;\n        case '[3$': key.name = 'delete'; key.shift = true; break;\n        case '[5$': key.name = 'pageup'; key.shift = true; break;\n        case '[6$': key.name = 'pagedown'; key.shift = true; break;\n        case '[7$': key.name = 'home'; key.shift = true; break;\n        case '[8$': key.name = 'end'; key.shift = true; break;\n\n        case 'Oa': key.name = 'up'; key.ctrl = true; break;\n        case 'Ob': key.name = 'down'; key.ctrl = true; break;\n        case 'Oc': key.name = 'right'; key.ctrl = true; break;\n        case 'Od': key.name = 'left'; key.ctrl = true; break;\n        case 'Oe': key.name = 'clear'; key.ctrl = true; break;\n\n        case '[2^': key.name = 'insert'; key.ctrl = true; break;\n        case '[3^': key.name = 'delete'; key.ctrl = true; break;\n        case '[5^': key.name = 'pageup'; key.ctrl = true; break;\n        case '[6^': key.name = 'pagedown'; key.ctrl = true; break;\n        case '[7^': key.name = 'home'; key.ctrl = true; break;\n        case '[8^': key.name = 'end'; key.ctrl = true; break;\n\n\n        case '[Z': key.name = 'tab'; key.shift = true; break;\n        default: key.name = 'undefined'; break;\n\n      }\n    }\n\n    // Don't emit a key if no name was found\n    if (util.isUndefined(key.name)) {\n      key = undefined;\n    }\n\n    if (s.length === 1) {\n      ch = s;\n    }\n\n    if (key || ch) {\n      stream.emit('keypress', ch, key);\n    }\n  });\n}\n\n\n\n\n\n\nfunction cursorTo(stream, x, y) {\n  if (!util.isNumber(x) && !util.isNumber(y))\n    return;\n\n  if (!util.isNumber(x))\n    throw new Error(\"Can't set cursor row without also setting it's column\");\n\n  if (!util.isNumber(y)) {\n    stream.write('\\x1b[' + (x + 1) + 'G');\n  } else {\n    stream.write('\\x1b[' + (y + 1) + ';' + (x + 1) + 'H');\n  }\n}\nexports.cursorTo = cursorTo;\n\n\n\n\n\n\nfunction moveCursor(stream, dx, dy) {\n  if (dx < 0) {\n    stream.write('\\x1b[' + (-dx) + 'D');\n  } else if (dx > 0) {\n    stream.write('\\x1b[' + dx + 'C');\n  }\n\n  if (dy < 0) {\n    stream.write('\\x1b[' + (-dy) + 'A');\n  } else if (dy > 0) {\n    stream.write('\\x1b[' + dy + 'B');\n  }\n}\nexports.moveCursor = moveCursor;\n\n\n\n\n\n\n\n\n\nfunction clearLine(stream, dir) {\n  if (dir < 0) {\n    // to the beginning\n    stream.write('\\x1b[1K');\n  } else if (dir > 0) {\n    // to the end\n    stream.write('\\x1b[0K');\n  } else {\n    // entire line\n    stream.write('\\x1b[2K');\n  }\n}\nexports.clearLine = clearLine;\n\n\n\n\n\n\nfunction clearScreenDown(stream) {\n  stream.write('\\x1b[0J');\n}\nexports.clearScreenDown = clearScreenDown;\n\n\n\n\n\n\nfunction getStringWidth(str) {\n  var width = 0;\n  str = stripVTControlCharacters(str);\n  for (var i = 0, len = str.length; i < len; i++) {\n    var code = codePointAt(str, i);\n    if (code >= 0x10000) { // surrogates\n      i++;\n    }\n    if (isFullWidthCodePoint(code)) {\n      width += 2;\n    } else {\n      width++;\n    }\n  }\n  return width;\n}\nexports.getStringWidth = getStringWidth;\n\n\n\n\n\n\n\nfunction isFullWidthCodePoint(code) {\n  if (isNaN(code)) {\n    return false;\n  }\n\n  // Code points are derived from:\n  // http://www.unicode.org/Public/UNIDATA/EastAsianWidth.txt\n  if (code >= 0x1100 && (\n      code <= 0x115f ||  // Hangul Jamo\n      0x2329 === code || // LEFT-POINTING ANGLE BRACKET\n      0x232a === code || // RIGHT-POINTING ANGLE BRACKET\n      // CJK Radicals Supplement .. Enclosed CJK Letters and Months\n      (0x2e80 <= code && code <= 0x3247 && code !== 0x303f) ||\n      // Enclosed CJK Letters and Months .. CJK Unified Ideographs Extension A\n      0x3250 <= code && code <= 0x4dbf ||\n      // CJK Unified Ideographs .. Yi Radicals\n      0x4e00 <= code && code <= 0xa4c6 ||\n      // Hangul Jamo Extended-A\n      0xa960 <= code && code <= 0xa97c ||\n      // Hangul Syllables\n      0xac00 <= code && code <= 0xd7a3 ||\n      // CJK Compatibility Ideographs\n      0xf900 <= code && code <= 0xfaff ||\n      // Vertical Forms\n      0xfe10 <= code && code <= 0xfe19 ||\n      // CJK Compatibility Forms .. Small Form Variants\n      0xfe30 <= code && code <= 0xfe6b ||\n      // Halfwidth and Fullwidth Forms\n      0xff01 <= code && code <= 0xff60 ||\n      0xffe0 <= code && code <= 0xffe6 ||\n      // Kana Supplement\n      0x1b000 <= code && code <= 0x1b001 ||\n      // Enclosed Ideographic Supplement\n      0x1f200 <= code && code <= 0x1f251 ||\n      // CJK Unified Ideographs Extension B .. Tertiary Ideographic Plane\n      0x20000 <= code && code <= 0x3fffd)) {\n    return true;\n  }\n  return false;\n}\nexports.isFullWidthCodePoint = isFullWidthCodePoint;\n\n\n\n\n\n\n\n\nfunction codePointAt(str, index) {\n  var code = str.charCodeAt(index);\n  var low;\n  if (0xd800 <= code && code <= 0xdbff) { // High surrogate\n    low = str.charCodeAt(index + 1);\n    if (!isNaN(low)) {\n      code = 0x10000 + (code - 0xd800) * 0x400 + (low - 0xdc00);\n    }\n  }\n  return code;\n}\nexports.codePointAt = codePointAt;\n\n\n\n\n\n\nfunction stripVTControlCharacters(str) {\n  str = str.replace(new RegExp(functionKeyCodeReAnywhere.source, 'g'), '');\n  return str.replace(new RegExp(metaKeyCodeReAnywhere.source, 'g'), '');\n}\nexports.stripVTControlCharacters = stripVTControlCharacters;\n",
  @"// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar util = require('util');\nvar inherits = require('util').inherits;\nvar Stream = require('stream');\nvar vm = require('vm');\nvar path = require('path');\nvar fs = require('fs');\nvar rl = require('readline');\nvar Console = require('console').Console;\nvar domain = require('domain');\nvar debug = util.debuglog('repl');\n\n// If obj.hasOwnProperty has been overridden, then calling\n// obj.hasOwnProperty(prop) will break.\n// See: https://github.com/joyent/node/issues/1707\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\n\n// hack for require.resolve(\"./relative\") to work properly.\nmodule.filename = path.resolve('repl');\n\n// hack for repl require to work properly with node_modules folders\nmodule.paths = require('module')._nodeModulePaths(module.filename);\n\n// Can overridden with custom print functions, such as `probe` or `eyes.js`.\n// This is the default \"writer\" value if none is passed in the REPL options.\nexports.writer = util.inspect;\n\nexports._builtinLibs = ['assert', 'buffer', 'child_process', 'cluster',\n  'crypto', 'dgram', 'dns', 'domain', 'events', 'fs', 'http', 'https', 'net',\n  'os', 'path', 'punycode', 'querystring', 'readline', 'stream',\n  'string_decoder', 'tls', 'tty', 'url', 'util', 'vm', 'zlib', 'smalloc',\n  'tracing'];\n\n\nfunction REPLServer(prompt, stream, eval_, useGlobal, ignoreUndefined) {\n  if (!(this instanceof REPLServer)) {\n    return new REPLServer(prompt, stream, eval_, useGlobal, ignoreUndefined);\n  }\n\n  var options, input, output, dom;\n  if (util.isObject(prompt)) {\n    // an options object was given\n    options = prompt;\n    stream = options.stream || options.socket;\n    input = options.input;\n    output = options.output;\n    eval_ = options.eval;\n    useGlobal = options.useGlobal;\n    ignoreUndefined = options.ignoreUndefined;\n    prompt = options.prompt;\n    dom = options.domain;\n  } else if (!util.isString(prompt)) {\n    throw new Error('An options Object, or a prompt String are required');\n  } else {\n    options = {};\n  }\n\n  var self = this;\n\n  self._domain = dom || domain.create();\n\n  self.useGlobal = !!useGlobal;\n  self.ignoreUndefined = !!ignoreUndefined;\n\n  // just for backwards compat, see github.com/joyent/node/pull/7127\n  self.rli = this;\n\n  eval_ = eval_ || defaultEval;\n\n  function defaultEval(code, context, file, cb) {\n    var err, result;\n    // first, create the Script object to check the syntax\n    try {\n      var script = vm.createScript(code, {\n        filename: file,\n        displayErrors: false\n      });\n    } catch (e) {\n      debug('parse error %j', code, e);\n      if (isRecoverableError(e))\n        err = new Recoverable(e);\n      else\n        err = e;\n    }\n\n    if (!err) {\n      try {\n        if (self.useGlobal) {\n          result = script.runInThisContext({ displayErrors: false });\n        } else {\n          result = script.runInContext(context, { displayErrors: false });\n        }\n      } catch (e) {\n        err = e;\n        if (err && process.domain) {\n          debug('not recoverable, send to domain');\n          process.domain.emit('error', err);\n          process.domain.exit();\n          return;\n        }\n      }\n    }\n\n    cb(err, result);\n  }\n\n  self.eval = self._domain.bind(eval_);\n\n  self._domain.on('error', function(e) {\n    debug('domain error');\n    self.outputStream.write((e.stack || e) + '\\n');\n    self.bufferedCommand = '';\n    self.lines.level = [];\n    self.displayPrompt();\n  });\n\n  if (!input && !output) {\n    // legacy API, passing a 'stream'/'socket' option\n    if (!stream) {\n      // use stdin and stdout as the default streams if none were given\n      stream = process;\n    }\n    if (stream.stdin && stream.stdout) {\n      // We're given custom object with 2 streams, or the `process` object\n      input = stream.stdin;\n      output = stream.stdout;\n    } else {\n      // We're given a duplex readable/writable Stream, like a `net.Socket`\n      input = stream;\n      output = stream;\n    }\n  }\n\n  self.inputStream = input;\n  self.outputStream = output;\n\n  self.resetContext();\n  self.bufferedCommand = '';\n  self.lines.level = [];\n\n  function complete(text, callback) {\n    self.complete(text, callback);\n  }\n\n  rl.Interface.apply(this, [\n    self.inputStream,\n    self.outputStream,\n    complete,\n    options.terminal\n  ]);\n\n  self.setPrompt(!util.isUndefined(prompt) ? prompt : '> ');\n\n  this.commands = {};\n  defineDefaultCommands(this);\n\n  // figure out which \"writer\" function to use\n  self.writer = options.writer || exports.writer;\n\n  if (util.isUndefined(options.useColors)) {\n    options.useColors = self.terminal;\n  }\n  self.useColors = !!options.useColors;\n\n  if (self.useColors && self.writer === util.inspect) {\n    // Turn on ANSI coloring.\n    self.writer = function(obj, showHidden, depth) {\n      return util.inspect(obj, showHidden, depth, true);\n    };\n  }\n\n  self.setPrompt(self._prompt);\n\n  self.on('close', function() {\n    self.emit('exit');\n  });\n\n  var sawSIGINT = false;\n  self.on('SIGINT', function() {\n    var empty = self.line.length === 0;\n    self.clearLine();\n\n    if (!(self.bufferedCommand && self.bufferedCommand.length > 0) && empty) {\n      if (sawSIGINT) {\n        self.close();\n        sawSIGINT = false;\n        return;\n      }\n      self.output.write('(^C again to quit)\\n');\n      sawSIGINT = true;\n    } else {\n      sawSIGINT = false;\n    }\n\n    self.bufferedCommand = '';\n    self.lines.level = [];\n    self.displayPrompt();\n  });\n\n  self.on('line', function(cmd) {\n    debug('line %j', cmd);\n    sawSIGINT = false;\n    var skipCatchall = false;\n    cmd = trimWhitespace(cmd);\n\n    // Check to see if a REPL keyword was used. If it returns true,\n    // display next prompt and return.\n    if (cmd && cmd.charAt(0) === '.' && isNaN(parseFloat(cmd))) {\n      var matches = cmd.match(/^\\.([^\\s]+)\\s*(.*)$/);\n      var keyword = matches && matches[1];\n      var rest = matches && matches[2];\n      if (self.parseREPLKeyword(keyword, rest) === true) {\n        return;\n      } else {\n        self.outputStream.write('Invalid REPL keyword\\n');\n        skipCatchall = true;\n      }\n    }\n\n    if (!skipCatchall) {\n      var evalCmd = self.bufferedCommand + cmd;\n      if (/^\\s*\\{/.test(evalCmd) && /\\}\\s*$/.test(evalCmd)) {\n        // It's confusing for `{ a : 1 }` to be interpreted as a block\n        // statement rather than an object literal.  So, we first try\n        // to wrap it in parentheses, so that it will be interpreted as\n        // an expression.\n        evalCmd = '(' + evalCmd + ')\\n';\n      } else {\n        // otherwise we just append a \\n so that it will be either\n        // terminated, or continued onto the next expression if it's an\n        // unexpected end of input.\n        evalCmd = evalCmd + '\\n';\n      }\n\n      debug('eval %j', evalCmd);\n      self.eval(evalCmd, self.context, 'repl', finish);\n    } else {\n      finish(null);\n    }\n\n    function finish(e, ret) {\n      debug('finish', e, ret);\n      self.memory(cmd);\n\n      if (e && !self.bufferedCommand && cmd.trim().match(/^npm /)) {\n        self.outputStream.write('npm should be run outside of the ' +\n                                'node repl, in your normal shell.\\n' +\n                                '(Press Control-D to exit.)\\n');\n        self.bufferedCommand = '';\n        self.displayPrompt();\n        return;\n      }\n\n      // If error was SyntaxError and not JSON.parse error\n      if (e) {\n        if (e instanceof Recoverable) {\n          // Start buffering data like that:\n          // {\n          // ...  x: 1\n          // ... }\n          self.bufferedCommand += cmd + '\\n';\n          self.displayPrompt();\n          return;\n        } else {\n          self._domain.emit('error', e);\n        }\n      }\n\n      // Clear buffer if no SyntaxErrors\n      self.bufferedCommand = '';\n\n      // If we got any output - print it (if no error)\n      if (!e && (!self.ignoreUndefined || !util.isUndefined(ret))) {\n        self.context._ = ret;\n        self.outputStream.write(self.writer(ret) + '\\n');\n      }\n\n      // Display prompt again\n      self.displayPrompt();\n    };\n  });\n\n  self.on('SIGCONT', function() {\n    self.displayPrompt(true);\n  });\n\n  self.displayPrompt();\n}\ninherits(REPLServer, rl.Interface);\nexports.REPLServer = REPLServer;\n\n\n// prompt is a string to print on each line for the prompt,\n// source is a stream to use for I/O, defaulting to stdin/stdout.\nexports.start = function(prompt, source, eval_, useGlobal, ignoreUndefined) {\n  var repl = new REPLServer(prompt, source, eval_, useGlobal, ignoreUndefined);\n  if (!exports.repl) exports.repl = repl;\n  return repl;\n};\n\nREPLServer.prototype.createContext = function() {\n  var context;\n  if (this.useGlobal) {\n    context = global;\n  } else {\n    context = vm.createContext();\n    for (var i in global) context[i] = global[i];\n    context.console = new Console(this.outputStream);\n    context.global = context;\n    context.global.global = context;\n  }\n\n  context.module = module;\n  context.require = require;\n\n  this.lines = [];\n  this.lines.level = [];\n\n  // make built-in modules available directly\n  // (loaded lazily)\n  exports._builtinLibs.forEach(function(name) {\n    Object.defineProperty(context, name, {\n      get: function() {\n        var lib = require(name);\n        context._ = context[name] = lib;\n        return lib;\n      },\n      // allow the creation of other globals with this name\n      set: function(val) {\n        delete context[name];\n        context[name] = val;\n      },\n      configurable: true\n    });\n  });\n\n  return context;\n};\n\nREPLServer.prototype.resetContext = function() {\n  this.context = this.createContext();\n\n  // Allow REPL extensions to extend the new context\n  this.emit('reset', this.context);\n};\n\nREPLServer.prototype.displayPrompt = function(preserveCursor) {\n  var initial = this._prompt;\n  var prompt = initial;\n  if (this.bufferedCommand.length) {\n    prompt = '...';\n    var levelInd = new Array(this.lines.level.length).join('..');\n    prompt += levelInd + ' ';\n  }\n  this.setPrompt(prompt);\n  this.prompt(preserveCursor);\n  this.setPrompt(initial);\n};\n\n// A stream to push an array into a REPL\n// used in REPLServer.complete\nfunction ArrayStream() {\n  Stream.call(this);\n\n  this.run = function(data) {\n    var self = this;\n    data.forEach(function(line) {\n      self.emit('data', line + '\\n');\n    });\n  }\n}\nutil.inherits(ArrayStream, Stream);\nArrayStream.prototype.readable = true;\nArrayStream.prototype.writable = true;\nArrayStream.prototype.resume = function() {};\nArrayStream.prototype.write = function() {};\n\nvar requireRE = /\\brequire\\s*\\(['\"](([\\w\\.\\/-]+\\/)?([\\w\\.\\/-]*))/;\nvar simpleExpressionRE =\n    /(([a-zA-Z_$](?:\\w|\\$)*)\\.)*([a-zA-Z_$](?:\\w|\\$)*)\\.?$/;\n\n\n// Provide a list of completions for the given leading text. This is\n// given to the readline interface for handling tab completion.\n//\n// Example:\n//  complete('var foo = util.')\n//    -> [['util.print', 'util.debug', 'util.log', 'util.inspect', 'util.pump'],\n//        'util.' ]\n//\n// Warning: This eval's code like \"foo.bar.baz\", so it will run property\n// getter code.\nREPLServer.prototype.complete = function(line, callback) {\n  // There may be local variables to evaluate, try a nested REPL\n  if (!util.isUndefined(this.bufferedCommand) && this.bufferedCommand.length) {\n    // Get a new array of inputed lines\n    var tmp = this.lines.slice();\n    // Kill off all function declarations to push all local variables into\n    // global scope\n    this.lines.level.forEach(function(kill) {\n      if (kill.isFunction) {\n        tmp[kill.line] = '';\n      }\n    });\n    var flat = new ArrayStream();         // make a new \"input\" stream\n    var magic = new REPLServer('', flat); // make a nested REPL\n    magic.context = magic.createContext();\n    flat.run(tmp);                        // eval the flattened code\n    // all this is only profitable if the nested REPL\n    // does not have a bufferedCommand\n    if (!magic.bufferedCommand) {\n      return magic.complete(line, callback);\n    }\n  }\n\n  var completions;\n\n  // list of completion lists, one for each inheritance \"level\"\n  var completionGroups = [];\n\n  var completeOn, match, filter, i, group, c;\n\n  // REPL commands (e.g. \".break\").\n  var match = null;\n  match = line.match(/^\\s*(\\.\\w*)$/);\n  if (match) {\n    completionGroups.push(Object.keys(this.commands));\n    completeOn = match[1];\n    if (match[1].length > 1) {\n      filter = match[1];\n    }\n\n    completionGroupsLoaded();\n  } else if (match = line.match(requireRE)) {\n    // require('...<Tab>')\n    var exts = Object.keys(require.extensions);\n    var indexRe = new RegExp('^index(' + exts.map(regexpEscape).join('|') +\n                             ')$');\n\n    completeOn = match[1];\n    var subdir = match[2] || '';\n    var filter = match[1];\n    var dir, files, f, name, base, ext, abs, subfiles, s;\n    group = [];\n    var paths = module.paths.concat(require('module').globalPaths);\n    for (i = 0; i < paths.length; i++) {\n      dir = path.resolve(paths[i], subdir);\n      try {\n        files = fs.readdirSync(dir);\n      } catch (e) {\n        continue;\n      }\n      for (f = 0; f < files.length; f++) {\n        name = files[f];\n        ext = path.extname(name);\n        base = name.slice(0, -ext.length);\n        if (base.match(/-\\d+\\.\\d+(\\.\\d+)?/) || name === '.npm') {\n          // Exclude versioned names that 'npm' installs.\n          continue;\n        }\n        if (exts.indexOf(ext) !== -1) {\n          if (!subdir || base !== 'index') {\n            group.push(subdir + base);\n          }\n        } else {\n          abs = path.resolve(dir, name);\n          try {\n            if (fs.statSync(abs).isDirectory()) {\n              group.push(subdir + name + '/');\n              subfiles = fs.readdirSync(abs);\n              for (s = 0; s < subfiles.length; s++) {\n                if (indexRe.test(subfiles[s])) {\n                  group.push(subdir + name);\n                }\n              }\n            }\n          } catch (e) {}\n        }\n      }\n    }\n    if (group.length) {\n      completionGroups.push(group);\n    }\n\n    if (!subdir) {\n      completionGroups.push(exports._builtinLibs);\n    }\n\n    completionGroupsLoaded();\n\n  // Handle variable member lookup.\n  // We support simple chained expressions like the following (no function\n  // calls, etc.). That is for simplicity and also because we *eval* that\n  // leading expression so for safety (see WARNING above) don't want to\n  // eval function calls.\n  //\n  //   foo.bar<|>     # completions for 'foo' with filter 'bar'\n  //   spam.eggs.<|>  # completions for 'spam.eggs' with filter ''\n  //   foo<|>         # all scope vars with filter 'foo'\n  //   foo.<|>        # completions for 'foo' with filter ''\n  } else if (line.length === 0 || line[line.length - 1].match(/\\w|\\.|\\$/)) {\n    match = simpleExpressionRE.exec(line);\n    if (line.length === 0 || match) {\n      var expr;\n      completeOn = (match ? match[0] : '');\n      if (line.length === 0) {\n        filter = '';\n        expr = '';\n      } else if (line[line.length - 1] === '.') {\n        filter = '';\n        expr = match[0].slice(0, match[0].length - 1);\n      } else {\n        var bits = match[0].split('.');\n        filter = bits.pop();\n        expr = bits.join('.');\n      }\n\n      // Resolve expr and get its completions.\n      var memberGroups = [];\n      if (!expr) {\n        // If context is instance of vm.ScriptContext\n        // Get global vars synchronously\n        if (this.useGlobal ||\n            this.context.constructor &&\n            this.context.constructor.name === 'Context') {\n          var contextProto = this.context;\n          while (contextProto = Object.getPrototypeOf(contextProto)) {\n            completionGroups.push(Object.getOwnPropertyNames(contextProto));\n          }\n          completionGroups.push(Object.getOwnPropertyNames(this.context));\n          addStandardGlobals(completionGroups, filter);\n          completionGroupsLoaded();\n        } else {\n          this.eval('.scope', this.context, 'repl', function(err, globals) {\n            if (err || !globals) {\n              addStandardGlobals(completionGroups, filter);\n            } else if (util.isArray(globals[0])) {\n              // Add grouped globals\n              globals.forEach(function(group) {\n                completionGroups.push(group);\n              });\n            } else {\n              completionGroups.push(globals);\n              addStandardGlobals(completionGroups, filter);\n            }\n            completionGroupsLoaded();\n          });\n        }\n      } else {\n        this.eval(expr, this.context, 'repl', function(e, obj) {\n          // if (e) console.log(e);\n\n          if (obj != null) {\n            if (util.isObject(obj) || util.isFunction(obj)) {\n              memberGroups.push(Object.getOwnPropertyNames(obj));\n            }\n            // works for non-objects\n            try {\n              var sentinel = 5;\n              var p;\n              if (util.isObject(obj) || util.isFunction(obj)) {\n                p = Object.getPrototypeOf(obj);\n              } else {\n                p = obj.constructor ? obj.constructor.prototype : null;\n              }\n              while (!util.isNull(p)) {\n                memberGroups.push(Object.getOwnPropertyNames(p));\n                p = Object.getPrototypeOf(p);\n                // Circular refs possible? Let's guard against that.\n                sentinel--;\n                if (sentinel <= 0) {\n                  break;\n                }\n              }\n            } catch (e) {\n              //console.log(\"completion error walking prototype chain:\" + e);\n            }\n          }\n\n          if (memberGroups.length) {\n            for (i = 0; i < memberGroups.length; i++) {\n              completionGroups.push(memberGroups[i].map(function(member) {\n                return expr + '.' + member;\n              }));\n            }\n            if (filter) {\n              filter = expr + '.' + filter;\n            }\n          }\n\n          completionGroupsLoaded();\n        });\n      }\n    } else {\n      completionGroupsLoaded();\n    }\n  } else {\n    completionGroupsLoaded();\n  }\n\n  // Will be called when all completionGroups are in place\n  // Useful for async autocompletion\n  function completionGroupsLoaded(err) {\n    if (err) throw err;\n\n    // Filter, sort (within each group), uniq and merge the completion groups.\n    if (completionGroups.length && filter) {\n      var newCompletionGroups = [];\n      for (i = 0; i < completionGroups.length; i++) {\n        group = completionGroups[i].filter(function(elem) {\n          return elem.indexOf(filter) == 0;\n        });\n        if (group.length) {\n          newCompletionGroups.push(group);\n        }\n      }\n      completionGroups = newCompletionGroups;\n    }\n\n    if (completionGroups.length) {\n      var uniq = {};  // unique completions across all groups\n      completions = [];\n      // Completion group 0 is the \"closest\"\n      // (least far up the inheritance chain)\n      // so we put its completions last: to be closest in the REPL.\n      for (i = completionGroups.length - 1; i >= 0; i--) {\n        group = completionGroups[i];\n        group.sort();\n        for (var j = 0; j < group.length; j++) {\n          c = group[j];\n          if (!hasOwnProperty(uniq, c)) {\n            completions.push(c);\n            uniq[c] = true;\n          }\n        }\n        completions.push(''); // separator btwn groups\n      }\n      while (completions.length && completions[completions.length - 1] === '') {\n        completions.pop();\n      }\n    }\n\n    callback(null, [completions || [], completeOn]);\n  }\n};\n\n\n\n\n\n\n\n\nREPLServer.prototype.parseREPLKeyword = function(keyword, rest) {\n  var cmd = this.commands[keyword];\n  if (cmd) {\n    cmd.action.call(this, rest);\n    return true;\n  }\n  return false;\n};\n\n\nREPLServer.prototype.defineCommand = function(keyword, cmd) {\n  if (util.isFunction(cmd)) {\n    cmd = {action: cmd};\n  } else if (!util.isFunction(cmd.action)) {\n    throw new Error('bad argument, action must be a function');\n  }\n  this.commands[keyword] = cmd;\n};\n\nREPLServer.prototype.memory = function memory(cmd) {\n  var self = this;\n\n  self.lines = self.lines || [];\n  self.lines.level = self.lines.level || [];\n\n  // save the line so I can do magic later\n  if (cmd) {\n    // TODO should I tab the level?\n    self.lines.push(new Array(self.lines.level.length).join('  ') + cmd);\n  } else {\n    // I don't want to not change the format too much...\n    self.lines.push('');\n  }\n\n  // I need to know \"depth.\"\n  // Because I can not tell the difference between a } that\n  // closes an object literal and a } that closes a function\n  if (cmd) {\n    // going down is { and (   e.g. function() {\n    // going up is } and )\n    var dw = cmd.match(/{|\\(/g);\n    var up = cmd.match(/}|\\)/g);\n    up = up ? up.length : 0;\n    dw = dw ? dw.length : 0;\n    var depth = dw - up;\n\n    if (depth) {\n      (function workIt() {\n        if (depth > 0) {\n          // going... down.\n          // push the line#, depth count, and if the line is a function.\n          // Since JS only has functional scope I only need to remove\n          // \"function() {\" lines, clearly this will not work for\n          // \"function()\n          // {\" but nothing should break, only tab completion for local\n          // scope will not work for this function.\n          self.lines.level.push({\n            line: self.lines.length - 1,\n            depth: depth,\n            isFunction: /\\s*function\\s*/.test(cmd)\n          });\n        } else if (depth < 0) {\n          // going... up.\n          var curr = self.lines.level.pop();\n          if (curr) {\n            var tmp = curr.depth + depth;\n            if (tmp < 0) {\n              //more to go, recurse\n              depth += curr.depth;\n              workIt();\n            } else if (tmp > 0) {\n              //remove and push back\n              curr.depth += depth;\n              self.lines.level.push(curr);\n            }\n          }\n        }\n      }());\n    }\n\n    // it is possible to determine a syntax error at this point.\n    // if the REPL still has a bufferedCommand and\n    // self.lines.level.length === 0\n    // TODO? keep a log of level so that any syntax breaking lines can\n    // be cleared on .break and in the case of a syntax error?\n    // TODO? if a log was kept, then I could clear the bufferedComand and\n    // eval these lines and throw the syntax error\n  } else {\n    self.lines.level = [];\n  }\n};\n\nfunction addStandardGlobals(completionGroups, filter) {\n  // Global object properties\n  // (http://www.ecma-international.org/publications/standards/Ecma-262.htm)\n  completionGroups.push(['NaN', 'Infinity', 'undefined',\n    'eval', 'parseInt', 'parseFloat', 'isNaN', 'isFinite', 'decodeURI',\n    'decodeURIComponent', 'encodeURI', 'encodeURIComponent',\n    'Object', 'Function', 'Array', 'String', 'Boolean', 'Number',\n    'Date', 'RegExp', 'Error', 'EvalError', 'RangeError',\n    'ReferenceError', 'SyntaxError', 'TypeError', 'URIError',\n    'Math', 'JSON']);\n  // Common keywords. Exclude for completion on the empty string, b/c\n  // they just get in the way.\n  if (filter) {\n    completionGroups.push(['break', 'case', 'catch', 'const',\n      'continue', 'debugger', 'default', 'delete', 'do', 'else',\n      'export', 'false', 'finally', 'for', 'function', 'if',\n      'import', 'in', 'instanceof', 'let', 'new', 'null', 'return',\n      'switch', 'this', 'throw', 'true', 'try', 'typeof', 'undefined',\n      'var', 'void', 'while', 'with', 'yield']);\n  }\n}\n\nfunction defineDefaultCommands(repl) {\n  // TODO remove me after 0.3.x\n  repl.defineCommand('break', {\n    help: 'Sometimes you get stuck, this gets you out',\n    action: function() {\n      this.bufferedCommand = '';\n      this.displayPrompt();\n    }\n  });\n\n  var clearMessage;\n  if (repl.useGlobal) {\n    clearMessage = 'Alias for .break';\n  } else {\n    clearMessage = 'Break, and also clear the local context';\n  }\n  repl.defineCommand('clear', {\n    help: clearMessage,\n    action: function() {\n      this.bufferedCommand = '';\n      if (!this.useGlobal) {\n        this.outputStream.write('Clearing context...\\n');\n        this.resetContext();\n      }\n      this.displayPrompt();\n    }\n  });\n\n  repl.defineCommand('exit', {\n    help: 'Exit the repl',\n    action: function() {\n      this.close();\n    }\n  });\n\n  repl.defineCommand('help', {\n    help: 'Show repl options',\n    action: function() {\n      var self = this;\n      Object.keys(this.commands).sort().forEach(function(name) {\n        var cmd = self.commands[name];\n        self.outputStream.write(name + '\\t' + (cmd.help || '') + '\\n');\n      });\n      this.displayPrompt();\n    }\n  });\n\n  repl.defineCommand('save', {\n    help: 'Save all evaluated commands in this REPL session to a file',\n    action: function(file) {\n      try {\n        fs.writeFileSync(file, this.lines.join('\\n') + '\\n');\n        this.outputStream.write('Session saved to:' + file + '\\n');\n      } catch (e) {\n        this.outputStream.write('Failed to save:' + file + '\\n');\n      }\n      this.displayPrompt();\n    }\n  });\n\n  repl.defineCommand('load', {\n    help: 'Load JS from a file into the REPL session',\n    action: function(file) {\n      try {\n        var stats = fs.statSync(file);\n        if (stats && stats.isFile()) {\n          var self = this;\n          var data = fs.readFileSync(file, 'utf8');\n          var lines = data.split('\\n');\n          this.displayPrompt();\n          lines.forEach(function(line) {\n            if (line) {\n              self.write(line + '\\n');\n            }\n          });\n        }\n      } catch (e) {\n        this.outputStream.write('Failed to load:' + file + '\\n');\n      }\n      this.displayPrompt();\n    }\n  });\n}\n\n\nfunction trimWhitespace(cmd) {\n  var trimmer = /^\\s*(.+)\\s*$/m,\n      matches = trimmer.exec(cmd);\n\n  if (matches && matches.length === 2) {\n    return matches[1];\n  }\n  return '';\n}\n\n\nfunction regexpEscape(s) {\n  return s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&');\n}\n\n\n\n\n\n\n\n\n\n\nREPLServer.prototype.convertToContext = function(cmd) {\n  var self = this, matches,\n      scopeVar = /^\\s*var\\s*([_\\w\\$]+)(.*)$/m,\n      scopeFunc = /^\\s*function\\s*([_\\w\\$]+)/;\n\n  // Replaces: var foo = \"bar\";  with: self.context.foo = bar;\n  matches = scopeVar.exec(cmd);\n  if (matches && matches.length === 3) {\n    return 'self.context.' + matches[1] + matches[2];\n  }\n\n  // Replaces: function foo() {};  with: foo = function foo() {};\n  matches = scopeFunc.exec(self.bufferedCommand);\n  if (matches && matches.length === 2) {\n    return matches[1] + ' = ' + self.bufferedCommand;\n  }\n\n  return cmd;\n};\n\n\n// If the error is that we've unexpectedly ended the input,\n// then let the user try to recover by adding more input.\nfunction isRecoverableError(e) {\n  return e &&\n      e.name === 'SyntaxError' &&\n      /^(Unexpected end of input|Unexpected token :)/.test(e.message);\n}\n\nfunction Recoverable(err) {\n  this.err = err;\n}\ninherits(Recoverable, SyntaxError);\n",
  @"// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar smalloc = process.binding('smalloc');\nvar kMaxLength = smalloc.kMaxLength;\nvar util = require('util');\n\nexports.alloc = alloc;\nexports.copyOnto = smalloc.copyOnto;\nexports.dispose = dispose;\nexports.hasExternalData = smalloc.hasExternalData;\n\n// don't allow kMaxLength to accidentally be overwritten. it's a lot less\n// apparent when a primitive is accidentally changed.\nObject.defineProperty(exports, 'kMaxLength', {\n  enumerable: true, value: kMaxLength, writable: false\n});\n\n// enumerated values for different external array types\nvar Types = {};\n\nObject.defineProperties(Types, {\n  'Int8': { enumerable: true, value: 1, writable: false },\n  'Uint8': { enumerable: true, value: 2, writable: false },\n  'Int16': { enumerable: true, value: 3, writable: false },\n  'Uint16': { enumerable: true, value: 4, writable: false },\n  'Int32': { enumerable: true, value: 5, writable: false },\n  'Uint32': { enumerable: true, value: 6, writable: false },\n  'Float': { enumerable: true, value: 7, writable: false },\n  'Double': { enumerable: true, value: 8, writable: false },\n  'Uint8Clamped': { enumerable: true, value: 9, writable: false }\n});\n\nObject.defineProperty(exports, 'Types', {\n  enumerable: true, value: Types, writable: false\n});\n\n\n// usage: obj = alloc(n[, obj][, type]);\nfunction alloc(n, obj, type) {\n  n = n >>> 0;\n\n  if (util.isUndefined(obj))\n    obj = {};\n\n  if (util.isNumber(obj)) {\n    type = obj >>> 0;\n    obj = {};\n  } else if (util.isPrimitive(obj)) {\n    throw new TypeError('obj must be an Object');\n  }\n\n  // 1 == v8::kExternalByteArray, 9 == v8::kExternalPixelArray\n  if (type < 1 || type > 9)\n    throw new TypeError('unknown external array type: ' + type);\n  if (util.isArray(obj))\n    throw new TypeError('Arrays are not supported');\n  if (n > kMaxLength)\n    throw new RangeError('n > kMaxLength');\n\n  return smalloc.alloc(obj, n, type);\n}\n\n\nfunction dispose(obj) {\n  if (util.isPrimitive(obj))\n    throw new TypeError('obj must be an Object');\n  if (util.isBuffer(obj))\n    throw new TypeError('obj cannot be a Buffer');\n\n  smalloc.dispose(obj);\n}\n",
  @"// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nmodule.exports = Stream;\n\nvar EE = require('events').EventEmitter;\nvar util = require('util');\n\nutil.inherits(Stream, EE);\nStream.Readable = require('_stream_readable');\nStream.Writable = require('_stream_writable');\nStream.Duplex = require('_stream_duplex');\nStream.Transform = require('_stream_transform');\nStream.PassThrough = require('_stream_passthrough');\n\n// Backwards-compat with node 0.4.x\nStream.Stream = Stream;\n\n\n\n// old-style streams.  Note that the pipe method (the only relevant\n// part of this class) is overridden in the Readable class.\n\nfunction Stream() {\n  EE.call(this);\n}\n\nStream.prototype.pipe = function(dest, options) {\n  var source = this;\n\n  function ondata(chunk) {\n    if (dest.writable) {\n      if (false === dest.write(chunk) && source.pause) {\n        source.pause();\n      }\n    }\n  }\n\n  source.on('data', ondata);\n\n  function ondrain() {\n    if (source.readable && source.resume) {\n      source.resume();\n    }\n  }\n\n  dest.on('drain', ondrain);\n\n  // If the 'end' option is not supplied, dest.end() will be called when\n  // source gets the 'end' or 'close' events.  Only dest.end() once.\n  if (!dest._isStdio && (!options || options.end !== false)) {\n    source.on('end', onend);\n    source.on('close', onclose);\n  }\n\n  var didOnEnd = false;\n  function onend() {\n    if (didOnEnd) return;\n    didOnEnd = true;\n\n    dest.end();\n  }\n\n\n  function onclose() {\n    if (didOnEnd) return;\n    didOnEnd = true;\n\n    if (util.isFunction(dest.destroy)) dest.destroy();\n  }\n\n  // don't leave dangling pipes when there are errors.\n  function onerror(er) {\n    cleanup();\n    if (EE.listenerCount(this, 'error') === 0) {\n      throw er; // Unhandled stream error in pipe.\n    }\n  }\n\n  source.on('error', onerror);\n  dest.on('error', onerror);\n\n  // remove all the event listeners that were added.\n  function cleanup() {\n    source.removeListener('data', ondata);\n    dest.removeListener('drain', ondrain);\n\n    source.removeListener('end', onend);\n    source.removeListener('close', onclose);\n\n    source.removeListener('error', onerror);\n    dest.removeListener('error', onerror);\n\n    source.removeListener('end', cleanup);\n    source.removeListener('close', cleanup);\n\n    dest.removeListener('close', cleanup);\n  }\n\n  source.on('end', cleanup);\n  source.on('close', cleanup);\n\n  dest.on('close', cleanup);\n\n  dest.emit('pipe', source);\n\n  // Allow for unix-like usage: A.pipe(B).pipe(C)\n  return dest;\n};\n",
  @"// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nfunction assertEncoding(encoding) {\n  if (encoding && !Buffer.isEncoding(encoding)) {\n    throw new Error('Unknown encoding: ' + encoding);\n  }\n}\n\n// StringDecoder provides an interface for efficiently splitting a series of\n// buffers into a series of JS strings without breaking apart multi-byte\n// characters. CESU-8 is handled as part of the UTF-8 encoding.\n//\n// @TODO Handling all encodings inside a single object makes it very difficult\n// to reason about this code, so it should be split up in the future.\n// @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code\n// points as used by CESU-8.\nvar StringDecoder = exports.StringDecoder = function(encoding) {\n  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');\n  assertEncoding(encoding);\n  switch (this.encoding) {\n    case 'utf8':\n      // CESU-8 represents each of Surrogate Pair by 3-bytes\n      this.surrogateSize = 3;\n      break;\n    case 'ucs2':\n    case 'utf16le':\n      // UTF-16 represents each of Surrogate Pair by 2-bytes\n      this.surrogateSize = 2;\n      this.detectIncompleteChar = utf16DetectIncompleteChar;\n      break;\n    case 'base64':\n      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.\n      this.surrogateSize = 3;\n      this.detectIncompleteChar = base64DetectIncompleteChar;\n      break;\n    default:\n      this.write = passThroughWrite;\n      return;\n  }\n\n  // Enough space to store all bytes of a single character. UTF-8 needs 4\n  // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).\n  this.charBuffer = new Buffer(6);\n  // Number of bytes received for the current incomplete multi-byte character.\n  this.charReceived = 0;\n  // Number of bytes expected for the current incomplete multi-byte character.\n  this.charLength = 0;\n};\n\n\n// write decodes the given buffer and returns it as JS string that is\n// guaranteed to not contain any partial multi-byte characters. Any partial\n// character found at the end of the buffer is buffered up, and will be\n// returned when calling write again with the remaining bytes.\n//\n// Note: Converting a Buffer containing an orphan surrogate to a String\n// currently works, but converting a String to a Buffer (via `new Buffer`, or\n// Buffer#write) will replace incomplete surrogates with the unicode\n// replacement character. See https://codereview.chromium.org/121173009/ .\nStringDecoder.prototype.write = function(buffer) {\n  var charStr = '';\n  // if our last write ended with an incomplete multibyte character\n  while (this.charLength) {\n    // determine how many remaining bytes this buffer has to offer for this char\n    var available = (buffer.length >= this.charLength - this.charReceived) ?\n                    this.charLength - this.charReceived :\n                    buffer.length;\n\n    // add the new bytes to the char buffer\n    buffer.copy(this.charBuffer, this.charReceived, 0, available);\n    this.charReceived += available;\n\n    if (this.charReceived < this.charLength) {\n      // still not enough chars in this buffer? wait for more ...\n      return '';\n    }\n\n    // remove bytes belonging to the current character from the buffer\n    buffer = buffer.slice(available, buffer.length);\n\n    // get the character that was split\n    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);\n\n    // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character\n    var charCode = charStr.charCodeAt(charStr.length - 1);\n    if (charCode >= 0xD800 && charCode <= 0xDBFF) {\n      this.charLength += this.surrogateSize;\n      charStr = '';\n      continue;\n    }\n    this.charReceived = this.charLength = 0;\n\n    // if there are no more bytes in this buffer, just emit our char\n    if (buffer.length === 0) {\n      return charStr;\n    }\n    break;\n  }\n\n  // determine and set charLength / charReceived\n  this.detectIncompleteChar(buffer);\n\n  var end = buffer.length;\n  if (this.charLength) {\n    // buffer the incomplete character bytes we got\n    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);\n    end -= this.charReceived;\n  }\n\n  charStr += buffer.toString(this.encoding, 0, end);\n\n  var end = charStr.length - 1;\n  var charCode = charStr.charCodeAt(end);\n  // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character\n  if (charCode >= 0xD800 && charCode <= 0xDBFF) {\n    var size = this.surrogateSize;\n    this.charLength += size;\n    this.charReceived += size;\n    this.charBuffer.copy(this.charBuffer, size, 0, size);\n    buffer.copy(this.charBuffer, 0, 0, size);\n    return charStr.substring(0, end);\n  }\n\n  // or just emit the charStr\n  return charStr;\n};\n\n// detectIncompleteChar determines if there is an incomplete UTF-8 character at\n// the end of the given buffer. If so, it sets this.charLength to the byte\n// length that character, and sets this.charReceived to the number of bytes\n// that are available for this character.\nStringDecoder.prototype.detectIncompleteChar = function(buffer) {\n  // determine how many bytes we have to check at the end of this buffer\n  var i = (buffer.length >= 3) ? 3 : buffer.length;\n\n  // Figure out if one of the last i bytes of our buffer announces an\n  // incomplete char.\n  for (; i > 0; i--) {\n    var c = buffer[buffer.length - i];\n\n    // See http://en.wikipedia.org/wiki/UTF-8#Description\n\n    // 110XXXXX\n    if (i == 1 && c >> 5 == 0x06) {\n      this.charLength = 2;\n      break;\n    }\n\n    // 1110XXXX\n    if (i <= 2 && c >> 4 == 0x0E) {\n      this.charLength = 3;\n      break;\n    }\n\n    // 11110XXX\n    if (i <= 3 && c >> 3 == 0x1E) {\n      this.charLength = 4;\n      break;\n    }\n  }\n  this.charReceived = i;\n};\n\nStringDecoder.prototype.end = function(buffer) {\n  var res = '';\n  if (buffer && buffer.length)\n    res = this.write(buffer);\n\n  if (this.charReceived) {\n    var cr = this.charReceived;\n    var buf = this.charBuffer;\n    var enc = this.encoding;\n    res += buf.slice(0, cr).toString(enc);\n  }\n\n  return res;\n};\n\nfunction passThroughWrite(buffer) {\n  return buffer.toString(this.encoding);\n}\n\nfunction utf16DetectIncompleteChar(buffer) {\n  this.charReceived = buffer.length % 2;\n  this.charLength = this.charReceived ? 2 : 0;\n}\n\nfunction base64DetectIncompleteChar(buffer) {\n  this.charReceived = buffer.length % 3;\n  this.charLength = this.charReceived ? 3 : 0;\n}\n",
  @"// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// the sys module was renamed to 'util'.\n// this shim remains to keep old programs working.\nmodule.exports = require('util');\n",
  @"// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar Timer = process.binding('timer_wrap').Timer;\nvar L = require('_linklist');\nvar assert = require('assert').ok;\n\nvar kOnTimeout = Timer.kOnTimeout | 0;\n\n// Timeout values > TIMEOUT_MAX are set to 1.\nvar TIMEOUT_MAX = 2147483647; // 2^31-1\n\nvar debug = require('util').debuglog('timer');\n\nvar tracing = require('tracing');\nvar asyncFlags = tracing._asyncFlags;\nvar runAsyncQueue = tracing._runAsyncQueue;\nvar loadAsyncQueue = tracing._loadAsyncQueue;\nvar unloadAsyncQueue = tracing._unloadAsyncQueue;\n\n// Same as in AsyncListener in env.h\nvar kHasListener = 0;\n\n// Do a little housekeeping.\ndelete tracing._asyncFlags;\ndelete tracing._runAsyncQueue;\ndelete tracing._loadAsyncQueue;\ndelete tracing._unloadAsyncQueue;\n\n\n// IDLE TIMEOUTS\n//\n// Because often many sockets will have the same idle timeout we will not\n// use one timeout watcher per item. It is too much overhead.  Instead\n// we'll use a single watcher for all sockets with the same timeout value\n// and a linked list. This technique is described in the libev manual:\n// http://pod.tst.eu/http://cvs.schmorp.de/libev/ev.pod#Be_smart_about_timeouts\n\n// Object containing all lists, timers\n// key = time in milliseconds\n// value = list\nvar lists = {};\n\n// Make Timer as monomorphic as possible.\nTimer.prototype._asyncQueue = undefined;\nTimer.prototype._asyncData = undefined;\nTimer.prototype._asyncFlags = 0;\n\n// the main function - creates lists on demand and the watchers associated\n// with them.\nfunction insert(item, msecs) {\n  item._idleStart = Timer.now();\n  item._idleTimeout = msecs;\n\n  if (msecs < 0) return;\n\n  var list;\n\n  if (lists[msecs]) {\n    list = lists[msecs];\n  } else {\n    list = new Timer();\n    list.start(msecs, 0);\n\n    L.init(list);\n\n    lists[msecs] = list;\n    list.msecs = msecs;\n    list[kOnTimeout] = listOnTimeout;\n  }\n\n  L.append(list, item);\n  assert(!L.isEmpty(list)); // list is not empty\n}\n\nfunction listOnTimeout() {\n  var msecs = this.msecs;\n  var list = this;\n\n  debug('timeout callback %d', msecs);\n\n  var now = Timer.now();\n  debug('now: %s', now);\n\n  var diff, first, hasQueue, threw;\n  while (first = L.peek(list)) {\n    diff = now - first._idleStart;\n    if (diff < msecs) {\n      list.start(msecs - diff, 0);\n      debug('%d list wait because diff is %d', msecs, diff);\n      return;\n    } else {\n      L.remove(first);\n      assert(first !== L.peek(list));\n\n      if (!first._onTimeout) continue;\n\n      // v0.4 compatibility: if the timer callback throws and the\n      // domain or uncaughtException handler ignore the exception,\n      // other timers that expire on this tick should still run.\n      //\n      // https://github.com/joyent/node/issues/2631\n      var domain = first.domain;\n      if (domain && domain._disposed)\n        continue;\n\n      hasQueue = !!first._asyncQueue;\n\n      try {\n        if (hasQueue)\n          loadAsyncQueue(first);\n        if (domain)\n          domain.enter();\n        threw = true;\n        first._onTimeout();\n        if (domain)\n          domain.exit();\n        if (hasQueue)\n          unloadAsyncQueue(first);\n        threw = false;\n      } finally {\n        if (threw) {\n          // We need to continue processing after domain error handling\n          // is complete, but not by using whatever domain was left over\n          // when the timeout threw its exception.\n          var oldDomain = process.domain;\n          process.domain = null;\n          process.nextTick(function() {\n            list[kOnTimeout]();\n          });\n          process.domain = oldDomain;\n        }\n      }\n    }\n  }\n\n  debug('%d list empty', msecs);\n  assert(L.isEmpty(list));\n  list.close();\n  delete lists[msecs];\n}\n\n\nvar unenroll = exports.unenroll = function(item) {\n  L.remove(item);\n\n  var list = lists[item._idleTimeout];\n  // if empty then stop the watcher\n  debug('unenroll');\n  if (list && L.isEmpty(list)) {\n    debug('unenroll: list empty');\n    list.close();\n    delete lists[item._idleTimeout];\n  }\n  // if active is called later, then we want to make sure not to insert again\n  item._idleTimeout = -1;\n};\n\n\n// Does not start the time, just sets up the members needed.\nexports.enroll = function(item, msecs) {\n  // if this item was already in a list somewhere\n  // then we should unenroll it from that\n  if (item._idleNext) unenroll(item);\n\n  // Ensure that msecs fits into signed int32\n  if (msecs > 0x7fffffff) {\n    msecs = 0x7fffffff;\n  }\n\n  item._idleTimeout = msecs;\n  L.init(item);\n};\n\n\n// call this whenever the item is active (not idle)\n// it will reset its timeout.\nexports.active = function(item) {\n  var msecs = item._idleTimeout;\n  if (msecs >= 0) {\n    var list = lists[msecs];\n    if (!list || L.isEmpty(list)) {\n      insert(item, msecs);\n    } else {\n      item._idleStart = Timer.now();\n      L.append(list, item);\n    }\n  }\n  // Whether or not a new TimerWrap needed to be created, this should run\n  // for each item. This way each \"item\" (i.e. timer) can properly have\n  // their own domain assigned.\n  if (asyncFlags[kHasListener] > 0)\n    runAsyncQueue(item);\n};\n\n\n\n\n\n\n\nexports.setTimeout = function(callback, after) {\n  var timer;\n\n  after *= 1; // coalesce to number or NaN\n\n  if (!(after >= 1 && after <= TIMEOUT_MAX)) {\n    after = 1; // schedule on next tick, follows browser behaviour\n  }\n\n  timer = new Timeout(after);\n\n  if (arguments.length <= 2) {\n    timer._onTimeout = callback;\n  } else {\n\n\n\n\n\n\n\n\n\n    var args = Array.prototype.slice.call(arguments, 2);\n    timer._onTimeout = function() {\n      callback.apply(timer, args);\n    }\n  }\n\n  if (process.domain) timer.domain = process.domain;\n\n  exports.active(timer);\n\n  return timer;\n};\n\n\nexports.clearTimeout = function(timer) {\n  if (timer && (timer[kOnTimeout] || timer._onTimeout)) {\n    timer[kOnTimeout] = timer._onTimeout = null;\n    if (timer instanceof Timeout) {\n      timer.close(); // for after === 0\n    } else {\n      exports.unenroll(timer);\n    }\n  }\n};\n\n\nexports.setInterval = function(callback, repeat) {\n  repeat *= 1; // coalesce to number or NaN\n\n  if (!(repeat >= 1 && repeat <= TIMEOUT_MAX)) {\n    repeat = 1; // schedule on next tick, follows browser behaviour\n  }\n\n  var timer = new Timeout(repeat);\n  var args = Array.prototype.slice.call(arguments, 2);\n  timer._onTimeout = wrapper;\n  timer._repeat = true;\n\n  if (process.domain) timer.domain = process.domain;\n  exports.active(timer);\n\n  return timer;\n\n  function wrapper() {\n    callback.apply(this, args);\n    // If callback called clearInterval().\n    if (timer._repeat === false) return;\n    // If timer is unref'd (or was - it's permanently removed from the list.)\n    if (this._handle) {\n      this._handle.start(repeat, 0);\n    } else {\n      timer._idleTimeout = repeat;\n      exports.active(timer);\n    }\n  }\n};\n\n\nexports.clearInterval = function(timer) {\n  if (timer && timer._repeat) {\n    timer._repeat = false;\n    clearTimeout(timer);\n  }\n};\n\n\nvar Timeout = function(after) {\n  this._idleTimeout = after;\n  this._idlePrev = this;\n  this._idleNext = this;\n  this._idleStart = null;\n  this._onTimeout = null;\n  this._repeat = false;\n};\n\nTimeout.prototype.unref = function() {\n  if (!this._handle) {\n    var now = Timer.now();\n    if (!this._idleStart) this._idleStart = now;\n    var delay = this._idleStart + this._idleTimeout - now;\n    if (delay < 0) delay = 0;\n    exports.unenroll(this);\n    this._handle = new Timer();\n    this._handle[kOnTimeout] = this._onTimeout;\n    this._handle.start(delay, 0);\n    this._handle.domain = this.domain;\n    this._handle.unref();\n  } else {\n    this._handle.unref();\n  }\n};\n\nTimeout.prototype.ref = function() {\n  if (this._handle)\n    this._handle.ref();\n};\n\nTimeout.prototype.close = function() {\n  this._onTimeout = null;\n  if (this._handle) {\n    this._handle[kOnTimeout] = null;\n    this._handle.close();\n  } else {\n    exports.unenroll(this);\n  }\n};\n\n\nvar immediateQueue = {};\nL.init(immediateQueue);\n\n\nfunction processImmediate() {\n  var queue = immediateQueue;\n  var domain, hasQueue, immediate;\n\n  immediateQueue = {};\n  L.init(immediateQueue);\n\n  while (L.isEmpty(queue) === false) {\n    immediate = L.shift(queue);\n    hasQueue = !!immediate._asyncQueue;\n    domain = immediate.domain;\n\n    if (hasQueue)\n      loadAsyncQueue(immediate);\n    if (domain)\n      domain.enter();\n\n    var threw = true;\n    try {\n      immediate._onImmediate();\n      threw = false;\n    } finally {\n      if (threw) {\n        if (!L.isEmpty(queue)) {\n          // Handle any remaining on next tick, assuming we're still\n          // alive to do so.\n          while (!L.isEmpty(immediateQueue)) {\n            L.append(queue, L.shift(immediateQueue));\n          }\n          immediateQueue = queue;\n          process.nextTick(processImmediate);\n        }\n      }\n    }\n\n    if (domain)\n      domain.exit();\n    if (hasQueue)\n      unloadAsyncQueue(immediate);\n  }\n\n  // Only round-trip to C++ land if we have to. Calling clearImmediate() on an\n  // immediate that's in |queue| is okay. Worst case is we make a superfluous\n  // call to NeedImmediateCallbackSetter().\n  if (L.isEmpty(immediateQueue)) {\n    process._needImmediateCallback = false;\n  }\n}\n\n\nfunction Immediate() { }\n\nImmediate.prototype.domain = undefined;\nImmediate.prototype._onImmediate = undefined;\nImmediate.prototype._asyncQueue = undefined;\nImmediate.prototype._asyncData = undefined;\nImmediate.prototype._idleNext = undefined;\nImmediate.prototype._idlePrev = undefined;\nImmediate.prototype._asyncFlags = 0;\n\n\nexports.setImmediate = function(callback) {\n  var immediate = new Immediate();\n  var args, index;\n\n  L.init(immediate);\n\n  immediate._onImmediate = callback;\n\n  if (arguments.length > 1) {\n    args = [];\n    for (index = 1; index < arguments.length; index++)\n      args.push(arguments[index]);\n\n    immediate._onImmediate = function() {\n      callback.apply(immediate, args);\n    };\n  }\n\n  if (!process._needImmediateCallback) {\n    process._needImmediateCallback = true;\n    process._immediateCallback = processImmediate;\n  }\n\n  // setImmediates are handled more like nextTicks.\n  if (asyncFlags[kHasListener] > 0)\n    runAsyncQueue(immediate);\n  if (process.domain)\n    immediate.domain = process.domain;\n\n  L.append(immediateQueue, immediate);\n\n  return immediate;\n};\n\n\nexports.clearImmediate = function(immediate) {\n  if (!immediate) return;\n\n  immediate._onImmediate = undefined;\n\n  L.remove(immediate);\n\n  if (L.isEmpty(immediateQueue)) {\n    process._needImmediateCallback = false;\n  }\n};\n\n\n// Internal APIs that need timeouts should use timers._unrefActive instead of\n// timers.active as internal timeouts shouldn't hold the loop open\n\nvar unrefList, unrefTimer;\n\n\nfunction unrefTimeout() {\n  var now = Timer.now();\n\n  debug('unrefTimer fired');\n\n  var diff, domain, first, hasQueue, threw;\n  while (first = L.peek(unrefList)) {\n    diff = now - first._idleStart;\n\n    if (diff < first._idleTimeout) {\n      diff = first._idleTimeout - diff;\n      unrefTimer.start(diff, 0);\n      unrefTimer.when = now + diff;\n      debug('unrefTimer rescheudling for later');\n      return;\n    }\n\n    L.remove(first);\n\n    domain = first.domain;\n\n    if (!first._onTimeout) continue;\n    if (domain && domain._disposed) continue;\n    hasQueue = !!first._asyncQueue;\n\n    try {\n      if (hasQueue)\n        loadAsyncQueue(first);\n      if (domain) domain.enter();\n      threw = true;\n      debug('unreftimer firing timeout');\n      first._onTimeout();\n      threw = false;\n      if (domain)\n        domain.exit();\n      if (hasQueue)\n        unloadAsyncQueue(first);\n    } finally {\n      if (threw) process.nextTick(unrefTimeout);\n    }\n  }\n\n  debug('unrefList is empty');\n  unrefTimer.when = -1;\n}\n\n\nexports._unrefActive = function(item) {\n  var msecs = item._idleTimeout;\n  if (!msecs || msecs < 0) return;\n  assert(msecs >= 0);\n\n  L.remove(item);\n\n  if (!unrefList) {\n    debug('unrefList initialized');\n    unrefList = {};\n    L.init(unrefList);\n\n    debug('unrefTimer initialized');\n    unrefTimer = new Timer();\n    unrefTimer.unref();\n    unrefTimer.when = -1;\n    unrefTimer[kOnTimeout] = unrefTimeout;\n  }\n\n  var now = Timer.now();\n  item._idleStart = now;\n\n  if (L.isEmpty(unrefList)) {\n    debug('unrefList empty');\n    L.append(unrefList, item);\n\n    unrefTimer.start(msecs, 0);\n    unrefTimer.when = now + msecs;\n    debug('unrefTimer scheduled');\n    return;\n  }\n\n  var when = now + msecs;\n\n  debug('unrefList find where we can insert');\n\n  var cur, them;\n\n  for (cur = unrefList._idlePrev; cur != unrefList; cur = cur._idlePrev) {\n    them = cur._idleStart + cur._idleTimeout;\n\n    if (when < them) {\n      debug('unrefList inserting into middle of list');\n\n      L.append(cur, item);\n\n      if (unrefTimer.when > when) {\n        debug('unrefTimer is scheduled to fire too late, reschedule');\n        unrefTimer.start(msecs, 0);\n        unrefTimer.when = when;\n      }\n\n      return;\n    }\n  }\n\n  debug('unrefList append to end');\n  L.append(unrefList, item);\n};\n",
  @"// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar net = require('net');\nvar url = require('url');\nvar util = require('util');\n\n// Allow {CLIENT_RENEG_LIMIT} client-initiated session renegotiations\n// every {CLIENT_RENEG_WINDOW} seconds. An error event is emitted if more\n// renegotations are seen. The settings are applied to all remote client\n// connections.\nexports.CLIENT_RENEG_LIMIT = 3;\nexports.CLIENT_RENEG_WINDOW = 600;\n\nexports.SLAB_BUFFER_SIZE = 10 * 1024 * 1024;\n\nexports.DEFAULT_CIPHERS =\n    'ECDHE-RSA-AES128-SHA256:AES128-GCM-SHA256:' + // TLS 1.2\n    'RC4:HIGH:!MD5:!aNULL:!EDH';                   // TLS 1.0\n\nexports.DEFAULT_ECDH_CURVE = 'prime256v1';\n\nexports.getCiphers = function() {\n  var names = process.binding('crypto').getSSLCiphers();\n  // Drop all-caps names in favor of their lowercase aliases,\n  var ctx = {};\n  names.forEach(function(name) {\n    if (/^[0-9A-Z\\-]+$/.test(name)) name = name.toLowerCase();\n    ctx[name] = true;\n  });\n  return Object.getOwnPropertyNames(ctx).sort();\n};\n\n// Convert protocols array into valid OpenSSL protocols list\n// (\"\\x06spdy/2\\x08http/1.1\\x08http/1.0\")\nexports.convertNPNProtocols = function convertNPNProtocols(NPNProtocols, out) {\n  // If NPNProtocols is Array - translate it into buffer\n  if (util.isArray(NPNProtocols)) {\n    var buff = new Buffer(NPNProtocols.reduce(function(p, c) {\n      return p + 1 + Buffer.byteLength(c);\n    }, 0));\n\n    NPNProtocols.reduce(function(offset, c) {\n      var clen = Buffer.byteLength(c);\n      buff[offset] = clen;\n      buff.write(c, offset + 1);\n\n      return offset + 1 + clen;\n    }, 0);\n\n    NPNProtocols = buff;\n  }\n\n  // If it's already a Buffer - store it\n  if (util.isBuffer(NPNProtocols)) {\n    out.NPNProtocols = NPNProtocols;\n  }\n};\n\nexports.checkServerIdentity = function checkServerIdentity(host, cert) {\n  // Create regexp to much hostnames\n  function regexpify(host, wildcards) {\n    // Add trailing dot (make hostnames uniform)\n    if (!/\\.$/.test(host)) host += '.';\n\n    // The same applies to hostname with more than one wildcard,\n    // if hostname has wildcard when wildcards are not allowed,\n    // or if there are less than two dots after wildcard (i.e. *.com or *d.com)\n    //\n    // also\n    //\n    // \"The client SHOULD NOT attempt to match a presented identifier in\n    // which the wildcard character comprises a label other than the\n    // left-most label (e.g., do not match bar.*.example.net).\"\n    // RFC6125\n    if (!wildcards && /\\*/.test(host) || /[\\.\\*].*\\*/.test(host) ||\n        /\\*/.test(host) && !/\\*.*\\..+\\..+/.test(host)) {\n      return /$./;\n    }\n\n    // Replace wildcard chars with regexp's wildcard and\n    // escape all characters that have special meaning in regexps\n    // (i.e. '.', '[', '{', '*', and others)\n    var re = host.replace(\n        /\\*([a-z0-9\\\\-_\\.])|[\\.,\\-\\\\\\^\\$+?*\\[\\]\\(\\):!\\|{}]/g,\n        function(all, sub) {\n          if (sub) return '[a-z0-9\\\\-_]*' + (sub === '-' ? '\\\\-' : sub);\n          return '\\\\' + all;\n        });\n\n    return new RegExp('^' + re + '$', 'i');\n  }\n\n  var dnsNames = [],\n      uriNames = [],\n      ips = [],\n      matchCN = true,\n      valid = false,\n      reason = 'Unknown reason';\n\n  // There're several names to perform check against:\n  // CN and altnames in certificate extension\n  // (DNS names, IP addresses, and URIs)\n  //\n  // Walk through altnames and generate lists of those names\n  if (cert.subjectaltname) {\n    cert.subjectaltname.split(/, /g).forEach(function(altname) {\n      var option = altname.match(/^(DNS|IP Address|URI):(.*)$/);\n      if (!option)\n        return;\n      if (option[1] === 'DNS') {\n        dnsNames.push(option[2]);\n      } else if (option[1] === 'IP Address') {\n        ips.push(option[2]);\n      } else if (option[1] === 'URI') {\n        var uri = url.parse(option[2]);\n        if (uri) uriNames.push(uri.hostname);\n      }\n    });\n  }\n\n  // If hostname is an IP address, it should be present in the list of IP\n  // addresses.\n  if (net.isIP(host)) {\n    valid = ips.some(function(ip) {\n      return ip === host;\n    });\n    if (!valid) {\n      reason = util.format('IP: %s is not in the cert\\'s list: %s',\n                           host,\n                           ips.join(', '));\n    }\n  } else {\n    // Transform hostname to canonical form\n    if (!/\\.$/.test(host)) host += '.';\n\n    // Otherwise check all DNS/URI records from certificate\n    // (with allowed wildcards)\n    dnsNames = dnsNames.map(function(name) {\n      return regexpify(name, true);\n    });\n\n    // Wildcards ain't allowed in URI names\n    uriNames = uriNames.map(function(name) {\n      return regexpify(name, false);\n    });\n\n    dnsNames = dnsNames.concat(uriNames);\n\n    if (dnsNames.length > 0) matchCN = false;\n\n    // Match against Common Name (CN) only if no supported identifiers are\n    // present.\n    //\n    // \"As noted, a client MUST NOT seek a match for a reference identifier\n    //  of CN-ID if the presented identifiers include a DNS-ID, SRV-ID,\n    //  URI-ID, or any application-specific identifier types supported by the\n    //  client.\"\n    // RFC6125\n    if (matchCN) {\n      var commonNames = cert.subject.CN;\n      if (util.isArray(commonNames)) {\n        for (var i = 0, k = commonNames.length; i < k; ++i) {\n          dnsNames.push(regexpify(commonNames[i], true));\n        }\n      } else {\n        dnsNames.push(regexpify(commonNames, true));\n      }\n    }\n\n    valid = dnsNames.some(function(re) {\n      return re.test(host);\n    });\n\n    if (!valid) {\n      if (cert.subjectaltname) {\n        reason = util.format('Host: %s is not in the cert\\'s altnames: %s',\n                             host,\n                             cert.subjectaltname);\n      } else {\n        reason = util.format('Host: %s is not cert\\'s CN: %s',\n                             host,\n                             cert.subject.CN);\n      }\n    }\n  }\n\n  if (!valid) {\n    var err = new Error(\n        util.format('Hostname/IP doesn\\'t match certificate\\'s altnames: %j',\n                    reason));\n    err.reason = reason;\n    err.host = host;\n    err.cert = cert;\n    return err;\n  }\n};\n\n// Example:\n// C=US\\nST=CA\\nL=SF\\nO=Joyent\\nOU=Node.js\\nCN=ca1\\nemailAddress=ry@clouds.org\nexports.parseCertString = function parseCertString(s) {\n  var out = {};\n  var parts = s.split('\\n');\n  for (var i = 0, len = parts.length; i < len; i++) {\n    var sepIndex = parts[i].indexOf('=');\n    if (sepIndex > 0) {\n      var key = parts[i].slice(0, sepIndex);\n      var value = parts[i].slice(sepIndex + 1);\n      if (key in out) {\n        if (!util.isArray(out[key])) {\n          out[key] = [out[key]];\n        }\n        out[key].push(value);\n      } else {\n        out[key] = value;\n      }\n    }\n  }\n  return out;\n};\n\n// Public API\nexports.createSecureContext = require('_tls_common').createSecureContext;\nexports.SecureContext = require('_tls_common').SecureContext;\nexports.TLSSocket = require('_tls_wrap').TLSSocket;\nexports.Server = require('_tls_wrap').Server;\nexports.createServer = require('_tls_wrap').createServer;\nexports.connect = require('_tls_wrap').connect;\n\n// Legacy API\nexports.__defineGetter__('createSecurePair', util.deprecate(function() {\n  return require('_tls_legacy').createSecurePair;\n}, 'createSecurePair() is deprecated, use TLSSocket instead'));\n",
  @"// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar EventEmitter = require('events');\nvar v8binding, process;\n\n// This needs to be loaded early, and before the \"process\" object is made\n// global. So allow src/node.js to pass the process object in during\n// initialization.\nexports._nodeInitialization = function nodeInitialization(pobj) {\n  process = pobj;\n  v8binding = process.binding('v8');\n\n  // Finish setting up the v8 Object.\n  v8.getHeapStatistics = v8binding.getHeapStatistics;\n\n  // Part of the AsyncListener setup to share objects/callbacks with the\n  // native layer.\n  process._setupAsyncListener(asyncFlags,\n                              runAsyncQueue,\n                              loadAsyncQueue,\n                              unloadAsyncQueue);\n\n  // Do a little housekeeping.\n  delete exports._nodeInitialization;\n};\n\n\n// v8\n\nvar v8 = exports.v8 = new EventEmitter();\n\n\nfunction emitGC(before, after) {\n  v8.emit('gc', before, after);\n}\n\n\nv8.on('newListener', function(name) {\n  if (name === 'gc' && EventEmitter.listenerCount(this, name) === 0) {\n    v8binding.startGarbageCollectionTracking(emitGC);\n  }\n});\n\n\nv8.on('removeListener', function(name) {\n  if (name === 'gc' && EventEmitter.listenerCount(this, name) === 0) {\n    v8binding.stopGarbageCollectionTracking();\n  }\n});\n\n\n// AsyncListener\n\n// new Array() is used here because it is more efficient for sparse\n// arrays. Please *do not* change these to simple bracket notation.\n\n// Track the active queue of AsyncListeners that have been added.\nvar asyncQueue = new Array();\n\n// Keep the stack of all contexts that have been loaded in the\n// execution chain of asynchronous events.\nvar contextStack = new Array();\nvar currentContext = undefined;\n\n// Incremental uid for new AsyncListener instances.\nvar alUid = 0;\n\n// Stateful flags shared with Environment for quick JS/C++\n// communication.\nvar asyncFlags = {};\n\n// Prevent accidentally suppressed thrown errors from before/after.\nvar inAsyncTick = false;\n\n// To prevent infinite recursion when an error handler also throws\n// flag when an error is currenly being handled.\nvar inErrorTick = false;\n\n// Needs to be the same as src/env.h\nvar kHasListener = 0;\n\n// Flags to determine what async listeners are available.\nvar HAS_CREATE_AL = 1 << 0;\nvar HAS_BEFORE_AL = 1 << 1;\nvar HAS_AFTER_AL = 1 << 2;\nvar HAS_ERROR_AL = 1 << 3;\n\n// _errorHandler is scoped so it's also accessible by _fatalException.\nexports._errorHandler = errorHandler;\n\n// Needs to be accessible from lib/timers.js so they know when async\n// listeners are currently in queue. They'll be cleaned up once\n// references there are made.\nexports._asyncFlags = asyncFlags;\nexports._runAsyncQueue = runAsyncQueue;\nexports._loadAsyncQueue = loadAsyncQueue;\nexports._unloadAsyncQueue = unloadAsyncQueue;\n\n// Public API.\nexports.createAsyncListener = createAsyncListener;\nexports.addAsyncListener = addAsyncListener;\nexports.removeAsyncListener = removeAsyncListener;\n\n// Load the currently executing context as the current context, and\n// create a new asyncQueue that can receive any added queue items\n// during the executing of the callback.\nfunction loadContext(ctx) {\n  contextStack.push(currentContext);\n  currentContext = ctx;\n\n  asyncFlags[kHasListener] = 1;\n}\n\nfunction unloadContext() {\n  currentContext = contextStack.pop();\n\n  if (currentContext === undefined && asyncQueue.length === 0)\n    asyncFlags[kHasListener] = 0;\n}\n\n// Run all the async listeners attached when an asynchronous event is\n// instantiated.\nfunction runAsyncQueue(context) {\n  var queue = new Array();\n  var data = new Array();\n  var ccQueue, i, queueItem, value;\n\n  context._asyncQueue = queue;\n  context._asyncData = data;\n  context._asyncFlags = 0;\n\n  inAsyncTick = true;\n\n  // First run through all callbacks in the currentContext. These may\n  // add new AsyncListeners to the asyncQueue during execution. Hence\n  // why they need to be evaluated first.\n  if (currentContext) {\n    ccQueue = currentContext._asyncQueue;\n    context._asyncFlags |= currentContext._asyncFlags;\n    for (i = 0; i < ccQueue.length; i++) {\n      queueItem = ccQueue[i];\n      queue[queue.length] = queueItem;\n      if ((queueItem.callback_flags & HAS_CREATE_AL) === 0) {\n        data[queueItem.uid] = queueItem.data;\n        continue;\n      }\n      value = queueItem.create(queueItem.data);\n      data[queueItem.uid] = (value === undefined) ? queueItem.data : value;\n    }\n  }\n\n  // Then run through all items in the asyncQueue\n  if (asyncQueue) {\n    for (i = 0; i < asyncQueue.length; i++) {\n      queueItem = asyncQueue[i];\n      // Quick way to check if an AL instance with the same uid was\n      // already run from currentContext.\n      if (data[queueItem.uid] !== undefined)\n        continue;\n      queue[queue.length] = queueItem;\n      context._asyncFlags |= queueItem.callback_flags;\n      if ((queueItem.callback_flags & HAS_CREATE_AL) === 0) {\n        data[queueItem.uid] = queueItem.data;\n        continue;\n      }\n      value = queueItem.create(queueItem.data);\n      data[queueItem.uid] = (value === undefined) ? queueItem.data : value;\n    }\n  }\n\n  inAsyncTick = false;\n}\n\n// Load the AsyncListener queue attached to context and run all\n// \"before\" callbacks, if they exist.\nfunction loadAsyncQueue(context) {\n  loadContext(context);\n\n  if ((context._asyncFlags & HAS_BEFORE_AL) === 0)\n    return;\n\n  var queue = context._asyncQueue;\n  var data = context._asyncData;\n  var i, queueItem;\n\n  inAsyncTick = true;\n  for (i = 0; i < queue.length; i++) {\n    queueItem = queue[i];\n    if ((queueItem.callback_flags & HAS_BEFORE_AL) > 0)\n      queueItem.before(context, data[queueItem.uid]);\n  }\n  inAsyncTick = false;\n}\n\n// Unload the AsyncListener queue attached to context and run all\n// \"after\" callbacks, if they exist.\nfunction unloadAsyncQueue(context) {\n  if ((context._asyncFlags & HAS_AFTER_AL) === 0) {\n    unloadContext();\n    return;\n  }\n\n  var queue = context._asyncQueue;\n  var data = context._asyncData;\n  var i, queueItem;\n\n  inAsyncTick = true;\n  for (i = 0; i < queue.length; i++) {\n    queueItem = queue[i];\n    if ((queueItem.callback_flags & HAS_AFTER_AL) > 0)\n      queueItem.after(context, data[queueItem.uid]);\n  }\n  inAsyncTick = false;\n\n  unloadContext();\n}\n\n// Handle errors that are thrown while in the context of an\n// AsyncListener. If an error is thrown from an AsyncListener\n// callback error handlers will be called once more to report\n// the error, then the application will die forcefully.\nfunction errorHandler(er) {\n  if (inErrorTick)\n    return false;\n\n  var handled = false;\n  var i, queueItem, threw;\n\n  inErrorTick = true;\n\n  // First process error callbacks from the current context.\n  if (currentContext && (currentContext._asyncFlags & HAS_ERROR_AL) > 0) {\n    var queue = currentContext._asyncQueue;\n    var data = currentContext._asyncData;\n    for (i = 0; i < queue.length; i++) {\n      queueItem = queue[i];\n      if ((queueItem.callback_flags & HAS_ERROR_AL) === 0)\n        continue;\n      try {\n        threw = true;\n        // While it would be possible to pass in currentContext, if\n        // the error is thrown from the \"create\" callback then there's\n        // a chance the object hasn't been fully constructed.\n        handled = queueItem.error(data[queueItem.uid], er) || handled;\n        threw = false;\n      } finally {\n        // If the error callback thew then die quickly. Only allow the\n        // exit events to be processed.\n        if (threw) {\n          process._exiting = true;\n          process.emit('exit', 1);\n        }\n      }\n    }\n  }\n\n  // Now process callbacks from any existing queue.\n  if (asyncQueue) {\n    for (i = 0; i < asyncQueue.length; i++) {\n      queueItem = asyncQueue[i];\n      if ((queueItem.callback_flags & HAS_ERROR_AL) === 0 ||\n          (data && data[queueItem.uid] !== undefined))\n        continue;\n      try {\n        threw = true;\n        handled = queueItem.error(queueItem.data, er) || handled;\n        threw = false;\n      } finally {\n        // If the error callback thew then die quickly. Only allow the\n        // exit events to be processed.\n        if (threw) {\n          process._exiting = true;\n          process.emit('exit', 1);\n        }\n      }\n    }\n  }\n\n  inErrorTick = false;\n\n  unloadContext();\n\n  // TODO(trevnorris): If the error was handled, should the after callbacks\n  // be fired anyways?\n\n  return handled && !inAsyncTick;\n}\n\n// Instance function of an AsyncListener object.\nfunction AsyncListenerInst(callbacks, data) {\n  if (typeof callbacks.create === 'function') {\n    this.create = callbacks.create;\n    this.callback_flags |= HAS_CREATE_AL;\n  }\n  if (typeof callbacks.before === 'function') {\n    this.before = callbacks.before;\n    this.callback_flags |= HAS_BEFORE_AL;\n  }\n  if (typeof callbacks.after === 'function') {\n    this.after = callbacks.after;\n    this.callback_flags |= HAS_AFTER_AL;\n  }\n  if (typeof callbacks.error === 'function') {\n    this.error = callbacks.error;\n    this.callback_flags |= HAS_ERROR_AL;\n  }\n\n  this.uid = ++alUid;\n  this.data = data === undefined ? null : data;\n}\nAsyncListenerInst.prototype.create = undefined;\nAsyncListenerInst.prototype.before = undefined;\nAsyncListenerInst.prototype.after = undefined;\nAsyncListenerInst.prototype.error = undefined;\nAsyncListenerInst.prototype.data = undefined;\nAsyncListenerInst.prototype.uid = 0;\nAsyncListenerInst.prototype.callback_flags = 0;\n\n// Create new async listener object. Useful when instantiating a new\n// object and want the listener instance, but not add it to the stack.\n// If an existing AsyncListenerInst is passed then any new \"data\" is\n// ignored.\nfunction createAsyncListener(callbacks, data) {\n  if (typeof callbacks !== 'object' || callbacks == null)\n    throw new TypeError('callbacks argument must be an object');\n\n  if (callbacks instanceof AsyncListenerInst)\n    return callbacks;\n  else\n    return new AsyncListenerInst(callbacks, data);\n}\n\n// Add a listener to the current queue.\nfunction addAsyncListener(callbacks, data) {\n  // Fast track if a new AsyncListenerInst has to be created.\n  if (!(callbacks instanceof AsyncListenerInst)) {\n    callbacks = createAsyncListener(callbacks, data);\n    asyncQueue.push(callbacks);\n    asyncFlags[kHasListener] = 1;\n    return callbacks;\n  }\n\n  var inQueue = false;\n  // The asyncQueue will be small. Probably always <= 3 items.\n  for (var i = 0; i < asyncQueue.length; i++) {\n    if (callbacks === asyncQueue[i]) {\n      inQueue = true;\n      break;\n    }\n  }\n\n  // Make sure the callback doesn't already exist in the queue.\n  if (!inQueue) {\n    asyncQueue.push(callbacks);\n    asyncFlags[kHasListener] = 1;\n  }\n\n  return callbacks;\n}\n\n// Remove listener from the current queue. Though this will not remove\n// the listener from the current context. So callback propagation will\n// continue.\nfunction removeAsyncListener(obj) {\n  for (var i = 0; i < asyncQueue.length; i++) {\n    if (obj === asyncQueue[i]) {\n      asyncQueue.splice(i, 1);\n      break;\n    }\n  }\n\n  if (asyncQueue.length > 0 || currentContext !== undefined)\n    asyncFlags[kHasListener] = 1;\n  else\n    asyncFlags[kHasListener] = 0;\n}\n",
  @"// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar inherits = require('util').inherits;\nvar net = require('net');\nvar TTY = process.binding('tty_wrap').TTY;\nvar isTTY = process.binding('tty_wrap').isTTY;\nvar util = require('util');\n\nvar errnoException = util._errnoException;\n\n\nexports.isatty = function(fd) {\n  return isTTY(fd);\n};\n\n\n// backwards-compat\nexports.setRawMode = util.deprecate(function(flag) {\n  if (!process.stdin.isTTY) {\n    throw new Error('can\\'t set raw mode on non-tty');\n  }\n  process.stdin.setRawMode(flag);\n}, 'tty.setRawMode: Use `process.stdin.setRawMode()` instead.');\n\n\nfunction ReadStream(fd, options) {\n  if (!(this instanceof ReadStream))\n    return new ReadStream(fd, options);\n\n  options = util._extend({\n    highWaterMark: 0,\n    readable: true,\n    writable: false,\n    handle: new TTY(fd, true)\n  }, options);\n\n  net.Socket.call(this, options);\n\n  this.isRaw = false;\n  this.isTTY = true;\n}\ninherits(ReadStream, net.Socket);\n\nexports.ReadStream = ReadStream;\n\nReadStream.prototype.setRawMode = function(flag) {\n  flag = !!flag;\n  this._handle.setRawMode(flag);\n  this.isRaw = flag;\n};\n\n\n\nfunction WriteStream(fd) {\n  if (!(this instanceof WriteStream)) return new WriteStream(fd);\n  net.Socket.call(this, {\n    handle: new TTY(fd, false),\n    readable: false,\n    writable: true\n  });\n\n  var winSize = [];\n  var err = this._handle.getWindowSize(winSize);\n  if (!err) {\n    this.columns = winSize[0];\n    this.rows = winSize[1];\n  }\n}\ninherits(WriteStream, net.Socket);\nexports.WriteStream = WriteStream;\n\n\nWriteStream.prototype.isTTY = true;\n\n\nWriteStream.prototype._refreshSize = function() {\n  var oldCols = this.columns;\n  var oldRows = this.rows;\n  var winSize = [];\n  var err = this._handle.getWindowSize(winSize);\n  if (err) {\n    this.emit('error', errnoException(err, 'getWindowSize'));\n    return;\n  }\n  var newCols = winSize[0];\n  var newRows = winSize[1];\n  if (oldCols !== newCols || oldRows !== newRows) {\n    this.columns = newCols;\n    this.rows = newRows;\n    this.emit('resize');\n  }\n};\n\n\n// backwards-compat\nWriteStream.prototype.cursorTo = function(x, y) {\n  require('readline').cursorTo(this, x, y);\n};\nWriteStream.prototype.moveCursor = function(dx, dy) {\n  require('readline').moveCursor(this, dx, dy);\n};\nWriteStream.prototype.clearLine = function(dir) {\n  require('readline').clearLine(this, dir);\n};\nWriteStream.prototype.clearScreenDown = function() {\n  require('readline').clearScreenDown(this);\n};\nWriteStream.prototype.getWindowSize = function() {\n  return [this.columns, this.rows];\n};\n",
  @"// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar punycode = require('punycode');\nvar util = require('util');\n\nexports.parse = urlParse;\nexports.resolve = urlResolve;\nexports.resolveObject = urlResolveObject;\nexports.format = urlFormat;\n\nexports.Url = Url;\n\nfunction Url() {\n  this.protocol = null;\n  this.slashes = null;\n  this.auth = null;\n  this.host = null;\n  this.port = null;\n  this.hostname = null;\n  this.hash = null;\n  this.search = null;\n  this.query = null;\n  this.pathname = null;\n  this.path = null;\n  this.href = null;\n}\n\n// Reference: RFC 3986, RFC 1808, RFC 2396\n\n// define these here so at least they only have to be\n// compiled once on the first module load.\nvar protocolPattern = /^([a-z0-9.+-]+:)/i,\n    portPattern = /:[0-9]*$/,\n\n    // RFC 2396: characters reserved for delimiting URLs.\n    // We actually just auto-escape these.\n    delims = ['<', '>', '\"', '`', ' ', '\\r', '\\n', '\\t'],\n\n    // RFC 2396: characters not allowed for various reasons.\n    unwise = ['{', '}', '|', '\\\\', '^', '`'].concat(delims),\n\n    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.\n    autoEscape = ['\\''].concat(unwise),\n    // Characters that are never ever allowed in a hostname.\n    // Note that any invalid chars are also handled, but these\n    // are the ones that are *expected* to be seen, so we fast-path\n    // them.\n    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),\n    hostEndingChars = ['/', '?', '#'],\n    hostnameMaxLen = 255,\n    hostnamePartPattern = /^[a-z0-9A-Z_-]{0,63}$/,\n    hostnamePartStart = /^([a-z0-9A-Z_-]{0,63})(.*)$/,\n    // protocols that can allow \"unsafe\" and \"unwise\" chars.\n    unsafeProtocol = {\n      'javascript': true,\n      'javascript:': true\n    },\n    // protocols that never have a hostname.\n    hostlessProtocol = {\n      'javascript': true,\n      'javascript:': true\n    },\n    // protocols that always contain a // bit.\n    slashedProtocol = {\n      'http': true,\n      'https': true,\n      'ftp': true,\n      'gopher': true,\n      'file': true,\n      'http:': true,\n      'https:': true,\n      'ftp:': true,\n      'gopher:': true,\n      'file:': true\n    },\n    querystring = require('querystring');\n\nfunction urlParse(url, parseQueryString, slashesDenoteHost) {\n  if (url && util.isObject(url) && url instanceof Url) return url;\n\n  var u = new Url;\n  u.parse(url, parseQueryString, slashesDenoteHost);\n  return u;\n}\n\nUrl.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {\n  if (!util.isString(url)) {\n    throw new TypeError(\"Parameter 'url' must be a string, not \" + typeof url);\n  }\n\n  // Copy chrome, IE, opera backslash-handling behavior.\n  // See: https://code.google.com/p/chromium/issues/detail?id=25916\n  var hashSplit = url.split('#');\n  hashSplit[0] = hashSplit[0].replace(/\\\\/g, '/');\n  url = hashSplit.join('#');\n\n  var rest = url;\n\n  // trim before proceeding.\n  // This is to support parse stuff like \"  http://foo.com  \\n\"\n  rest = rest.trim();\n\n  var proto = protocolPattern.exec(rest);\n  if (proto) {\n    proto = proto[0];\n    var lowerProto = proto.toLowerCase();\n    this.protocol = lowerProto;\n    rest = rest.substr(proto.length);\n  }\n\n  // figure out if it's got a host\n  // user@server is *always* interpreted as a hostname, and url\n  // resolution will treat //foo/bar as host=foo,path=bar because that's\n  // how the browser resolves relative URLs.\n  if (slashesDenoteHost || proto || rest.match(/^\\/\\/[^@\\/]+@[^@\\/]+/)) {\n    var slashes = rest.substr(0, 2) === '//';\n    if (slashes && !(proto && hostlessProtocol[proto])) {\n      rest = rest.substr(2);\n      this.slashes = true;\n    }\n  }\n\n  if (!hostlessProtocol[proto] &&\n      (slashes || (proto && !slashedProtocol[proto]))) {\n\n    // there's a hostname.\n    // the first instance of /, ?, ;, or # ends the host.\n    //\n    // If there is an @ in the hostname, then non-host chars *are* allowed\n    // to the left of the last @ sign, unless some host-ending character\n    // comes *before* the @-sign.\n    // URLs are obnoxious.\n    //\n    // ex:\n    // http://a@b@c/ => user:a@b host:c\n    // http://a@b?@c => user:a host:c path:/?@c\n\n    // v0.12 TODO(isaacs): This is not quite how Chrome does things.\n    // Review our test case against browsers more comprehensively.\n\n    // find the first instance of any hostEndingChars\n    var hostEnd = -1;\n    for (var i = 0; i < hostEndingChars.length; i++) {\n      var hec = rest.indexOf(hostEndingChars[i]);\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))\n        hostEnd = hec;\n    }\n\n    // at this point, either we have an explicit point where the\n    // auth portion cannot go past, or the last @ char is the decider.\n    var auth, atSign;\n    if (hostEnd === -1) {\n      // atSign can be anywhere.\n      atSign = rest.lastIndexOf('@');\n    } else {\n      // atSign must be in auth portion.\n      // http://a@b/c@d => host:b auth:a path:/c@d\n      atSign = rest.lastIndexOf('@', hostEnd);\n    }\n\n    // Now we have a portion which is definitely the auth.\n    // Pull that off.\n    if (atSign !== -1) {\n      auth = rest.slice(0, atSign);\n      rest = rest.slice(atSign + 1);\n      this.auth = decodeURIComponent(auth);\n    }\n\n    // the host is the remaining to the left of the first non-host char\n    hostEnd = -1;\n    for (var i = 0; i < nonHostChars.length; i++) {\n      var hec = rest.indexOf(nonHostChars[i]);\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))\n        hostEnd = hec;\n    }\n    // if we still have not hit it, then the entire thing is a host.\n    if (hostEnd === -1)\n      hostEnd = rest.length;\n\n    this.host = rest.slice(0, hostEnd);\n    rest = rest.slice(hostEnd);\n\n    // pull out port.\n    this.parseHost();\n\n    // we've indicated that there is a hostname,\n    // so even if it's empty, it has to be present.\n    this.hostname = this.hostname || '';\n\n    // if hostname begins with [ and ends with ]\n    // assume that it's an IPv6 address.\n    var ipv6Hostname = this.hostname[0] === '[' &&\n        this.hostname[this.hostname.length - 1] === ']';\n\n    // validate a little.\n    if (!ipv6Hostname) {\n      var hostparts = this.hostname.split(/\\./);\n      for (var i = 0, l = hostparts.length; i < l; i++) {\n        var part = hostparts[i];\n        if (!part) continue;\n        if (!part.match(hostnamePartPattern)) {\n          var newpart = '';\n          for (var j = 0, k = part.length; j < k; j++) {\n            if (part.charCodeAt(j) > 127) {\n              // we replace non-ASCII char with a temporary placeholder\n              // we need this to make sure size of hostname is not\n              // broken by replacing non-ASCII by nothing\n              newpart += 'x';\n            } else {\n              newpart += part[j];\n            }\n          }\n          // we test again with ASCII char only\n          if (!newpart.match(hostnamePartPattern)) {\n            var validParts = hostparts.slice(0, i);\n            var notHost = hostparts.slice(i + 1);\n            var bit = part.match(hostnamePartStart);\n            if (bit) {\n              validParts.push(bit[1]);\n              notHost.unshift(bit[2]);\n            }\n            if (notHost.length) {\n              rest = '/' + notHost.join('.') + rest;\n            }\n            this.hostname = validParts.join('.');\n            break;\n          }\n        }\n      }\n    }\n\n    if (this.hostname.length > hostnameMaxLen) {\n      this.hostname = '';\n    } else {\n      // hostnames are always lower case.\n      this.hostname = this.hostname.toLowerCase();\n    }\n\n    if (!ipv6Hostname) {\n      // IDNA Support: Returns a puny coded representation of \"domain\".\n      // It only converts the part of the domain name that\n      // has non ASCII characters. I.e. it dosent matter if\n      // you call it with a domain that already is in ASCII.\n      var domainArray = this.hostname.split('.');\n      var newOut = [];\n      for (var i = 0; i < domainArray.length; ++i) {\n        var s = domainArray[i];\n        newOut.push(s.match(/[^A-Za-z0-9_-]/) ?\n            'xn--' + punycode.encode(s) : s);\n      }\n      this.hostname = newOut.join('.');\n    }\n\n    var p = this.port ? ':' + this.port : '';\n    var h = this.hostname || '';\n    this.host = h + p;\n    this.href += this.host;\n\n    // strip [ and ] from the hostname\n    // the host field still retains them, though\n    if (ipv6Hostname) {\n      this.hostname = this.hostname.substr(1, this.hostname.length - 2);\n      if (rest[0] !== '/') {\n        rest = '/' + rest;\n      }\n    }\n  }\n\n  // now rest is set to the post-host stuff.\n  // chop off any delim chars.\n  if (!unsafeProtocol[lowerProto]) {\n\n    // First, make 100% sure that any \"autoEscape\" chars get\n    // escaped, even if encodeURIComponent doesn't think they\n    // need to be.\n    for (var i = 0, l = autoEscape.length; i < l; i++) {\n      var ae = autoEscape[i];\n      var esc = encodeURIComponent(ae);\n      if (esc === ae) {\n        esc = escape(ae);\n      }\n      rest = rest.split(ae).join(esc);\n    }\n  }\n\n\n  // chop off from the tail first.\n  var hash = rest.indexOf('#');\n  if (hash !== -1) {\n    // got a fragment string.\n    this.hash = rest.substr(hash);\n    rest = rest.slice(0, hash);\n  }\n  var qm = rest.indexOf('?');\n  if (qm !== -1) {\n    this.search = rest.substr(qm);\n    this.query = rest.substr(qm + 1);\n    if (parseQueryString) {\n      this.query = querystring.parse(this.query);\n    }\n    rest = rest.slice(0, qm);\n  } else if (parseQueryString) {\n    // no query string, but parseQueryString still requested\n    this.search = '';\n    this.query = {};\n  }\n  if (rest) this.pathname = rest;\n  if (slashedProtocol[lowerProto] &&\n      this.hostname && !this.pathname) {\n    this.pathname = '/';\n  }\n\n  //to support http.request\n  if (this.pathname || this.search) {\n    var p = this.pathname || '';\n    var s = this.search || '';\n    this.path = p + s;\n  }\n\n  // finally, reconstruct the href based on what has been validated.\n  this.href = this.format();\n  return this;\n};\n\n// format a parsed object into a url string\nfunction urlFormat(obj) {\n  // ensure it's an object, and not a string url.\n  // If it's an obj, this is a no-op.\n  // this way, you can call url_format() on strings\n  // to clean up potentially wonky urls.\n  if (util.isString(obj)) obj = urlParse(obj);\n  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);\n  return obj.format();\n}\n\nUrl.prototype.format = function() {\n  var auth = this.auth || '';\n  if (auth) {\n    auth = encodeURIComponent(auth);\n    auth = auth.replace(/%3A/i, ':');\n    auth += '@';\n  }\n\n  var protocol = this.protocol || '',\n      pathname = this.pathname || '',\n      hash = this.hash || '',\n      host = false,\n      query = '';\n\n  if (this.host) {\n    host = auth + this.host;\n  } else if (this.hostname) {\n    host = auth + (this.hostname.indexOf(':') === -1 ?\n        this.hostname :\n        '[' + this.hostname + ']');\n    if (this.port) {\n      host += ':' + this.port;\n    }\n  }\n\n  if (this.query &&\n      util.isObject(this.query) &&\n      Object.keys(this.query).length) {\n    query = querystring.stringify(this.query);\n  }\n\n  var search = this.search || (query && ('?' + query)) || '';\n\n  if (protocol && protocol.substr(-1) !== ':') protocol += ':';\n\n  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.\n  // unless they had them to begin with.\n  if (this.slashes ||\n      (!protocol || slashedProtocol[protocol]) && host !== false) {\n    host = '//' + (host || '');\n    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;\n  } else if (!host) {\n    host = '';\n  }\n\n  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;\n  if (search && search.charAt(0) !== '?') search = '?' + search;\n\n  pathname = pathname.replace(/[?#]/g, function(match) {\n    return encodeURIComponent(match);\n  });\n  search = search.replace('#', '%23');\n\n  return protocol + host + pathname + search + hash;\n};\n\nfunction urlResolve(source, relative) {\n  return urlParse(source, false, true).resolve(relative);\n}\n\nUrl.prototype.resolve = function(relative) {\n  return this.resolveObject(urlParse(relative, false, true)).format();\n};\n\nfunction urlResolveObject(source, relative) {\n  if (!source) return relative;\n  return urlParse(source, false, true).resolveObject(relative);\n}\n\nUrl.prototype.resolveObject = function(relative) {\n  if (util.isString(relative)) {\n    var rel = new Url();\n    rel.parse(relative, false, true);\n    relative = rel;\n  }\n\n  var result = new Url();\n  Object.keys(this).forEach(function(k) {\n    result[k] = this[k];\n  }, this);\n\n  // hash is always overridden, no matter what.\n  // even href=\"\" will remove it.\n  result.hash = relative.hash;\n\n  // if the relative url is empty, then there's nothing left to do here.\n  if (relative.href === '') {\n    result.href = result.format();\n    return result;\n  }\n\n  // hrefs like //foo/bar always cut to the protocol.\n  if (relative.slashes && !relative.protocol) {\n    // take everything except the protocol from relative\n    Object.keys(relative).forEach(function(k) {\n      if (k !== 'protocol')\n        result[k] = relative[k];\n    });\n\n    //urlParse appends trailing / to urls like http://www.example.com\n    if (slashedProtocol[result.protocol] &&\n        result.hostname && !result.pathname) {\n      result.path = result.pathname = '/';\n    }\n\n    result.href = result.format();\n    return result;\n  }\n\n  if (relative.protocol && relative.protocol !== result.protocol) {\n    // if it's a known url protocol, then changing\n    // the protocol does weird things\n    // first, if it's not file:, then we MUST have a host,\n    // and if there was a path\n    // to begin with, then we MUST have a path.\n    // if it is file:, then the host is dropped,\n    // because that's known to be hostless.\n    // anything else is assumed to be absolute.\n    if (!slashedProtocol[relative.protocol]) {\n      Object.keys(relative).forEach(function(k) {\n        result[k] = relative[k];\n      });\n      result.href = result.format();\n      return result;\n    }\n\n    result.protocol = relative.protocol;\n    if (!relative.host && !hostlessProtocol[relative.protocol]) {\n      var relPath = (relative.pathname || '').split('/');\n      while (relPath.length && !(relative.host = relPath.shift()));\n      if (!relative.host) relative.host = '';\n      if (!relative.hostname) relative.hostname = '';\n      if (relPath[0] !== '') relPath.unshift('');\n      if (relPath.length < 2) relPath.unshift('');\n      result.pathname = relPath.join('/');\n    } else {\n      result.pathname = relative.pathname;\n    }\n    result.search = relative.search;\n    result.query = relative.query;\n    result.host = relative.host || '';\n    result.auth = relative.auth;\n    result.hostname = relative.hostname || relative.host;\n    result.port = relative.port;\n    // to support http.request\n    if (result.pathname || result.search) {\n      var p = result.pathname || '';\n      var s = result.search || '';\n      result.path = p + s;\n    }\n    result.slashes = result.slashes || relative.slashes;\n    result.href = result.format();\n    return result;\n  }\n\n  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),\n      isRelAbs = (\n          relative.host ||\n          relative.pathname && relative.pathname.charAt(0) === '/'\n      ),\n      mustEndAbs = (isRelAbs || isSourceAbs ||\n                    (result.host && relative.pathname)),\n      removeAllDots = mustEndAbs,\n      srcPath = result.pathname && result.pathname.split('/') || [],\n      relPath = relative.pathname && relative.pathname.split('/') || [],\n      psychotic = result.protocol && !slashedProtocol[result.protocol];\n\n  // if the url is a non-slashed url, then relative\n  // links like ../.. should be able\n  // to crawl up to the hostname, as well.  This is strange.\n  // result.protocol has already been set by now.\n  // Later on, put the first path part into the host field.\n  if (psychotic) {\n    result.hostname = '';\n    result.port = null;\n    if (result.host) {\n      if (srcPath[0] === '') srcPath[0] = result.host;\n      else srcPath.unshift(result.host);\n    }\n    result.host = '';\n    if (relative.protocol) {\n      relative.hostname = null;\n      relative.port = null;\n      if (relative.host) {\n        if (relPath[0] === '') relPath[0] = relative.host;\n        else relPath.unshift(relative.host);\n      }\n      relative.host = null;\n    }\n    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');\n  }\n\n  if (isRelAbs) {\n    // it's absolute.\n    result.host = (relative.host || relative.host === '') ?\n                  relative.host : result.host;\n    result.hostname = (relative.hostname || relative.hostname === '') ?\n                      relative.hostname : result.hostname;\n    result.search = relative.search;\n    result.query = relative.query;\n    srcPath = relPath;\n    // fall through to the dot-handling below.\n  } else if (relPath.length) {\n    // it's relative\n    // throw away the existing file, and take the new path instead.\n    if (!srcPath) srcPath = [];\n    srcPath.pop();\n    srcPath = srcPath.concat(relPath);\n    result.search = relative.search;\n    result.query = relative.query;\n  } else if (!util.isNullOrUndefined(relative.search)) {\n    // just pull out the search.\n    // like href='?foo'.\n    // Put this after the other two cases because it simplifies the booleans\n    if (psychotic) {\n      result.hostname = result.host = srcPath.shift();\n      //occationaly the auth can get stuck only in host\n      //this especialy happens in cases like\n      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')\n      var authInHost = result.host && result.host.indexOf('@') > 0 ?\n                       result.host.split('@') : false;\n      if (authInHost) {\n        result.auth = authInHost.shift();\n        result.host = result.hostname = authInHost.shift();\n      }\n    }\n    result.search = relative.search;\n    result.query = relative.query;\n    //to support http.request\n    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {\n      result.path = (result.pathname ? result.pathname : '') +\n                    (result.search ? result.search : '');\n    }\n    result.href = result.format();\n    return result;\n  }\n\n  if (!srcPath.length) {\n    // no path at all.  easy.\n    // we've already handled the other stuff above.\n    result.pathname = null;\n    //to support http.request\n    if (result.search) {\n      result.path = '/' + result.search;\n    } else {\n      result.path = null;\n    }\n    result.href = result.format();\n    return result;\n  }\n\n  // if a url ENDs in . or .., then it must get a trailing slash.\n  // however, if it ends in anything else non-slashy,\n  // then it must NOT get a trailing slash.\n  var last = srcPath.slice(-1)[0];\n  var hasTrailingSlash = (\n      (result.host || relative.host) && (last === '.' || last === '..') ||\n      last === '');\n\n  // strip single dots, resolve double dots to parent dir\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = srcPath.length; i >= 0; i--) {\n    last = srcPath[i];\n    if (last === '.') {\n      srcPath.splice(i, 1);\n    } else if (last === '..') {\n      srcPath.splice(i, 1);\n      up++;\n    } else if (up) {\n      srcPath.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (!mustEndAbs && !removeAllDots) {\n    for (; up--; up) {\n      srcPath.unshift('..');\n    }\n  }\n\n  if (mustEndAbs && srcPath[0] !== '' &&\n      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {\n    srcPath.unshift('');\n  }\n\n  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {\n    srcPath.push('');\n  }\n\n  var isAbsolute = srcPath[0] === '' ||\n      (srcPath[0] && srcPath[0].charAt(0) === '/');\n\n  // put the host back\n  if (psychotic) {\n    result.hostname = result.host = isAbsolute ? '' :\n                                    srcPath.length ? srcPath.shift() : '';\n    //occationaly the auth can get stuck only in host\n    //this especialy happens in cases like\n    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')\n    var authInHost = result.host && result.host.indexOf('@') > 0 ?\n                     result.host.split('@') : false;\n    if (authInHost) {\n      result.auth = authInHost.shift();\n      result.host = result.hostname = authInHost.shift();\n    }\n  }\n\n  mustEndAbs = mustEndAbs || (result.host && srcPath.length);\n\n  if (mustEndAbs && !isAbsolute) {\n    srcPath.unshift('');\n  }\n\n  if (!srcPath.length) {\n    result.pathname = null;\n    result.path = null;\n  } else {\n    result.pathname = srcPath.join('/');\n  }\n\n  //to support request.http\n  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {\n    result.path = (result.pathname ? result.pathname : '') +\n                  (result.search ? result.search : '');\n  }\n  result.auth = relative.auth || result.auth;\n  result.slashes = result.slashes || relative.slashes;\n  result.href = result.format();\n  return result;\n};\n\nUrl.prototype.parseHost = function() {\n  var host = this.host;\n  var port = portPattern.exec(host);\n  if (port) {\n    port = port[0];\n    if (port !== ':') {\n      this.port = port.substr(1);\n    }\n    host = host.substr(0, host.length - port.length);\n  }\n  if (host) this.hostname = host;\n};\n",
  @"// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar formatRegExp = /%[sdj%]/g;\nexports.format = function(f) {\n  if (!isString(f)) {\n    var objects = [];\n    for (var i = 0; i < arguments.length; i++) {\n      objects.push(inspect(arguments[i]));\n    }\n    return objects.join(' ');\n  }\n\n  var i = 1;\n  var args = arguments;\n  var len = args.length;\n  var str = String(f).replace(formatRegExp, function(x) {\n    if (x === '%%') return '%';\n    if (i >= len) return x;\n    switch (x) {\n      case '%s': return String(args[i++]);\n      case '%d': return Number(args[i++]);\n      case '%j':\n        try {\n          return JSON.stringify(args[i++]);\n        } catch (_) {\n          return '[Circular]';\n        }\n      default:\n        return x;\n    }\n  });\n  for (var x = args[i]; i < len; x = args[++i]) {\n    if (isNull(x) || !isObject(x)) {\n      str += ' ' + x;\n    } else {\n      str += ' ' + inspect(x);\n    }\n  }\n  return str;\n};\n\n\n// Mark that a method should not be used.\n// Returns a modified function which warns once by default.\n// If --no-deprecation is set, then it is a no-op.\nexports.deprecate = function(fn, msg) {\n  // Allow for deprecating things in the process of starting up.\n  if (isUndefined(global.process)) {\n    return function() {\n      return exports.deprecate(fn, msg).apply(this, arguments);\n    };\n  }\n\n  if (process.noDeprecation === true) {\n    return fn;\n  }\n\n  var warned = false;\n  function deprecated() {\n    if (!warned) {\n      if (process.throwDeprecation) {\n        throw new Error(msg);\n      } else if (process.traceDeprecation) {\n        console.trace(msg);\n      } else {\n        console.error(msg);\n      }\n      warned = true;\n    }\n    return fn.apply(this, arguments);\n  }\n\n  return deprecated;\n};\n\n\nvar debugs = {};\nvar debugEnviron;\nexports.debuglog = function(set) {\n  if (isUndefined(debugEnviron))\n    debugEnviron = process.env.NODE_DEBUG || '';\n  set = set.toUpperCase();\n  if (!debugs[set]) {\n    if (new RegExp('\\\\b' + set + '\\\\b', 'i').test(debugEnviron)) {\n      var pid = process.pid;\n      debugs[set] = function() {\n        var msg = exports.format.apply(exports, arguments);\n        console.error('%s %d: %s', set, pid, msg);\n      };\n    } else {\n      debugs[set] = function() {};\n    }\n  }\n  return debugs[set];\n};\n\n\n\n\n\n\n\n\n\n\nfunction inspect(obj, opts) {\n  // default options\n  var ctx = {\n    seen: [],\n    stylize: stylizeNoColor\n  };\n  // legacy...\n  if (arguments.length >= 3) ctx.depth = arguments[2];\n  if (arguments.length >= 4) ctx.colors = arguments[3];\n  if (isBoolean(opts)) {\n    // legacy...\n    ctx.showHidden = opts;\n  } else if (opts) {\n    // got an \"options\" object\n    exports._extend(ctx, opts);\n  }\n  // set default options\n  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;\n  if (isUndefined(ctx.depth)) ctx.depth = 2;\n  if (isUndefined(ctx.colors)) ctx.colors = false;\n  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;\n  if (ctx.colors) ctx.stylize = stylizeWithColor;\n  return formatValue(ctx, obj, ctx.depth);\n}\nexports.inspect = inspect;\n\n\n// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\ninspect.colors = {\n  'bold' : [1, 22],\n  'italic' : [3, 23],\n  'underline' : [4, 24],\n  'inverse' : [7, 27],\n  'white' : [37, 39],\n  'grey' : [90, 39],\n  'black' : [30, 39],\n  'blue' : [34, 39],\n  'cyan' : [36, 39],\n  'green' : [32, 39],\n  'magenta' : [35, 39],\n  'red' : [31, 39],\n  'yellow' : [33, 39]\n};\n\n// Don't use 'blue' not visible on cmd.exe\ninspect.styles = {\n  'special': 'cyan',\n  'number': 'yellow',\n  'boolean': 'yellow',\n  'undefined': 'grey',\n  'null': 'bold',\n  'string': 'green',\n  'date': 'magenta',\n  // \"name\": intentionally not styling\n  'regexp': 'red'\n};\n\n\nfunction stylizeWithColor(str, styleType) {\n  var style = inspect.styles[styleType];\n\n  if (style) {\n    return '\\u001b[' + inspect.colors[style][0] + 'm' + str +\n           '\\u001b[' + inspect.colors[style][1] + 'm';\n  } else {\n    return str;\n  }\n}\n\n\nfunction stylizeNoColor(str, styleType) {\n  return str;\n}\n\n\nfunction arrayToHash(array) {\n  var hash = {};\n\n  array.forEach(function(val, idx) {\n    hash[val] = true;\n  });\n\n  return hash;\n}\n\n\nfunction formatValue(ctx, value, recurseTimes) {\n  // Provide a hook for user-specified inspect functions.\n  // Check that value is an object with an inspect function on it\n  if (ctx.customInspect &&\n      value &&\n      isFunction(value.inspect) &&\n      // Filter out the util module, it's inspect function is special\n      value.inspect !== exports.inspect &&\n      // Also filter out any prototype objects using the circular check.\n      !(value.constructor && value.constructor.prototype === value)) {\n    var ret = value.inspect(recurseTimes, ctx);\n    if (!isString(ret)) {\n      ret = formatValue(ctx, ret, recurseTimes);\n    }\n    return ret;\n  }\n\n  // Primitive types cannot have properties\n  var primitive = formatPrimitive(ctx, value);\n  if (primitive) {\n    return primitive;\n  }\n\n  // Look up the keys of the object.\n  var keys = Object.keys(value);\n  var visibleKeys = arrayToHash(keys);\n\n  if (ctx.showHidden) {\n    keys = Object.getOwnPropertyNames(value);\n  }\n\n  // This could be a boxed primitive (new String(), etc.), check valueOf()\n  // NOTE: Avoid calling `valueOf` on `Date` instance because it will return\n  // a number which, when object has some additional user-stored `keys`,\n  // will be printed out.\n  var formatted;\n  var raw = value;\n  try {\n    // the .valueOf() call can fail for a multitude of reasons\n    if (!isDate(value))\n      raw = value.valueOf();\n  } catch (e) {\n    // ignore...\n  }\n\n  if (isString(raw)) {\n    // for boxed Strings, we have to remove the 0-n indexed entries,\n    // since they just noisey up the output and are redundant\n    keys = keys.filter(function(key) {\n      return !(key >= 0 && key < raw.length);\n    });\n  }\n\n  // Some type of object without properties can be shortcutted.\n  if (keys.length === 0) {\n    if (isFunction(value)) {\n      var name = value.name ? ': ' + value.name : '';\n      return ctx.stylize('[Function' + name + ']', 'special');\n    }\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    }\n    if (isDate(value)) {\n      return ctx.stylize(Date.prototype.toString.call(value), 'date');\n    }\n    if (isError(value)) {\n      return formatError(value);\n    }\n    // now check the `raw` value to handle boxed primitives\n    if (isString(raw)) {\n      formatted = formatPrimitiveNoColor(ctx, raw);\n      return ctx.stylize('[String: ' + formatted + ']', 'string');\n    }\n    if (isNumber(raw)) {\n      formatted = formatPrimitiveNoColor(ctx, raw);\n      return ctx.stylize('[Number: ' + formatted + ']', 'number');\n    }\n    if (isBoolean(raw)) {\n      formatted = formatPrimitiveNoColor(ctx, raw);\n      return ctx.stylize('[Boolean: ' + formatted + ']', 'boolean');\n    }\n  }\n\n  var base = '', array = false, braces = ['{', '}'];\n\n  // Make Array say that they are Array\n  if (isArray(value)) {\n    array = true;\n    braces = ['[', ']'];\n  }\n\n  // Make functions say that they are functions\n  if (isFunction(value)) {\n    var n = value.name ? ': ' + value.name : '';\n    base = ' [Function' + n + ']';\n  }\n\n  // Make RegExps say that they are RegExps\n  if (isRegExp(value)) {\n    base = ' ' + RegExp.prototype.toString.call(value);\n  }\n\n  // Make dates with properties first say the date\n  if (isDate(value)) {\n    base = ' ' + Date.prototype.toUTCString.call(value);\n  }\n\n  // Make error with message first say the error\n  if (isError(value)) {\n    base = ' ' + formatError(value);\n  }\n\n  // Make boxed primitive Strings look like such\n  if (isString(raw)) {\n    formatted = formatPrimitiveNoColor(ctx, raw);\n    base = ' ' + '[String: ' + formatted + ']';\n  }\n\n  // Make boxed primitive Numbers look like such\n  if (isNumber(raw)) {\n    formatted = formatPrimitiveNoColor(ctx, raw);\n    base = ' ' + '[Number: ' + formatted + ']';\n  }\n\n  // Make boxed primitive Booleans look like such\n  if (isBoolean(raw)) {\n    formatted = formatPrimitiveNoColor(ctx, raw);\n    base = ' ' + '[Boolean: ' + formatted + ']';\n  }\n\n  if (keys.length === 0 && (!array || value.length === 0)) {\n    return braces[0] + base + braces[1];\n  }\n\n  if (recurseTimes < 0) {\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    } else {\n      return ctx.stylize('[Object]', 'special');\n    }\n  }\n\n  ctx.seen.push(value);\n\n  var output;\n  if (array) {\n    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\n  } else {\n    output = keys.map(function(key) {\n      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\n    });\n  }\n\n  ctx.seen.pop();\n\n  return reduceToSingleString(output, base, braces);\n}\n\n\nfunction formatPrimitive(ctx, value) {\n  if (isUndefined(value))\n    return ctx.stylize('undefined', 'undefined');\n  if (isString(value)) {\n    var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '')\n                                             .replace(/'/g, \"\\\\'\")\n                                             .replace(/\\\\\"/g, '\"') + '\\'';\n    return ctx.stylize(simple, 'string');\n  }\n  if (isNumber(value)) {\n    // Format -0 as '-0'. Strict equality won't distinguish 0 from -0,\n    // so instead we use the fact that 1 / -0 < 0 whereas 1 / 0 > 0 .\n    if (value === 0 && 1 / value < 0)\n      return ctx.stylize('-0', 'number');\n    return ctx.stylize('' + value, 'number');\n  }\n  if (isBoolean(value))\n    return ctx.stylize('' + value, 'boolean');\n  // For some reason typeof null is \"object\", so special case here.\n  if (isNull(value))\n    return ctx.stylize('null', 'null');\n}\n\n\nfunction formatPrimitiveNoColor(ctx, value) {\n  var stylize = ctx.stylize;\n  ctx.stylize = stylizeNoColor;\n  var str = formatPrimitive(ctx, value);\n  ctx.stylize = stylize;\n  return str;\n}\n\n\nfunction formatError(value) {\n  return '[' + Error.prototype.toString.call(value) + ']';\n}\n\n\nfunction formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\n  var output = [];\n  for (var i = 0, l = value.length; i < l; ++i) {\n    if (hasOwnProperty(value, String(i))) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          String(i), true));\n    } else {\n      output.push('');\n    }\n  }\n  keys.forEach(function(key) {\n    if (!key.match(/^\\d+$/)) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          key, true));\n    }\n  });\n  return output;\n}\n\n\nfunction formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\n  var name, str, desc;\n  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };\n  if (desc.get) {\n    if (desc.set) {\n      str = ctx.stylize('[Getter/Setter]', 'special');\n    } else {\n      str = ctx.stylize('[Getter]', 'special');\n    }\n  } else {\n    if (desc.set) {\n      str = ctx.stylize('[Setter]', 'special');\n    }\n  }\n  if (!hasOwnProperty(visibleKeys, key)) {\n    name = '[' + key + ']';\n  }\n  if (!str) {\n    if (ctx.seen.indexOf(desc.value) < 0) {\n      if (isNull(recurseTimes)) {\n        str = formatValue(ctx, desc.value, null);\n      } else {\n        str = formatValue(ctx, desc.value, recurseTimes - 1);\n      }\n      if (str.indexOf('\\n') > -1) {\n        if (array) {\n          str = str.split('\\n').map(function(line) {\n            return '  ' + line;\n          }).join('\\n').substr(2);\n        } else {\n          str = '\\n' + str.split('\\n').map(function(line) {\n            return '   ' + line;\n          }).join('\\n');\n        }\n      }\n    } else {\n      str = ctx.stylize('[Circular]', 'special');\n    }\n  }\n  if (isUndefined(name)) {\n    if (array && key.match(/^\\d+$/)) {\n      return str;\n    }\n    name = JSON.stringify('' + key);\n    if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n      name = name.substr(1, name.length - 2);\n      name = ctx.stylize(name, 'name');\n    } else {\n      name = name.replace(/'/g, \"\\\\'\")\n                 .replace(/\\\\\"/g, '\"')\n                 .replace(/(^\"|\"$)/g, \"'\")\n                 .replace(/\\\\\\\\/g, '\\\\');\n      name = ctx.stylize(name, 'string');\n    }\n  }\n\n  return name + ': ' + str;\n}\n\n\nfunction reduceToSingleString(output, base, braces) {\n  var length = output.reduce(function(prev, cur) {\n    return prev + cur.replace(/\\u001b\\[\\d\\d?m/g, '').length + 1;\n  }, 0);\n\n  if (length > 60) {\n    return braces[0] +\n           (base === '' ? '' : base + '\\n ') +\n           ' ' +\n           output.join(',\\n  ') +\n           ' ' +\n           braces[1];\n  }\n\n  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\n}\n\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\nvar isArray = exports.isArray = Array.isArray;\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n  return arg === null;\n}\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n  return arg == null;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n  return typeof arg === 'symbol';\n}\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n  return isObject(re) && objectToString(re) === '[object RegExp]';\n}\nexports.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\nexports.isObject = isObject;\n\nfunction isDate(d) {\n  return isObject(d) && objectToString(d) === '[object Date]';\n}\nexports.isDate = isDate;\n\nfunction isError(e) {\n  return isObject(e) &&\n      (objectToString(e) === '[object Error]' || e instanceof Error);\n}\nexports.isError = isError;\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n         typeof arg === 'boolean' ||\n         typeof arg === 'number' ||\n         typeof arg === 'string' ||\n         typeof arg === 'symbol' ||  // ES6 symbol\n         typeof arg === 'undefined';\n}\nexports.isPrimitive = isPrimitive;\n\nfunction isBuffer(arg) {\n  return arg instanceof Buffer;\n}\nexports.isBuffer = isBuffer;\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n\n\nfunction pad(n) {\n  return n < 10 ? '0' + n.toString(10) : n.toString(10);\n}\n\n\nvar months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',\n              'Oct', 'Nov', 'Dec'];\n\n// 26 Feb 16:19:34\nfunction timestamp() {\n  var d = new Date();\n  var time = [pad(d.getHours()),\n              pad(d.getMinutes()),\n              pad(d.getSeconds())].join(':');\n  return [d.getDate(), months[d.getMonth()], time].join(' ');\n}\n\n\n// log is just a thin wrapper to console.log that prepends a timestamp\nexports.log = function() {\n  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));\n};\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nexports.inherits = function(ctor, superCtor) {\n  ctor.super_ = superCtor;\n  ctor.prototype = Object.create(superCtor.prototype, {\n    constructor: {\n      value: ctor,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n};\n\nexports._extend = function(origin, add) {\n  // Don't do anything if add isn't an object\n  if (!add || !isObject(add)) return origin;\n\n  var keys = Object.keys(add);\n  var i = keys.length;\n  while (i--) {\n    origin[keys[i]] = add[keys[i]];\n  }\n  return origin;\n};\n\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\n\n// Deprecated old stuff.\n\nexports.p = exports.deprecate(function() {\n  for (var i = 0, len = arguments.length; i < len; ++i) {\n    console.error(exports.inspect(arguments[i]));\n  }\n}, 'util.p: Use console.error() instead');\n\n\nexports.exec = exports.deprecate(function() {\n  return require('child_process').exec.apply(this, arguments);\n}, 'util.exec is now called `child_process.exec`.');\n\n\nexports.print = exports.deprecate(function() {\n  for (var i = 0, len = arguments.length; i < len; ++i) {\n    process.stdout.write(String(arguments[i]));\n  }\n}, 'util.print: Use console.log instead');\n\n\nexports.puts = exports.deprecate(function() {\n  for (var i = 0, len = arguments.length; i < len; ++i) {\n    process.stdout.write(arguments[i] + '\\n');\n  }\n}, 'util.puts: Use console.log instead');\n\n\nexports.debug = exports.deprecate(function(x) {\n  process.stderr.write('DEBUG: ' + x + '\\n');\n}, 'util.debug: Use console.error instead');\n\n\nexports.error = exports.deprecate(function(x) {\n  for (var i = 0, len = arguments.length; i < len; ++i) {\n    process.stderr.write(arguments[i] + '\\n');\n  }\n}, 'util.error: Use console.error instead');\n\n\nexports.pump = exports.deprecate(function(readStream, writeStream, callback) {\n  var callbackCalled = false;\n\n  function call(a, b, c) {\n    if (callback && !callbackCalled) {\n      callback(a, b, c);\n      callbackCalled = true;\n    }\n  }\n\n  readStream.addListener('data', function(chunk) {\n    if (writeStream.write(chunk) === false) readStream.pause();\n  });\n\n  writeStream.addListener('drain', function() {\n    readStream.resume();\n  });\n\n  readStream.addListener('end', function() {\n    writeStream.end();\n  });\n\n  readStream.addListener('close', function() {\n    call();\n  });\n\n  readStream.addListener('error', function(err) {\n    writeStream.end();\n    call(err);\n  });\n\n  writeStream.addListener('error', function(err) {\n    readStream.destroy();\n    call(err);\n  });\n}, 'util.pump(): Use readableStream.pipe() instead');\n\n\nvar uv;\nexports._errnoException = function(err, syscall, original) {\n  if (isUndefined(uv)) uv = process.binding('uv');\n  var errname = uv.errname(err);\n  var message = syscall + ' ' + errname;\n  if (original)\n    message += ' ' + original;\n  var e = new Error(message);\n  e.code = errname;\n  e.errno = errname;\n  e.syscall = syscall;\n  return e;\n};\n",
  @"// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar binding = process.binding('contextify');\nvar Script = binding.ContextifyScript;\nvar util = require('util');\n\n// The binding provides a few useful primitives:\n// - ContextifyScript(code, { filename = \"evalmachine.anonymous\",\n//                            displayErrors = true } = {})\n//   with methods:\n//   - runInThisContext({ displayErrors = true } = {})\n//   - runInContext(sandbox, { displayErrors = true, timeout = undefined } = {})\n// - makeContext(sandbox)\n// - isContext(sandbox)\n// From this we build the entire documented API.\n\nScript.prototype.runInNewContext = function(sandbox, options) {\n  var context = exports.createContext(sandbox);\n  return this.runInContext(context, options);\n};\n\nexports.Script = Script;\n\nexports.createScript = function(code, options) {\n  return new Script(code, options);\n};\n\nexports.createContext = function(sandbox) {\n  if (util.isUndefined(sandbox)) {\n    sandbox = {};\n  } else if (binding.isContext(sandbox)) {\n    return sandbox;\n  }\n\n  binding.makeContext(sandbox);\n  return sandbox;\n};\n\nexports.runInContext = function(code, contextifiedSandbox, options) {\n  var script = new Script(code, options);\n  return script.runInContext(contextifiedSandbox, options);\n};\n\nexports.runInNewContext = function(code, sandbox, options) {\n  var script = new Script(code, options);\n  return script.runInNewContext(sandbox, options);\n};\n\nexports.runInThisContext = function(code, options) {\n  var script = new Script(code, options);\n  return script.runInThisContext(options);\n};\n\nexports.isContext = binding.isContext;\n",
  @"// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar Transform = require('_stream_transform');\n\nvar binding = process.binding('zlib');\nvar util = require('util');\nvar assert = require('assert').ok;\n\n// zlib doesn't provide these, so kludge them in following the same\n// const naming scheme zlib uses.\nbinding.Z_MIN_WINDOWBITS = 8;\nbinding.Z_MAX_WINDOWBITS = 15;\nbinding.Z_DEFAULT_WINDOWBITS = 15;\n\n// fewer than 64 bytes per chunk is stupid.\n// technically it could work with as few as 8, but even 64 bytes\n// is absurdly low.  Usually a MB or more is best.\nbinding.Z_MIN_CHUNK = 64;\nbinding.Z_MAX_CHUNK = Infinity;\nbinding.Z_DEFAULT_CHUNK = (16 * 1024);\n\nbinding.Z_MIN_MEMLEVEL = 1;\nbinding.Z_MAX_MEMLEVEL = 9;\nbinding.Z_DEFAULT_MEMLEVEL = 8;\n\nbinding.Z_MIN_LEVEL = -1;\nbinding.Z_MAX_LEVEL = 9;\nbinding.Z_DEFAULT_LEVEL = binding.Z_DEFAULT_COMPRESSION;\n\n// expose all the zlib constants\nObject.keys(binding).forEach(function(k) {\n  if (k.match(/^Z/)) exports[k] = binding[k];\n});\n\n// translation table for return codes.\nexports.codes = {\n  Z_OK: binding.Z_OK,\n  Z_STREAM_END: binding.Z_STREAM_END,\n  Z_NEED_DICT: binding.Z_NEED_DICT,\n  Z_ERRNO: binding.Z_ERRNO,\n  Z_STREAM_ERROR: binding.Z_STREAM_ERROR,\n  Z_DATA_ERROR: binding.Z_DATA_ERROR,\n  Z_MEM_ERROR: binding.Z_MEM_ERROR,\n  Z_BUF_ERROR: binding.Z_BUF_ERROR,\n  Z_VERSION_ERROR: binding.Z_VERSION_ERROR\n};\n\nObject.keys(exports.codes).forEach(function(k) {\n  exports.codes[exports.codes[k]] = k;\n});\n\nexports.Deflate = Deflate;\nexports.Inflate = Inflate;\nexports.Gzip = Gzip;\nexports.Gunzip = Gunzip;\nexports.DeflateRaw = DeflateRaw;\nexports.InflateRaw = InflateRaw;\nexports.Unzip = Unzip;\n\nexports.createDeflate = function(o) {\n  return new Deflate(o);\n};\n\nexports.createInflate = function(o) {\n  return new Inflate(o);\n};\n\nexports.createDeflateRaw = function(o) {\n  return new DeflateRaw(o);\n};\n\nexports.createInflateRaw = function(o) {\n  return new InflateRaw(o);\n};\n\nexports.createGzip = function(o) {\n  return new Gzip(o);\n};\n\nexports.createGunzip = function(o) {\n  return new Gunzip(o);\n};\n\nexports.createUnzip = function(o) {\n  return new Unzip(o);\n};\n\n\n// Convenience methods.\n// compress/decompress a string or buffer in one step.\nexports.deflate = function(buffer, opts, callback) {\n  if (util.isFunction(opts)) {\n    callback = opts;\n    opts = {};\n  }\n  return zlibBuffer(new Deflate(opts), buffer, callback);\n};\n\nexports.deflateSync = function(buffer, opts) {\n  return zlibBufferSync(new Deflate(opts), buffer);\n};\n\nexports.gzip = function(buffer, opts, callback) {\n  if (util.isFunction(opts)) {\n    callback = opts;\n    opts = {};\n  }\n  return zlibBuffer(new Gzip(opts), buffer, callback);\n};\n\nexports.gzipSync = function(buffer, opts) {\n  return zlibBufferSync(new Gzip(opts), buffer);\n};\n\nexports.deflateRaw = function(buffer, opts, callback) {\n  if (util.isFunction(opts)) {\n    callback = opts;\n    opts = {};\n  }\n  return zlibBuffer(new DeflateRaw(opts), buffer, callback);\n};\n\nexports.deflateRawSync = function(buffer, opts) {\n  return zlibBufferSync(new DeflateRaw(opts), buffer);\n};\n\nexports.unzip = function(buffer, opts, callback) {\n  if (util.isFunction(opts)) {\n    callback = opts;\n    opts = {};\n  }\n  return zlibBuffer(new Unzip(opts), buffer, callback);\n};\n\nexports.unzipSync = function(buffer, opts) {\n  return zlibBufferSync(new Unzip(opts), buffer);\n};\n\nexports.inflate = function(buffer, opts, callback) {\n  if (util.isFunction(opts)) {\n    callback = opts;\n    opts = {};\n  }\n  return zlibBuffer(new Inflate(opts), buffer, callback);\n};\n\nexports.inflateSync = function(buffer, opts) {\n  return zlibBufferSync(new Inflate(opts), buffer);\n};\n\nexports.gunzip = function(buffer, opts, callback) {\n  if (util.isFunction(opts)) {\n    callback = opts;\n    opts = {};\n  }\n  return zlibBuffer(new Gunzip(opts), buffer, callback);\n};\n\nexports.gunzipSync = function(buffer, opts) {\n  return zlibBufferSync(new Gunzip(opts), buffer);\n};\n\nexports.inflateRaw = function(buffer, opts, callback) {\n  if (util.isFunction(opts)) {\n    callback = opts;\n    opts = {};\n  }\n  return zlibBuffer(new InflateRaw(opts), buffer, callback);\n};\n\nexports.inflateRawSync = function(buffer, opts) {\n  return zlibBufferSync(new InflateRaw(opts), buffer);\n};\n\nfunction zlibBuffer(engine, buffer, callback) {\n  var buffers = [];\n  var nread = 0;\n\n  engine.on('error', onError);\n  engine.on('end', onEnd);\n\n  engine.end(buffer);\n  flow();\n\n  function flow() {\n    var chunk;\n    while (null !== (chunk = engine.read())) {\n      buffers.push(chunk);\n      nread += chunk.length;\n    }\n    engine.once('readable', flow);\n  }\n\n  function onError(err) {\n    engine.removeListener('end', onEnd);\n    engine.removeListener('readable', flow);\n    callback(err);\n  }\n\n  function onEnd() {\n    var buf = Buffer.concat(buffers, nread);\n    buffers = [];\n    callback(null, buf);\n    engine.close();\n  }\n}\n\nfunction zlibBufferSync(engine, buffer) {\n  if (util.isString(buffer))\n    buffer = new Buffer(buffer);\n  if (!util.isBuffer(buffer))\n    throw new TypeError('Not a string or buffer');\n\n  var flushFlag = binding.Z_FINISH;\n\n  return engine._processChunk(buffer, flushFlag);\n}\n\n// generic zlib\n// minimal 2-byte header\nfunction Deflate(opts) {\n  if (!(this instanceof Deflate)) return new Deflate(opts);\n  Zlib.call(this, opts, binding.DEFLATE);\n}\n\nfunction Inflate(opts) {\n  if (!(this instanceof Inflate)) return new Inflate(opts);\n  Zlib.call(this, opts, binding.INFLATE);\n}\n\n\n\n// gzip - bigger header, same deflate compression\nfunction Gzip(opts) {\n  if (!(this instanceof Gzip)) return new Gzip(opts);\n  Zlib.call(this, opts, binding.GZIP);\n}\n\nfunction Gunzip(opts) {\n  if (!(this instanceof Gunzip)) return new Gunzip(opts);\n  Zlib.call(this, opts, binding.GUNZIP);\n}\n\n\n\n// raw - no header\nfunction DeflateRaw(opts) {\n  if (!(this instanceof DeflateRaw)) return new DeflateRaw(opts);\n  Zlib.call(this, opts, binding.DEFLATERAW);\n}\n\nfunction InflateRaw(opts) {\n  if (!(this instanceof InflateRaw)) return new InflateRaw(opts);\n  Zlib.call(this, opts, binding.INFLATERAW);\n}\n\n\n// auto-detect header.\nfunction Unzip(opts) {\n  if (!(this instanceof Unzip)) return new Unzip(opts);\n  Zlib.call(this, opts, binding.UNZIP);\n}\n\n\n// the Zlib class they all inherit from\n// This thing manages the queue of requests, and returns\n// true or false if there is anything in the queue when\n// you call the .write() method.\n\nfunction Zlib(opts, mode) {\n  this._opts = opts = opts || {};\n  this._chunkSize = opts.chunkSize || exports.Z_DEFAULT_CHUNK;\n\n  Transform.call(this, opts);\n\n  if (opts.flush) {\n    if (opts.flush !== binding.Z_NO_FLUSH &&\n        opts.flush !== binding.Z_PARTIAL_FLUSH &&\n        opts.flush !== binding.Z_SYNC_FLUSH &&\n        opts.flush !== binding.Z_FULL_FLUSH &&\n        opts.flush !== binding.Z_FINISH &&\n        opts.flush !== binding.Z_BLOCK) {\n      throw new Error('Invalid flush flag: ' + opts.flush);\n    }\n  }\n  this._flushFlag = opts.flush || binding.Z_NO_FLUSH;\n\n  if (opts.chunkSize) {\n    if (opts.chunkSize < exports.Z_MIN_CHUNK ||\n        opts.chunkSize > exports.Z_MAX_CHUNK) {\n      throw new Error('Invalid chunk size: ' + opts.chunkSize);\n    }\n  }\n\n  if (opts.windowBits) {\n    if (opts.windowBits < exports.Z_MIN_WINDOWBITS ||\n        opts.windowBits > exports.Z_MAX_WINDOWBITS) {\n      throw new Error('Invalid windowBits: ' + opts.windowBits);\n    }\n  }\n\n  if (opts.level) {\n    if (opts.level < exports.Z_MIN_LEVEL ||\n        opts.level > exports.Z_MAX_LEVEL) {\n      throw new Error('Invalid compression level: ' + opts.level);\n    }\n  }\n\n  if (opts.memLevel) {\n    if (opts.memLevel < exports.Z_MIN_MEMLEVEL ||\n        opts.memLevel > exports.Z_MAX_MEMLEVEL) {\n      throw new Error('Invalid memLevel: ' + opts.memLevel);\n    }\n  }\n\n  if (opts.strategy) {\n    if (opts.strategy != exports.Z_FILTERED &&\n        opts.strategy != exports.Z_HUFFMAN_ONLY &&\n        opts.strategy != exports.Z_RLE &&\n        opts.strategy != exports.Z_FIXED &&\n        opts.strategy != exports.Z_DEFAULT_STRATEGY) {\n      throw new Error('Invalid strategy: ' + opts.strategy);\n    }\n  }\n\n  if (opts.dictionary) {\n    if (!util.isBuffer(opts.dictionary)) {\n      throw new Error('Invalid dictionary: it should be a Buffer instance');\n    }\n  }\n\n  this._handle = new binding.Zlib(mode);\n\n  var self = this;\n  this._hadError = false;\n  this._handle.onerror = function(message, errno) {\n    // there is no way to cleanly recover.\n    // continuing only obscures problems.\n    self._handle = null;\n    self._hadError = true;\n\n    var error = new Error(message);\n    error.errno = errno;\n    error.code = exports.codes[errno];\n    self.emit('error', error);\n  };\n\n  var level = exports.Z_DEFAULT_COMPRESSION;\n  if (util.isNumber(opts.level)) level = opts.level;\n\n  var strategy = exports.Z_DEFAULT_STRATEGY;\n  if (util.isNumber(opts.strategy)) strategy = opts.strategy;\n\n  this._handle.init(opts.windowBits || exports.Z_DEFAULT_WINDOWBITS,\n                    level,\n                    opts.memLevel || exports.Z_DEFAULT_MEMLEVEL,\n                    strategy,\n                    opts.dictionary);\n\n  this._buffer = new Buffer(this._chunkSize);\n  this._offset = 0;\n  this._closed = false;\n  this._level = level;\n  this._strategy = strategy;\n\n  this.once('end', this.close);\n}\n\nutil.inherits(Zlib, Transform);\n\nZlib.prototype.params = function(level, strategy, callback) {\n  if (level < exports.Z_MIN_LEVEL ||\n      level > exports.Z_MAX_LEVEL) {\n    throw new RangeError('Invalid compression level: ' + level);\n  }\n  if (strategy != exports.Z_FILTERED &&\n      strategy != exports.Z_HUFFMAN_ONLY &&\n      strategy != exports.Z_RLE &&\n      strategy != exports.Z_FIXED &&\n      strategy != exports.Z_DEFAULT_STRATEGY) {\n    throw new TypeError('Invalid strategy: ' + strategy);\n  }\n\n  if (this._level !== level || this._strategy !== strategy) {\n    var self = this;\n    this.flush(binding.Z_SYNC_FLUSH, function() {\n      self._handle.params(level, strategy);\n      if (!self._hadError) {\n        self._level = level;\n        self._strategy = strategy;\n        if (callback) callback();\n      }\n    });\n  } else {\n    process.nextTick(callback);\n  }\n};\n\nZlib.prototype.reset = function() {\n  return this._handle.reset();\n};\n\n// This is the _flush function called by the transform class,\n// internally, when the last chunk has been written.\nZlib.prototype._flush = function(callback) {\n  this._transform(new Buffer(0), '', callback);\n};\n\nZlib.prototype.flush = function(kind, callback) {\n  var ws = this._writableState;\n\n  if (util.isFunction(kind) || (util.isUndefined(kind) && !callback)) {\n    callback = kind;\n    kind = binding.Z_FULL_FLUSH;\n  }\n\n  if (ws.ended) {\n    if (callback)\n      process.nextTick(callback);\n  } else if (ws.ending) {\n    if (callback)\n      this.once('end', callback);\n  } else if (ws.needDrain) {\n    var self = this;\n    this.once('drain', function() {\n      self.flush(callback);\n    });\n  } else {\n    this._flushFlag = kind;\n    this.write(new Buffer(0), '', callback);\n  }\n};\n\nZlib.prototype.close = function(callback) {\n  if (callback)\n    process.nextTick(callback);\n\n  if (this._closed)\n    return;\n\n  this._closed = true;\n\n  this._handle.close();\n\n  var self = this;\n  process.nextTick(function() {\n    self.emit('close');\n  });\n};\n\nZlib.prototype._transform = function(chunk, encoding, cb) {\n  var flushFlag;\n  var ws = this._writableState;\n  var ending = ws.ending || ws.ended;\n  var last = ending && (!chunk || ws.length === chunk.length);\n\n  if (!util.isNull(chunk) && !util.isBuffer(chunk))\n    return cb(new Error('invalid input'));\n\n  // If it's the last chunk, or a final flush, we use the Z_FINISH flush flag.\n  // If it's explicitly flushing at some other time, then we use\n  // Z_FULL_FLUSH. Otherwise, use Z_NO_FLUSH for maximum compression\n  // goodness.\n  if (last)\n    flushFlag = binding.Z_FINISH;\n  else {\n    flushFlag = this._flushFlag;\n    // once we've flushed the last of the queue, stop flushing and\n    // go back to the normal behavior.\n    if (chunk.length >= ws.length) {\n      this._flushFlag = this._opts.flush || binding.Z_NO_FLUSH;\n    }\n  }\n\n  this._processChunk(chunk, flushFlag, cb);\n};\n\nZlib.prototype._processChunk = function(chunk, flushFlag, cb) {\n  var availInBefore = chunk && chunk.length;\n  var availOutBefore = this._chunkSize - this._offset;\n  var inOff = 0;\n\n  var self = this;\n\n  var async = util.isFunction(cb);\n\n  if (!async) {\n    var buffers = [];\n    var nread = 0;\n\n    var error;\n    this.on('error', function(er) {\n      error = er;\n    });\n\n    do {\n      var res = this._handle.writeSync(flushFlag,\n                                       chunk, // in\n                                       inOff, // in_off\n                                       availInBefore, // in_len\n                                       this._buffer, // out\n                                       this._offset, //out_off\n                                       availOutBefore); // out_len\n    } while (!this._hadError && callback(res[0], res[1]));\n\n    if (this._hadError) {\n      throw error;\n    }\n\n    var buf = Buffer.concat(buffers, nread);\n    this.close();\n\n    return buf;\n  }\n\n  var req = this._handle.write(flushFlag,\n                               chunk, // in\n                               inOff, // in_off\n                               availInBefore, // in_len\n                               this._buffer, // out\n                               this._offset, //out_off\n                               availOutBefore); // out_len\n\n  req.buffer = chunk;\n  req.callback = callback;\n\n  function callback(availInAfter, availOutAfter) {\n    if (self._hadError)\n      return;\n\n    var have = availOutBefore - availOutAfter;\n    assert(have >= 0, 'have should not go down');\n\n    if (have > 0) {\n      var out = self._buffer.slice(self._offset, self._offset + have);\n      self._offset += have;\n      // serve some output to the consumer.\n      if (async) {\n        self.push(out);\n      } else {\n        buffers.push(out);\n        nread += out.length;\n      }\n    }\n\n    // exhausted the output buffer, or used all the input create a new one.\n    if (availOutAfter === 0 || self._offset >= self._chunkSize) {\n      availOutBefore = self._chunkSize;\n      self._offset = 0;\n      self._buffer = new Buffer(self._chunkSize);\n    }\n\n    if (availOutAfter === 0) {\n      // Not actually done.  Need to reprocess.\n      // Also, update the availInBefore to the availInAfter value,\n      // so that if we have to hit it a third (fourth, etc.) time,\n      // it'll have the correct byte counts.\n      inOff += (availInBefore - availInAfter);\n      availInBefore = availInAfter;\n\n      if (!async)\n        return true;\n\n      var newReq = self._handle.write(flushFlag,\n                                      chunk,\n                                      inOff,\n                                      availInBefore,\n                                      self._buffer,\n                                      self._offset,\n                                      self._chunkSize);\n      newReq.callback = callback; // this same function\n      newReq.buffer = chunk;\n      return;\n    }\n\n    if (!async)\n      return false;\n\n    // finished with the chunk.\n    cb();\n  }\n};\n\nutil.inherits(Deflate, Zlib);\nutil.inherits(Inflate, Zlib);\nutil.inherits(Gzip, Zlib);\nutil.inherits(Gunzip, Zlib);\nutil.inherits(DeflateRaw, Zlib);\nutil.inherits(InflateRaw, Zlib);\nutil.inherits(Unzip, Zlib);\n"
};

+ (instancetype)sharedSources
{
    static dispatch_once_t predicate;
    static id sharedSources = nil;
    dispatch_once(&predicate, ^{
        sharedSources = [[self alloc] init];
    });
    return sharedSources;
}

- (NSUInteger)scriptCount
{
    return 53;
}

- (NSUInteger)indexOfScript:(NSString *)moduleName
{
    if ([moduleName isEqualToString:@"node"]) return 0;
    if ([moduleName isEqualToString:@"iOS"]) return 1;
    if ([moduleName isEqualToString:@"_debugger"]) return 2;
    if ([moduleName isEqualToString:@"_http_agent"]) return 3;
    if ([moduleName isEqualToString:@"_http_client"]) return 4;
    if ([moduleName isEqualToString:@"_http_common"]) return 5;
    if ([moduleName isEqualToString:@"_http_incoming"]) return 6;
    if ([moduleName isEqualToString:@"_http_outgoing"]) return 7;
    if ([moduleName isEqualToString:@"_http_server"]) return 8;
    if ([moduleName isEqualToString:@"_linklist"]) return 9;
    if ([moduleName isEqualToString:@"_stream_duplex"]) return 10;
    if ([moduleName isEqualToString:@"_stream_passthrough"]) return 11;
    if ([moduleName isEqualToString:@"_stream_readable"]) return 12;
    if ([moduleName isEqualToString:@"_stream_transform"]) return 13;
    if ([moduleName isEqualToString:@"_stream_writable"]) return 14;
    if ([moduleName isEqualToString:@"_tls_common"]) return 15;
    if ([moduleName isEqualToString:@"_tls_legacy"]) return 16;
    if ([moduleName isEqualToString:@"_tls_wrap"]) return 17;
    if ([moduleName isEqualToString:@"assert"]) return 18;
    if ([moduleName isEqualToString:@"buffer"]) return 19;
    if ([moduleName isEqualToString:@"child_process"]) return 20;
    if ([moduleName isEqualToString:@"cluster"]) return 21;
    if ([moduleName isEqualToString:@"console"]) return 22;
    if ([moduleName isEqualToString:@"constants"]) return 23;
    if ([moduleName isEqualToString:@"crypto"]) return 24;
    if ([moduleName isEqualToString:@"dgram"]) return 25;
    if ([moduleName isEqualToString:@"dns"]) return 26;
    if ([moduleName isEqualToString:@"domain"]) return 27;
    if ([moduleName isEqualToString:@"events"]) return 28;
    if ([moduleName isEqualToString:@"freelist"]) return 29;
    if ([moduleName isEqualToString:@"fs"]) return 30;
    if ([moduleName isEqualToString:@"http"]) return 31;
    if ([moduleName isEqualToString:@"https"]) return 32;
    if ([moduleName isEqualToString:@"module"]) return 33;
    if ([moduleName isEqualToString:@"net"]) return 34;
    if ([moduleName isEqualToString:@"os"]) return 35;
    if ([moduleName isEqualToString:@"path"]) return 36;
    if ([moduleName isEqualToString:@"punycode"]) return 37;
    if ([moduleName isEqualToString:@"querystring"]) return 38;
    if ([moduleName isEqualToString:@"readline"]) return 39;
    if ([moduleName isEqualToString:@"repl"]) return 40;
    if ([moduleName isEqualToString:@"smalloc"]) return 41;
    if ([moduleName isEqualToString:@"stream"]) return 42;
    if ([moduleName isEqualToString:@"string_decoder"]) return 43;
    if ([moduleName isEqualToString:@"sys"]) return 44;
    if ([moduleName isEqualToString:@"timers"]) return 45;
    if ([moduleName isEqualToString:@"tls"]) return 46;
    if ([moduleName isEqualToString:@"tracing"]) return 47;
    if ([moduleName isEqualToString:@"tty"]) return 48;
    if ([moduleName isEqualToString:@"url"]) return 49;
    if ([moduleName isEqualToString:@"util"]) return 50;
    if ([moduleName isEqualToString:@"vm"]) return 51;
    if ([moduleName isEqualToString:@"zlib"]) return 52;

    NSString *message = [NSString stringWithFormat:@"Unknown built-in %@", moduleName];
    @throw [NSException exceptionWithName:NSInternalInconsistencyException reason:message userInfo:nil];
}

- (NSString *)nameOfScriptAtIndex:(NSUInteger)index
{
    if (index == 0) return @"native node.js";
    if (index == 1) return @"native iOS.js";
    if (index == 2) return @"native _debugger.js";
    if (index == 3) return @"native _http_agent.js";
    if (index == 4) return @"native _http_client.js";
    if (index == 5) return @"native _http_common.js";
    if (index == 6) return @"native _http_incoming.js";
    if (index == 7) return @"native _http_outgoing.js";
    if (index == 8) return @"native _http_server.js";
    if (index == 9) return @"native _linklist.js";
    if (index == 10) return @"native _stream_duplex.js";
    if (index == 11) return @"native _stream_passthrough.js";
    if (index == 12) return @"native _stream_readable.js";
    if (index == 13) return @"native _stream_transform.js";
    if (index == 14) return @"native _stream_writable.js";
    if (index == 15) return @"native _tls_common.js";
    if (index == 16) return @"native _tls_legacy.js";
    if (index == 17) return @"native _tls_wrap.js";
    if (index == 18) return @"native assert.js";
    if (index == 19) return @"native buffer.js";
    if (index == 20) return @"native child_process.js";
    if (index == 21) return @"native cluster.js";
    if (index == 22) return @"native console.js";
    if (index == 23) return @"native constants.js";
    if (index == 24) return @"native crypto.js";
    if (index == 25) return @"native dgram.js";
    if (index == 26) return @"native dns.js";
    if (index == 27) return @"native domain.js";
    if (index == 28) return @"native events.js";
    if (index == 29) return @"native freelist.js";
    if (index == 30) return @"native fs.js";
    if (index == 31) return @"native http.js";
    if (index == 32) return @"native https.js";
    if (index == 33) return @"native module.js";
    if (index == 34) return @"native net.js";
    if (index == 35) return @"native os.js";
    if (index == 36) return @"native path.js";
    if (index == 37) return @"native punycode.js";
    if (index == 38) return @"native querystring.js";
    if (index == 39) return @"native readline.js";
    if (index == 40) return @"native repl.js";
    if (index == 41) return @"native smalloc.js";
    if (index == 42) return @"native stream.js";
    if (index == 43) return @"native string_decoder.js";
    if (index == 44) return @"native sys.js";
    if (index == 45) return @"native timers.js";
    if (index == 46) return @"native tls.js";
    if (index == 47) return @"native tracing.js";
    if (index == 48) return @"native tty.js";
    if (index == 49) return @"native url.js";
    if (index == 50) return @"native util.js";
    if (index == 51) return @"native vm.js";
    if (index == 52) return @"native zlib.js";

    NSString *message = [NSString stringWithFormat:@"Unknown index %lu", (unsigned long)index];
    @throw [NSException exceptionWithName:NSInternalInconsistencyException reason:message userInfo:nil];
}

- (NSString *)nameOfModuleAtIndex:(NSUInteger)index
{
    if (index == 0) return @"node";
    if (index == 1) return @"iOS";
    if (index == 2) return @"_debugger";
    if (index == 3) return @"_http_agent";
    if (index == 4) return @"_http_client";
    if (index == 5) return @"_http_common";
    if (index == 6) return @"_http_incoming";
    if (index == 7) return @"_http_outgoing";
    if (index == 8) return @"_http_server";
    if (index == 9) return @"_linklist";
    if (index == 10) return @"_stream_duplex";
    if (index == 11) return @"_stream_passthrough";
    if (index == 12) return @"_stream_readable";
    if (index == 13) return @"_stream_transform";
    if (index == 14) return @"_stream_writable";
    if (index == 15) return @"_tls_common";
    if (index == 16) return @"_tls_legacy";
    if (index == 17) return @"_tls_wrap";
    if (index == 18) return @"assert";
    if (index == 19) return @"buffer";
    if (index == 20) return @"child_process";
    if (index == 21) return @"cluster";
    if (index == 22) return @"console";
    if (index == 23) return @"constants";
    if (index == 24) return @"crypto";
    if (index == 25) return @"dgram";
    if (index == 26) return @"dns";
    if (index == 27) return @"domain";
    if (index == 28) return @"events";
    if (index == 29) return @"freelist";
    if (index == 30) return @"fs";
    if (index == 31) return @"http";
    if (index == 32) return @"https";
    if (index == 33) return @"module";
    if (index == 34) return @"net";
    if (index == 35) return @"os";
    if (index == 36) return @"path";
    if (index == 37) return @"punycode";
    if (index == 38) return @"querystring";
    if (index == 39) return @"readline";
    if (index == 40) return @"repl";
    if (index == 41) return @"smalloc";
    if (index == 42) return @"stream";
    if (index == 43) return @"string_decoder";
    if (index == 44) return @"sys";
    if (index == 45) return @"timers";
    if (index == 46) return @"tls";
    if (index == 47) return @"tracing";
    if (index == 48) return @"tty";
    if (index == 49) return @"url";
    if (index == 50) return @"util";
    if (index == 51) return @"vm";
    if (index == 52) return @"zlib";

    NSString *message = [NSString stringWithFormat:@"Unknown index %lu", (unsigned long)index];
    @throw [NSException exceptionWithName:NSInternalInconsistencyException reason:message userInfo:nil];
}

- (NSString *)sourceOfScriptAtIndex:(NSUInteger)index
{
    return sources[index];
}

@end
